diff --git a/.github/workflows/build.yml b/.github/workflows/build.yml
index ffb53a5d..13d0f376 100755
--- a/.github/workflows/build.yml
+++ b/.github/workflows/build.yml
@@ -8,18 +8,21 @@ on:
       publish:
         description: "Publish Release"
         type: boolean
-        required: false
+        default: true
+        required: true
       text:
         description: "Release Description"
         required: false
-      source:
+      source_only:
         description: "Skip building binaries, distribute only unified source"
         type: boolean
+        default: false
         required: false
-      updater:
+      skip_updater:
         description: "Ship binaries without updater"
         type: boolean
         required: false
+        default: false
       build_windows_x64:
         description: "Build windows x64 binaries"
         type: boolean
@@ -45,6 +48,11 @@ on:
         type: boolean
         default: false
         required: false
+      publish_winget:
+        description: "Publish WinGet manifest"
+        type: boolean
+        default: true
+        required: false
 jobs:
   build-go:
     permissions:
@@ -78,17 +86,19 @@ jobs:
     runs-on: ubuntu-latest
     steps:
       - name: Checking out sources
-        if: matrix.cross_os == 'public' || ( github.event.inputs.source != 'true' && matrix.allow == 'true' )
+        if: matrix.cross_os == 'public' || ( github.event.inputs.source_only  != 'true' && matrix.allow == 'true' )
         uses: actions/checkout@v4.2.2
+        with:
+          submodules: 'true'
       - name: Cache Common Download
         id: cache-common
-        if: matrix.cross_os == 'public' || ( github.event.inputs.source != 'true' && matrix.allow == 'true' )
+        if: matrix.cross_os != 'public' && ( github.event.inputs.source_only  != 'true' && matrix.allow == 'true' )
         uses: actions/cache@v4.2.3
         with:
           path: artifacts.tgz
           key: CommonCache-${{ matrix.cross_os }}-${{ matrix.cross_arch }}-${{ hashFiles('script/build_go.sh', 'core/*') }}-${{ matrix.go_version }}
       - name: Install Golang
-        if: ( matrix.cross_os == 'public' || ( github.event.inputs.source != 'true' && matrix.allow == 'true' ) ) && steps.cache-common.outputs.cache-hit != 'true'
+        if: ( matrix.cross_os == 'public' || ( github.event.inputs.source_only  != 'true' && matrix.allow == 'true' ) ) && steps.cache-common.outputs.cache-hit != 'true'
         uses: actions/setup-go@v5.5.0
         with:
           go-version: ${{ matrix.go_version }}
@@ -96,16 +106,16 @@ jobs:
             core/server/go.sum
             core/updater/go.sum
       - name: Linux - Install apt dependencies
-        if: matrix.cross_os == 'public' || ( github.event.inputs.source != 'true' && matrix.allow == 'true' )
+        if: matrix.cross_os == 'public' || ( github.event.inputs.source_only  != 'true' && matrix.allow == 'true' )
         uses: awalsh128/cache-apt-pkgs-action@latest
         with:
           packages: thrift-compiler
           version: 1.0
       - name: Build golang parts
-        if: steps.cache-common.outputs.cache-hit != 'true' && matrix.cross_os != 'public' && ( github.event.inputs.source != 'true' && matrix.allow == 'true' )
+        if: steps.cache-common.outputs.cache-hit != 'true' && matrix.cross_os != 'public' && ( github.event.inputs.source_only  != 'true' && matrix.allow == 'true' )
         shell: bash
         run: |
-          if [[ ${{ github.event.inputs.updater }} == 'true' ]]; then
+          if [[ ${{ github.event.inputs.skip_updater }} == 'true' ]]; then
             export SKIP_UPDATER=y
           fi
           GO_MOD_TIDY=yes GOOS=${{ matrix.cross_os }} GOARCH=${{ matrix.cross_arch }} ./script/build_go.sh
@@ -115,10 +125,10 @@ jobs:
         run: |
           env INPUT_VERSION=${{ github.event.inputs.tag }} bash -x ./script/deploy_vendor.sh
       - name: Tar files
-        if: ( matrix.cross_os == 'public' || ( github.event.inputs.source != 'true' && matrix.allow == 'true' ) ) && steps.cache-common.outputs.cache-hit != 'true'
+        if: matrix.cross_os == 'public' || ( github.event.inputs.source_only  != 'true' && matrix.allow == 'true' && steps.cache-common.outputs.cache-hit != 'true' )
         run: tar czvf artifacts.tgz ./deployment
       - name: Uploading Artifact
-        if: matrix.cross_os == 'public' || ( github.event.inputs.source != 'true' && matrix.allow == 'true' )
+        if: matrix.cross_os == 'public' || ( github.event.inputs.source_only  != 'true' && matrix.allow == 'true' )
         uses: actions/upload-artifact@v4.6.2
         with:
           name: nekobox-${{ github.sha }}-Common-${{ matrix.cross_os }}-${{ matrix.cross_arch }}
@@ -148,19 +158,19 @@ jobs:
       INPUT_VERSION: ${{ github.event.inputs.tag }}
     steps:
       - name: Checking out sources
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: actions/checkout@v4.2.2
         with:
           submodules: "recursive"
 
       - name: Install NSIS
         id: nsis
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true' && matrix.target == 'x86_64'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true' && matrix.target == 'x86_64'
         uses: negrutiu/nsis-install@v2
 
       - name: vcpkg build
         uses: johnwason/vcpkg-action@v7
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         id: vcpkg
         with:
           pkgs: thrift
@@ -168,20 +178,20 @@ jobs:
           token: ${{ github.token }}
           
       - name: Download Artifacts
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: actions/download-artifact@v4.3.0
         with:
           path: download-artifact
 
       - name: Download Srslist
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         shell: bash
         run: |
           curl -fLso "srslist.json" "https://github.com/qr243vbi/ruleset/raw/refs/heads/rule-set/srslist.json"
           mkdir build
 
       - name: Install Qt
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: jurplel/install-qt-action@v4.3.0
         with:
           version: ${{ matrix.qt_version }}
@@ -191,59 +201,35 @@ jobs:
           cache-key-prefix: QtCache-${{ matrix.platform }}-${{ matrix.target }}
 
       - name: Install MSVC compiler
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: ilammy/msvc-dev-cmd@v1
         with:
           arch: ${{ matrix.target }}
           
       - name: Cache Builds
         id: cache-common
-        if: github.event.inputs.source != 'true' && matrix.allow == 'true'
+        if: github.event.inputs.source_only  != 'true' && matrix.allow == 'true'
         uses: actions/cache@v4.2.3
         with:
           path: build
           key: CommonCache-${{ matrix.platform }}-${{ matrix.target }}-${{ github.event.inputs.tag }}
 
       - name: Windows - Generate MakeFile and Build
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         shell: bash
         run: |
-          if [[ ${{ github.event.inputs.updater }} == 'true' ]]; then export SKIP_UPDATE_BUTTON=ON; else export SKIP_UPDATE_BUTTON=OFF; fi
-          cmake  -DCMAKE_TOOLCHAIN_FILE='${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake' '-DVCPKG_TARGET_TRIPLET=${{ matrix.triplet }}' -DVCPKG_MANIFEST_MODE=OFF -DSKIP_UPDATE_BUTTON="${SKIP_UPDATE_BUTTON}" -DCMAKE_BUILD_TYPE=Release -S . -B build
+          if [[ ${{ github.event.inputs.skip_updater }} == 'true' ]]; then export SKIP_UPDATE_BUTTON=ON; else export SKIP_UPDATE_BUTTON=OFF; fi
+          cmake  -DCMAKE_TOOLCHAIN_FILE='${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake' '-DVCPKG_TARGET_TRIPLET=${{ matrix.triplet }}' -DVCPKG_MANIFEST_MODE=OFF -DSKIP_UPDATE_BUTTON="${SKIP_UPDATE_BUTTON}" -DCMAKE_BUILD_TYPE=Release "-DNKR_DEFAULT_VERSION=${INPUT_VERSION}" -S . -B build
           cmake --build build --config Release --verbose
           ./script/deploy_windows.sh "new-${{ matrix.target }}"
 
-      - name: Build Installer with NSIS for windows64
-        shell: cmd
-        if: matrix.allow == 'true' && matrix.target == 'x86_64' && github.event.inputs.source != 'true'
-        run: |
-          cp .\script\windows_installer.nsi .
-          makensis.exe windows_installer.nsi
-          install -D nekobox_setup.exe deployment/nekobox_setup.exe
-
-      - name: Build Installer with NSIS for windows32
-        shell: cmd
-        if: matrix.allow == 'true' && matrix.target == 'i686' && github.event.inputs.source != 'true'
-        run: |
-          cp .\script\windows_installer.nsi .
-          makensis "/DDIRECTORY=windows32"  windows_installer.nsi
-          install -D nekobox_setup.exe deployment/nekobox_setup32.exe
-
-      - name: Build Installer with NSIS for windows-arm64
-        shell: cmd
-        if: matrix.allow == 'true' && matrix.target == 'arm64' && github.event.inputs.source != 'true'
-        run: |
-          cp .\script\windows_installer.nsi .
-          makensis "/DDIRECTORY=windows-arm64" windows_installer.nsi
-          install -D nekobox_setup.exe deployment/nekobox_setup_arm64.exe
-
       - name: Tar files
         shell: bash
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         run: tar czvf artifacts.tgz ./deployment
 
       - name: Uploading Artifact
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: actions/upload-artifact@v4.6.2
         with:
           name: nekobox-${{ github.sha }}-${{ matrix.platform }}-${{ matrix.target }}-Qt${{ matrix.qt_version }}
@@ -272,19 +258,19 @@ jobs:
       INPUT_VERSION: ${{ github.event.inputs.tag }}
     steps:
       - name: Checking out sources
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: actions/checkout@v4.2.2
         with:
           submodules: "recursive"
 
       - name: Download Artifacts
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: actions/download-artifact@v4.3.0
         with:
           path: download-artifact
 
       - name: Install Qt
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: jurplel/install-qt-action@v4.3.0
         with:
           version: ${{ matrix.qt_version }}
@@ -294,14 +280,14 @@ jobs:
           cache-key-prefix: QtCache-${{ matrix.platform }}-${{ matrix.target }}
 
       - name: Download Srslist
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         shell: bash
         run: |
           curl -fLso "srslist.json" "https://github.com/qr243vbi/ruleset/raw/refs/heads/rule-set/srslist.json"
           mkdir build
 
       - name: Linux - Install apt dependencies
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: awalsh128/cache-apt-pkgs-action@latest
         with:
           packages: libfuse2 patchelf squashfs-tools openssl-dev openssl thrift-compiler libthrift-dev
@@ -309,30 +295,30 @@ jobs:
 
       - name: Cache Builds
         id: cache-common
-        if: github.event.inputs.source != 'true' && matrix.allow == 'true'
+        if: github.event.inputs.source_only  != 'true' && matrix.allow == 'true'
         uses: actions/cache@v4.2.3
         with:
           path: build
           key: CommonCache-${{ matrix.platform }}-${{ matrix.target }}-${{ github.event.inputs.tag }}
 
       - name: Linux - Generate MakeFile and Build
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         shell: bash
         run: |
           cd build
-          if [[ ${{ github.event.inputs.updater }} == 'true' ]]; then export SKIP_UPDATE_BUTTON=ON; else export SKIP_UPDATE_BUTTON=OFF; fi
-          cmake -GNinja -DSKIP_UPDATE_BUTTON="${SKIP_UPDATE_BUTTON}" -DCMAKE_BUILD_TYPE=Release ..
+          if [[ ${{ github.event.inputs.skip_updater }} == 'true' ]]; then export SKIP_UPDATE_BUTTON=ON; else export SKIP_UPDATE_BUTTON=OFF; fi
+          cmake -GNinja -DSKIP_UPDATE_BUTTON="${SKIP_UPDATE_BUTTON}" -DCMAKE_BUILD_TYPE=Release "-DNKR_DEFAULT_VERSION=${INPUT_VERSION}" ..
           ninja
           cd ..
           bash -x ./script/deploy_linux64.sh
 
       - name: Tar files
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         shell: bash
         run: tar czvf artifacts.tgz ./deployment
 
       - name: Uploading Artifact
-        if: matrix.allow == 'true' && github.event.inputs.source != 'true'
+        if: matrix.allow == 'true' && github.event.inputs.source_only  != 'true'
         uses: actions/upload-artifact@v4.6.2
         with:
           name: nekobox-${{ github.sha }}-${{ matrix.platform }}-${{ matrix.target }}-Qt${{ matrix.qt_version }}
@@ -381,30 +367,11 @@ jobs:
           cd deployment
           rm -rf *.pdb ||:
           ####
-          if [[ -d linux-amd64 ]]; then
-            mv linux-amd64 nekobox
-            if [[ -f nekobox/nekobox-x86_64.AppImage ]]; then
-                mv nekobox/nekobox-x86_64.AppImage ./nekobox-${{ github.event.inputs.tag }}-x86_64-linux.AppImage
-            fi
-            zip -9 -r $version_standalone-linux-amd64.zip nekobox
-            rm -rf nekobox linux-amd64
-          fi
-          ####
-          if [[ -d linux-arm64 ]]; then
-            mv linux-arm64 nekobox
-            if [[ -f nekobox/nekobox-aarch64.AppImage ]]; then
-                mv nekobox/nekobox-aarch64.AppImage ./nekobox-${{ github.event.inputs.tag }}-aarch64-linux.AppImage
-            fi
-            zip -9 -r $version_standalone-linux-arm64.zip nekobox
-            rm -rf nekobox linux-arm64
-          fi
-          ####
           if [[ -f nekobox_setup.exe ]]; then
             CHECKSUM=$(sha256sum nekobox_setup.exe)
             export sha_x64="${CHECKSUM%% *}"
             mv nekobox_setup.exe $version_standalone-windows64-installer.exe
             mv windows64 nekobox
-            rm nekobox/config
             zip -9 -r $version_standalone-windows64.zip nekobox
             rm -rf nekobox windows64
           fi
@@ -419,7 +386,6 @@ jobs:
           if [[ -f nekobox_setup_arm64.exe ]]; then
             mv nekobox_setup_arm64.exe $version_standalone-windows-arm64-installer.exe
             mv windows-arm64 nekobox
-            rm nekobox/config
             zip -9 -r $version_standalone-windows-arm64.zip nekobox
             rm -rf nekobox windows-arm64
           fi
@@ -427,7 +393,6 @@ jobs:
           if [[ -f nekobox_setup32.exe ]]; then
             mv nekobox_setup32.exe $version_standalone-windows32-installer.exe
             mv windows32 nekobox
-            rm nekobox/config
             zip -9 -r $version_standalone-windows32.zip nekobox
             rm -rf nekobox windows32
           fi
@@ -435,7 +400,6 @@ jobs:
           if [[ -f nekobox_setup_legacy.exe ]]; then
             mv nekobox_setup_legacy.exe $version_standalone-windowslegacy64-installer.exe
             mv windowslegacy64 nekobox
-            rm nekobox/config
             zip -9 -r $version_standalone-windowslegacy64.zip nekobox
             rm -rf nekobox windowslegacy64
           fi
@@ -478,8 +442,8 @@ jobs:
           export OBS_USER="${{ secrets.OBS_USER }}"
           export OBS_PASSWORD="${{ secrets.OBS_PASSWORD }}"
           export OBS_HOOK_TOKEN="${{ secrets.OBS_HOOK_TOKEN }}"
-          export INPUT_VERSION=${{ github.event.inputs.tag }}
-          bash ./script/trigger_open_build_service.sh
+          export INPUT_VERSION="${{ github.event.inputs.tag }}"
+          bash ./script/trigger_open_build_service.sh ||:
           bash ./script/generate_pkgbuild.sh
 
       - name: Publish AUR package
@@ -493,3 +457,27 @@ jobs:
           commit_message: Update AUR package
           ssh_keyscan_types: rsa,ecdsa,ed25519
 
+      - name: Linux - Install apt dependencies
+        if: github.event.inputs.build_windows_arm64 == 'true' && github.event.inputs.build_windows_x64 == 'true' && github.event.inputs.publish_winget == 'true' && github.event.inputs.source_only  != 'true'
+        uses: awalsh128/cache-apt-pkgs-action@latest
+        with:
+          packages: curl jq git gh
+          version: 1.0
+          
+      - name: Cache winget-pkgs
+        if: github.event.inputs.build_windows_arm64 == 'true' && github.event.inputs.build_windows_x64 == 'true' && github.event.inputs.publish_winget == 'true' && github.event.inputs.source_only  != 'true'
+        uses: actions/cache@v4.2.3
+        with:
+          path: build
+          key: CommonCache-WingetPkgs-Cache
+
+      - name: Run winget-pkgs
+        if: github.event.inputs.build_windows_arm64 == 'true' && github.event.inputs.build_windows_x64 == 'true' && github.event.inputs.publish_winget == 'true' && github.event.inputs.source_only  != 'true'
+        shell: bash
+        run: |
+          export GITHUB_TOKEN="${{ secrets.WINGET_TOKEN }}"
+          export INPUT_VERSION="${{ github.event.inputs.tag }}"
+          export EMAIL="${{ secrets.EMAIL }}"
+          bash ./script/trigger_winget_pkgs.sh
+
+
diff --git a/.gitignore b/.gitignore
index 3f055343..f1ef15e1 100755
--- a/.gitignore
+++ b/.gitignore
@@ -3,8 +3,15 @@
 gen-cpp
 core/server/gen/libcore_service-remote
 core/server/gen/*.go
+script/winget-pkgs
+run.cmd
+run86.cmd
+*.zip
 SingBox.Version
+/script/nekobox
+/winget-pkgs
 version.txt
+global.ini
 /config
 /updater
 /vcpkg*
diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 00000000..3072971d
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "core/server/sing-box"]
+	path = core/server/sing-box
+	url = https://github.com/qr243vbi/sing-box
diff --git a/3rdparty/WinCommander.cpp b/3rdparty/WinCommander.cpp
index 6172259e..855813c3 100755
--- a/3rdparty/WinCommander.cpp
+++ b/3rdparty/WinCommander.cpp
@@ -45,10 +45,36 @@ execution or wait for the exit of the launched process
 \n
 Returns the return value of the executed command
 */
+
+QString escapeSpecialCharacters(const QString &arg) {
+    QString escapedArg = arg;
+
+    // Escape double quotes
+    escapedArg.replace("\"", "\\\"");  // Replace " with \"
+
+    // Escape other special characters
+    escapedArg.replace("&", "^&");  // Escape &
+    escapedArg.replace("|", "^|");  // Escape |
+    escapedArg.replace("<", "^<");   // Escape <
+    escapedArg.replace(">", "^>");   // Escape >
+    escapedArg.replace("(", "^(");   // Escape (
+    escapedArg.replace(")", "^)");   // Escape )
+    escapedArg.replace("^", "^^");    // Escape ^
+    escapedArg.replace("%", "^^^%");   // Escape % in batch files
+
+    return escapedArg;
+}
+
 uint WinCommander::runProcessElevated(const QString &path,
                                       const QStringList &parameters,
                                       const QString &workingDir,
                                       int nShow, bool aWait) {
+    return runProcess(path, parameters, workingDir, nShow, aWait, true);
+}
+uint WinCommander::runProcess(const QString &path,
+                                          const QStringList &parameters,
+                                          const QString &workingDir,
+                                int nShow, bool aWait, bool elevated) {
     uint result = 0;
 
 #ifdef Q_OS_WIN
@@ -56,7 +82,7 @@ uint WinCommander::runProcessElevated(const QString &path,
     HWND hwnd = NULL;
     LPCTSTR pszPath = (LPCTSTR)path.utf16();
     foreach(QString item, parameters)
-        params += "\"" + item + "\" ";
+        params += "\"" + escapeSpecialCharacters(item) + "\" ";
 
     LPCTSTR pszParameters = (LPCTSTR)params.utf16();
     QString dir;
@@ -74,7 +100,7 @@ uint WinCommander::runProcessElevated(const QString &path,
     shex.cbSize       = sizeof(shex);
     shex.fMask        = SEE_MASK_NOCLOSEPROCESS;
     shex.hwnd         = hwnd;
-    shex.lpVerb       = TEXT("runas");
+    shex.lpVerb       = elevated ? TEXT("runas") : TEXT("open");
     shex.lpFile       = pszPath;
     shex.lpParameters = pszParameters;
     shex.lpDirectory  = pszDirectory;
diff --git a/3rdparty/WinCommander.hpp b/3rdparty/WinCommander.hpp
index 66faea71..a3c9d9f2 100755
--- a/3rdparty/WinCommander.hpp
+++ b/3rdparty/WinCommander.hpp
@@ -32,10 +32,16 @@
 class WinCommander {
 public:
 
+    static uint runProcess(const QString &path,
+                                   const QStringList &parameters = QStringList(),
+                                   const QString &workingDir = QString(),
+                                   int nShow = SW_SHOWMINIMIZED, bool aWait = true,
+                           bool elevated = false);
+
     static uint runProcessElevated(const QString &path,
                                    const QStringList &parameters = QStringList(),
                                    const QString &workingDir = QString(),
                                    int nShow = SW_SHOWMINIMIZED, bool aWait = true);
 };
 
-#endif // WINCOMMANDER_H
\ No newline at end of file
+#endif // WINCOMMANDER_H
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8138ea38..8ded9f25 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -88,6 +88,7 @@ set(PROJECT_SOURCES
         src/main.cpp
         src/dataStore/Configs.cpp
         src/dataStore/Utils.cpp
+        src/global/GuiUtils.cpp
         src/global/HTTPRequestHelper.cpp
         src/global/DeviceDetailsHelper.cpp
         src/global/CountryHelper.cpp
@@ -122,12 +123,54 @@ set(PROJECT_SOURCES
         src/configs/proxy/Bean2CoreObj_box.cpp
         src/configs/proxy/Bean2Link.cpp
         src/configs/proxy/Link2Bean.cpp
-        ${NEKOBOX_INCLUDE}/configs/proxy/ChainBean.hpp # translate
-
+        ${NEKOBOX_INCLUDE}/configs/proxy/AbstractBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/AnyTLSBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/ChainBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/CustomBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/ExtraCore.h
+        ${NEKOBOX_INCLUDE}/configs/proxy/includes.h
+        ${NEKOBOX_INCLUDE}/configs/proxy/MieruBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/TorBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/Preset.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/QUICBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/ShadowSocksBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/ShadowTLSBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/SocksHttpBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/SSHBean.h
+        ${NEKOBOX_INCLUDE}/configs/proxy/Tailscale.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/TrojanVLESSBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/V2RayStreamSettings.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/VMessBean.hpp
+        ${NEKOBOX_INCLUDE}/configs/proxy/WireguardBean.h
         ${NEKOBOX_INCLUDE}/configs/sub/GroupUpdater.hpp
-        src/configs/sub/GroupUpdater.cpp
+        ${NEKOBOX_INCLUDE}/configs/ConfigBuilder.hpp
+        ${NEKOBOX_INCLUDE}/api/RPC.h
+        ${NEKOBOX_INCLUDE}/dataStore/ConfigItem.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/Configs.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/Const.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/Database.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/DataStore.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/Group.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/ProfileFilter.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/ProxyEntity.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/ResourceEntity.hpp
+        ${NEKOBOX_INCLUDE}/dataStore/RouteEntity.h
+        ${NEKOBOX_INCLUDE}/dataStore/Utils.hpp
+
+        ${NEKOBOX_INCLUDE}/global/CountryHelper.hpp
+        ${NEKOBOX_INCLUDE}/global/DeviceDetailsHelper.hpp
+        ${NEKOBOX_INCLUDE}/global/GuiUtils.hpp
+        ${NEKOBOX_INCLUDE}/global/HTTPRequestHelper.hpp
+        ${NEKOBOX_INCLUDE}/global/keyvaluerange.h
+
+        ${NEKOBOX_INCLUDE}/stats/traffic/TrafficData.hpp
+        ${NEKOBOX_INCLUDE}/stats/traffic/TrafficLooper.hpp
 
+        src/configs/sub/GroupUpdater.cpp
+        ${NEKOBOX_INCLUDE}/sys/AutoRun.hpp
         ${NEKOBOX_INCLUDE}/sys/Process.hpp
+        ${NEKOBOX_INCLUDE}/sys/Settings.h
+
         src/sys/Process.cpp
         src/sys/AutoRun.cpp
 
@@ -164,6 +207,9 @@ set(PROJECT_SOURCES
         ${NEKOBOX_INCLUDE}/ui/profile/edit_mieru.h
         src/ui/profile/edit_mieru.cpp
         ${NEKOBOX_INCLUDE}/ui/profile/edit_mieru.ui
+        ${NEKOBOX_INCLUDE}/ui/profile/edit_tor.h
+        src/ui/profile/edit_tor.cpp
+        ${NEKOBOX_INCLUDE}/ui/profile/edit_tor.ui
         ${NEKOBOX_INCLUDE}/ui/profile/edit_trojan_vless.h
         src/ui/profile/edit_trojan_vless.cpp
         ${NEKOBOX_INCLUDE}/ui/profile/edit_trojan_vless.ui
@@ -174,7 +220,6 @@ set(PROJECT_SOURCES
         ${NEKOBOX_INCLUDE}/ui/profile/edit_tailscale.h
         src/ui/profile/edit_tailscale.cpp
         ${NEKOBOX_INCLUDE}/ui/profile/edit_tailscale.ui
-        ${NEKOBOX_INCLUDE}/configs/proxy/Tailscale.hpp
 
         ${NEKOBOX_INCLUDE}/ui/profile/edit_quic.h
         src/ui/profile/edit_quic.cpp
@@ -224,25 +269,20 @@ set(PROJECT_SOURCES
 
         res/nekobox.qrc
         ${QV2RAY_RC}
-        ${NEKOBOX_INCLUDE}/dataStore/RouteEntity.h
         src/dataStore/RouteEntity.cpp
         src/dataStore/ResourceEntity.cpp
         res/darkstyle.qrc
         src/ui/profile/edit_ssh.cpp
         ${NEKOBOX_INCLUDE}/ui/profile/edit_ssh.h
         ${NEKOBOX_INCLUDE}/ui/profile/edit_ssh.ui
-        ${NEKOBOX_INCLUDE}/configs/proxy/SSHBean.h
         src/sys/Settings.cpp
 
-        src/sys/linux/LinuxCap.cpp
-
         src/sys/AutoRun.cpp
         src/sys/Process.cpp
         ${NEKOBOX_INCLUDE}/ui/mainwindow_interface.h
         ${NEKOBOX_INCLUDE}/stats/connections/connectionLister.hpp
         src/stats/connectionLister/connectionLister.cpp
         src/configs/proxy/Json2Bean.cpp
-        ${NEKOBOX_INCLUDE}/sys/windows/eventHandler.h
         src/dataStore/Group.cpp
         src/dataStore/ProxyEntity.cpp
 
@@ -263,14 +303,24 @@ set_property(TARGET nekobox PROPERTY AUTOMOC ON)
 set_property(TARGET nekobox PROPERTY AUTORCC ON)
 
 if(SKIP_UPDATE_BUTTON)
-    add_definitions(-DSKIP_UPDATE_BUTTON)
+    nkr_add_compile_definitions(SKIP_UPDATE_BUTTON=yes)
 endif()
 if(SKIP_JS_UPDATER)
-    add_definitions(-DSKIP_JS_UPDATER)
+    nkr_add_compile_definitions(SKIP_JS_UPDATER=yes)
 else()
     find_package(Qt6 REQUIRED COMPONENTS Qml)
     target_link_libraries(nekobox PRIVATE Qt6::Qml)
-    target_sources(nekobox PRIVATE src/js/js_updater.cpp ${NEKOBOX_INCLUDE}/js/js_updater.h res/nekobox_updater.qrc)
+    target_sources(nekobox
+            PRIVATE
+            src/js/js_updater.cpp
+            ${NEKOBOX_INCLUDE}/js/js_updater.h
+            ${NEKOBOX_INCLUDE}/js/blocking_queue.h
+            ${NEKOBOX_INCLUDE}/js/js_updater.h
+            ${NEKOBOX_INCLUDE}/js/message_queue.h
+            ${NEKOBOX_INCLUDE}/js/version.h
+
+            res/nekobox_updater.qrc
+    )
 endif()
 
 
diff --git a/README.md b/README.md
index b80c9541..b317f529 100755
--- a/README.md
+++ b/README.md
@@ -1,4 +1,4 @@
-# [NekoBox](https://github.com/qr243vbi/nekobox) for PC 
+# [HelBox](https://github.com/qr243vbi/nekobox) / [NekoBox](https://github.com/qr243vbi/nekobox) for PC 
 
 Qt based Desktop cross-platform GUI proxy utility, empowered by [Sing-box](https://github.com/SagerNet/sing-box)
 Supports Windows 11/10 (arm64, x86_64) / Linux  out of the box.
@@ -11,11 +11,15 @@ Supports Windows 11/10 (arm64, x86_64) / Linux  out of the box.
 
 ### OBS repository 
 [![build result](https://build.opensuse.org/projects/home:juzbun:NekoBox/packages/nekobox/badge.svg?type=percent)](https://build.opensuse.org/package/show/home:juzbun:NekoBox/nekobox) </br>
+
 [NekoBox repository](https://software.opensuse.org//download.html?project=home%3Ajuzbun%3ANekoBox&package=nekobox) for various linux distributions ([OpenSUSE](https://get.opensuse.org/), [Fedora](https://fedoraproject.org/), [Mageia](https://www.mageia.org/), [Debian](https://www.debian.org/), [Raspbian](https://www.raspberrypi.com/software/), [Ubuntu](https://ubuntu.com/), [Arch](https://archlinux.org/)).
 
 ### COPR repository
 [NekoBox repository](https://copr.fedorainfracloud.org/coprs/qr243vbi/NekoBox/) for various linux distributions ([RedHat](https://www.redhat.com), [Centos](https://www.centos.org), [OpenSUSE](https://get.opensuse.org/), [Fedora](https://fedoraproject.org/), [Mageia](https://www.mageia.org/), [Almalinux](https://almalinux.org/)).
 
+### WinGet Package
+- [![WinGet Page](https://img.shields.io/winget/v/qr243vbi.NekoBox)](https://winget.ragerworks.com/package/qr243vbi.NekoBox)
+
 ### Aur package
 - [source](https://aur.archlinux.org/packages/nekobox)
 
@@ -26,7 +30,7 @@ Supports Windows 11/10 (arm64, x86_64) / Linux  out of the box.
 
 ## Supported protocols
  
-  SOCKS ; HTTP(S) ; Shadowsocks ; Trojan ; VMess ; VLESS ; TUIC ; Hysteria ; Hysteria2 ; AnyTLS ; Mieru ; Wireguard ; SSH ; ShadowTLS ; Custom Outbound ; Custom Config ; Chaining outbounds ; Extra Core
+  SOCKS ; HTTP(S) ; Shadowsocks ; Trojan ; VMess ; VLESS ; TUIC ; Hysteria ; Hysteria2 ; AnyTLS ; Mieru ; Wireguard ; SSH ; ShadowTLS ; Custom Outbound ; Custom Config ; Chaining outbounds ; Extra Core ; Tor
 
 ## Subscription Formats
 
diff --git a/check_new_release.js b/check_new_release.js
index 129a0e2c..04866dd1 100755
--- a/check_new_release.js
+++ b/check_new_release.js
@@ -1,226 +1,339 @@
-var allow_beta_update = configs['allow_beta_update'];
-var exitFlag = false;
-var simple_mode = true;
-var resp = new HTTPResponse("https://api.github.com/repos/qr243vbi/nekobox/releases");
-var archive_extension = ".zip"
-var updater_args = [];
-var release_array = [];
-var is_newer = false;
-var stopFlag = false;
-var note_pre_release = '';
-var release_url = '';
-var release_note = '';
-var assets_name = '';
-var options = {};
-var release_download_url = '';
-var archive_name = '';
-var latest_tag_name = '';
-var chocolatey_package = (GlobalMap['chocolatey_package'] == 'true');
-
-if (file_exists(env["APPIMAGE"])){
-  if (file_exists(APPLICATION_DIR_PATH + "/" + env["NEKOBOX_APPIMAGE_CUSTOM_EXECUTABLE"])){
-    archive_extension = ".AppImage";
-    if (search == "linux-amd64"){
-      search = "x86_64-linux";
-    } else if (search == "linux-arm64"){
-      search = "aarch64-linux";
-    } else if (search == "linux-arm32"){
-      search = "armhf-linux";
-    } else if (search == "linux-i386"){
-      search = "i686-linux";
-    } else {
-      archive_extension = ".zip"
-    }
-  }
-}
-
-function isNewer(assetName) {
-    let curver = NKR_VERSION.trim();
-    if (!curver) {
-        return false;
-    }
-
-    const spl = assetName.split('-');
-    if (spl.length < 2) {
-        return false;
-    }
-
-    let version = spl[1]; // Extract version: 1.2.3
-    if (spl.length >= 3) {
-        const spl_2 = spl[2];
-        if (spl_2.includes("beta") || spl_2.includes("alpha") || spl_2.includes("rc")) {
-            version += "." + spl_2;
-        }
-    }
-
-    const parts = version.split('.'); // [1, 2, 3, beta, 13]
-    const currentParts = curver.split('.').map(part => part.replace("-", "."));
-
-    if (parts.length < 3 || currentParts.length < 3) {
-        log("1. Version strings seem to be invalid: " + curver + " and " + version);
-        return false;
-    }
-
-    const verNums = [];
-    const currNums = [];
-
-    // Add base version first
-    verNums.push(parseInt(parts[0], 10), parseInt(parts[1], 10), parseInt(parts[2], 10));
-    if (parts.length > 3) {
-        if (parts[3] === "alpha") verNums.push(1);
-        if (parts[3] === "beta") verNums.push(2);
-        if (parts[3] === "rc") verNums.push(3);
-        if (parts.length > 4) verNums.push(parseInt(parts[4], 10));
-    }
-
-    currNums.push(parseInt(currentParts[0], 10), parseInt(currentParts[1], 10), parseInt(currentParts[2], 10));
-    if (currentParts.length > 3) {
-        if (currentParts[3] === "alpha") currNums.push(1);
-        if (currentParts[3] === "beta") currNums.push(2);
-        if (currentParts[3] === "rc") currNums.push(3);
-        if (currentParts.length > 4) currNums.push(parseInt(currentParts[4], 10));
-    }
-
-    if (verNums.length < 3 || currNums.length < 3) {
-        log("2. Version strings seem to be invalid: " + curver + " and " + version);
-        return false;
-    }
-
-    for (let i = 0; i < 3; i++) {
-        if (verNums[i] > currNums[i]) return true;
-        if (verNums[i] < currNums[i]) return false;
-    }
-
-    // Equal base version, check beta-ness
-    if (verNums.length === 5 && currNums.length === 3) return false;
-    if (verNums.length === 3 && currNums.length === 5) return true;
-
-    if (verNums.length === 5 && currNums.length === 5) {
-        for (let i = 3; i < 5; i++) {
-            if (verNums[i] > currNums[i]) return true;
-            if (verNums[i] < currNums[i]) return false;
-        }
-    } else {
-        return false;
-    }
-
-    return false;
-}
-
-
-
-if (resp.error){
-    warning(
-        translate('Requesting update error: %1').replace('%1', resp.error),
-        translate('Update'));
-} else {
-    let array = JSON.parse(resp.text);
-	
-    for (let release of array){
-        if (!allow_beta_update) {
-            if (release["prerelease"]) {
-                continue;
-            }
-        }
-		
-        for (let asset of release["assets"]) {
-            let asset_name = asset["name"];
-
-            if (asset_name.includes(search) && asset_name.endsWith(archive_extension)) {
-                
-				if (exitFlag){
-                    let tag_name = release['tag_name'];
-                    if (isNewer(asset_name)) {
-                        release_array.push([tag_name, release['body']]);
-                    } else {
-                        stopFlag = true;
-                    }
-                } else {
-                    note_pre_release = release["prerelease"] ? " (Pre-release)" : "";
-                    release_url = release["html_url"];
-                    release_note = release["body"];
-                    assets_name = asset_name;
-					latest_tag_name = release['tag_name'];
-                    release_array.push([latest_tag_name, release_note]);
-                    release_download_url = asset["browser_download_url"];
-                    exitFlag = true;
-                    is_newer = isNewer(assets_name);
-                    stopFlag = !is_newer;
-                }
-                break;
-            }
-        }
-        if (exitFlag) {
-            if (stopFlag){
-                break;
-            }
-        }
-    }
-    let release_length = release_array.length;
-    if (release_length > 1) {
-        let ar = release_array[0];
-        release_note = ar[0] + ': ' + ar[1];
-        for (let i = 1 ; i < release_length ; i++ ) {
-            release_note += "\n"
-            ar = release_array[i];
-            release_note += ar[0] + ': ' + ar[1];
-        }
-    }
-archive_name = "downloads/" + assets_name;
-
-let release_download_url_flag = (release_download_url == '');
-
-log(translate("assets version is" + (is_newer ? "": " not") + " newer" + ((is_newer && release_download_url_flag) ? ", but download url is empty" : "") ), "Warn");
-
-if (release_download_url_flag || !is_newer){
-    warning(translate("No update"), translate("Update"));
-	is_newer = false;
-} else {
-	is_newer = false;
-    let array = [translate("Cancel"), translate("Open in browser")];
-    if (UpdaterExists){
-        array.push(translate("Update"));
-    }
-    let index = ask(
-        translate("Update found: %1\nRelease note:\n%2").
-            replace('%1', assets_name).replace('%2', release_note),
-        translate("Update"),
-            array
-    );
-    if (index == 1){
-        open_url(release_url);
-    }
-	
-    if (index == 2){
-		is_newer = false;
-        let errors = download(release_download_url, archive_name, true);
-		if (chocolatey_package){
-			let nupkg_errors = download(
-				"https://github.com/qr243vbi/nekobox/releases/download/"+
-				latest_tag_name+"/nekobox."+latest_tag_name+".nupkg", 
-				"downloads/nekobox."+latest_tag_name+".nupkg", true);
-			if (nupkg_errors == ''){
-				options['chocolatey_source'] = curdir_path('downloads');
-			}
-		}
-        if (errors == ''){
-            let index2 = ask(
-                translate("Update is ready, restart to install?"),
-                translate("Update"),
-                [translate("Yes"), translate("No")]
-            );
-			if (index2 == 0){
-				if (Object.keys(options).length > 0){
-					options['version'] = latest_tag_name;
-					updater_args = ['-options', utf8EncodeHex(JSON.stringify(options))]
-				}
-				is_newer = true;
-			}
-        } else {
-            warning(errors, translate("Failed to download update assets"));
-        }
-    }
-}
-
-}
-
+var allow_beta_update = configs['allow_beta_update'];
+var exitFlag = false;
+var simple_mode = true;
+var archive_extension = ".tar.gz"
+var updater_args = [];
+var release_array = [];
+var is_newer = false;
+var stopFlag = false;
+var note_pre_release = '';
+var release_url = '';
+var release_note = '';
+var assets_name = '';
+var options = {};
+var release_download_url = '';
+var archive_name = '';
+var latest_tag_name = '';
+var keep_running = false;
+
+log("Checking new version", "Info");
+
+function isNewerVersion(curver, version){
+    const parts = version.replace('-', '.').split('.'); // [1, 2, 3, beta, 13]
+    const currentParts = curver.replace("-", ".").split('.');
+
+    if (parts.length < 3 || currentParts.length < 3) {
+      //  log("1. Version strings seem to be invalid: " + curver + " and " + version);
+        return false;
+    }
+
+    const verNums = [];
+    const currNums = [];
+
+    // Add base version first
+    verNums.push(parseInt(parts[0], 10), parseInt(parts[1], 10), parseInt(parts[2], 10));
+    if (parts.length > 3) {
+        if (parts[3] === "alpha") verNums.push(1);
+        if (parts[3] === "beta") verNums.push(2);
+        if (parts[3] === "rc") verNums.push(3);
+        if (parts.length > 4) verNums.push(parseInt(parts[4], 10));
+    }
+
+    currNums.push(parseInt(currentParts[0], 10), parseInt(currentParts[1], 10), parseInt(currentParts[2], 10));
+    if (currentParts.length > 3) {
+        if (currentParts[3] === "alpha") currNums.push(1);
+        if (currentParts[3] === "beta") currNums.push(2);
+        if (currentParts[3] === "rc") currNums.push(3);
+        if (currentParts.length > 4) currNums.push(parseInt(currentParts[4], 10));
+    }
+
+    if (verNums.length < 3 || currNums.length < 3) {
+      //  log("2. Version strings seem to be invalid: " + curver + " and " + version);
+        return false;
+    }
+
+    for (let i = 0; i < 3; i++) {
+        if (verNums[i] > currNums[i]) return true;
+        if (verNums[i] < currNums[i]) return false;
+    }
+
+    // Equal base version, check beta-ness
+    if (verNums.length === 5 && currNums.length === 3) return false;
+    if (verNums.length === 3 && currNums.length === 5) return true;
+
+    if (verNums.length === 5 && currNums.length === 5) {
+        for (let i = 3; i < 5; i++) {
+            if (verNums[i] > currNums[i]) return true;
+            if (verNums[i] < currNums[i]) return false;
+        }
+    } else {
+        return false;
+    }
+
+    return false;
+}
+
+function getLatestWingetVersion(packageId) {
+    // Split "Publisher.Package"
+    var parts = packageId.split(".");
+    var publisher = parts[0];
+    var packageName = parts[1];
+    var firstLetter = publisher.charAt(0).toLowerCase();
+
+    // GitHub API URL for winget manifests
+    var url = "https://api.github.com/repos/microsoft/winget-pkgs/contents/manifests/"
+              + firstLetter + "/" + publisher + "/" + packageName;
+
+    // Synchronous HTTP request using your class
+    var res = new HTTPResponse(url);
+
+    if (res.error) {
+        return '0.0.0';
+    }
+
+    // Parse JSON
+    var data;
+    try {
+        data = JSON.parse(res.text);
+    } catch (e) {
+        return '0.0.0';
+    }
+
+    // Extract version folder names
+    var versions = [];
+    for (var i = 0; i < data.length; i++) {
+        if (data[i].type === "dir") {
+            versions.push(data[i].name);
+        }
+    }
+
+    if (versions.length === 0) {
+        return '0.0.0';
+    }
+
+    // Natural sort (numeric-aware)
+    versions.sort(function(a, b) {
+		if (a == b ) return 0;
+		if (isNewerVersion(a, b)){
+			return -1;
+		} else {
+			return 1;
+		}
+    });
+	
+    // Latest version is the last one
+    return versions[versions.length - 1];
+}
+
+var chocolatey_package = false;
+var winget_package = false;
+
+if (file_exists(env["APPIMAGE"])){
+  if (file_exists(APPLICATION_DIR_PATH + "/" + env["NEKOBOX_APPIMAGE_CUSTOM_EXECUTABLE"])){
+    archive_extension = ".AppImage";
+    if (search == "linux-amd64"){
+      search = "x86_64-linux";
+    } else if (search == "linux-arm64"){
+      search = "aarch64-linux";
+    } else if (search == "linux-arm32"){
+      search = "armhf-linux";
+    } else if (search == "linux-i386"){
+      search = "i686-linux";
+    } else {
+      archive_extension = ".tar.gz"
+    }
+  }
+}
+
+if (search.includes('windows')){
+    archive_extension = '-installer.exe';
+    chocolatey_package = (GlobalMap['chocolatey_package'] == 'true');
+    winget_package = (GlobalMap['winget_package'] == 'true');
+    keep_running = true;
+}
+
+function isNewerAsset(assetName, curver) {
+	if (!curver){
+		curver = NKR_VERSION;
+	}
+	curver = curver.trim();
+    if (!curver) {
+        return '0.0.0';
+    }
+
+    const spl = assetName.split('-');
+    if (spl.length < 2) {
+        return false;
+    }
+
+    let version = spl[1]; // Extract version: 1.2.3
+    if (spl.length >= 3) {
+        const spl_2 = spl[2];
+        if (spl_2.includes("beta") || spl_2.includes("alpha") || spl_2.includes("rc")) {
+            version += "." + spl_2;
+        }
+    }
+
+	return isNewerVersion(curver, version);
+}
+
+
+var resp = new HTTPResponse("https://api.github.com/repos/qr243vbi/nekobox/releases");
+var data;
+var resp_error;
+if (!resp.error){	
+    try {
+        data = JSON.parse(resp.text);
+    } catch (e) {
+        resp_error = "Invalid JSON from GitHub";
+    }
+} else {
+	resp_error = resp.error;
+}
+
+if (resp_error){
+    warning(
+        translate('Requesting update error: %1').replace('%1', resp_error),
+        translate('Update'));
+} else {
+    var array = JSON.parse(resp.text);
+	var bound = '';
+	
+	if (winget_package){
+		bound = getLatestWingetVersion('qr243vbi.NekoBox');
+	}
+	
+    for (let release of array){
+        if (!allow_beta_update) {
+            if (release["prerelease"]) {
+                continue;
+            }
+        }
+		
+        for (let asset of release["assets"]) {
+            let asset_name = asset["name"];
+
+            if (asset_name.includes(search) && asset_name.endsWith(archive_extension)) {
+				if (bound == '' || !isNewerAsset(asset_name, bound) ){
+				if (exitFlag){
+                    let tag_name = release['tag_name'];
+                    if (isNewerAsset(asset_name)) {
+                        release_array.push([tag_name, release['body']]);
+                    } else {
+                        stopFlag = true;
+                    }
+                } else {
+                    note_pre_release = release["prerelease"] ? " (Pre-release)" : "";
+                    release_url = release["html_url"];
+                    release_note = release["body"];
+                    assets_name = asset_name;
+					latest_tag_name = release['tag_name'];
+                    release_array.push([latest_tag_name, release_note]);
+                    release_download_url = asset["browser_download_url"];
+                    exitFlag = true;
+                    is_newer = isNewerAsset(assets_name);
+                    stopFlag = !is_newer;
+                }
+                break;
+				}
+            }
+        }
+        if (exitFlag) {
+            if (stopFlag){
+                break;
+            }
+        }
+    }
+    let release_length = release_array.length;
+    if (release_length > 1) {
+        let ar = release_array[0];
+        release_note = ar[0] + ': ' + ar[1];
+        for (let i = 1 ; i < release_length ; i++ ) {
+            release_note += "\n"
+            ar = release_array[i];
+            release_note += ar[0] + ': ' + ar[1];
+        }
+    }
+archive_name = "downloads/" + assets_name;
+
+let release_download_url_flag = (release_download_url == '');
+
+log(translate("assets version is" + (is_newer ? "": " not") + " newer" + ((is_newer && release_download_url_flag) ? ", but download url is empty" : "") ), "Warn");
+
+if (release_download_url_flag || !is_newer){
+    warning(translate("No update"), translate("Update"));
+	is_newer = false;
+} else {
+	is_newer = false;
+    let array = [translate("Cancel"), translate("Open in browser")];
+    if (UpdaterExists){
+        array.push(translate("Update"));
+    }
+    let index = ask(
+        translate("Update found: %1\nRelease note:\n%2").
+            replace('%1', assets_name).replace('%2', release_note),
+        translate("Update"),
+            array
+    );
+    if (index == 1){
+        open_url(release_url);
+    }
+	
+    if (index == 2){
+		is_newer = false;
+		let errors = '';
+		if (!winget_package){
+			errors = download(release_download_url, archive_name, true);
+			if (chocolatey_package){
+				let nupkg_errors = download(
+					"https://github.com/qr243vbi/nekobox/releases/download/"+
+					latest_tag_name+"/nekobox."+latest_tag_name+".nupkg", 
+					"downloads/nekobox."+latest_tag_name+".nupkg", true);
+				if (nupkg_errors == ''){
+					options['chocolatey_source'] = curdir_path('downloads');
+				}
+			}
+			archive_name = curdir_path(archive_name);
+		} else {
+			options['winget_install'] = true;
+			archive_name = 'qr243vbi.NekoBox';
+		}
+        if (errors == ''){
+            let index2 = ask(
+                translate("Update is ready, restart to install?"),
+                translate("Update"),
+                [translate("No"), translate("Yes")]
+            );
+			if (index2 == 1){
+				
+				try{
+					var object_keys = Object.keys(options);
+				if (object_keys.length > 0){
+					for (var key of object_keys) {
+						var value = options[key];
+						updater_args.push('-' + key);
+						if (!(value === true)){
+							updater_args.push(value);
+						}
+					}
+					updater_args.push('-version')
+					updater_args.push(latest_tag_name);
+					updater_args.push('-name');
+                    updater_args.push(NKR_SOFTWARE_NAME);
+				}
+				
+					is_newer = true;
+				} catch (e){
+					info(e);
+					is_newer = false;
+				}
+				
+			}
+        } else {
+            warning(errors, translate("Failed to download update assets"));
+        }
+    }
+}
+
+}
+
diff --git a/check_routeprofiles.js b/check_routeprofiles.js
index 9176eb5a..72603aae 100755
--- a/check_routeprofiles.js
+++ b/check_routeprofiles.js
@@ -1,41 +1,41 @@
-var route_profiles = [];
-var route_profile_names = {};
-let resp = new HTTPResponse("https://api.github.com/repos/qr243vbi/ruleset/git/trees/routeprofiles");
-let release = JSON.parse(resp.text); // Assuming resp.data is a JSON string
-
-let locale = get_locale();
-
-let repl_reg = new RegExp('_', 'g');
-
-release.tree.forEach(asset => {
-    let profile = asset.path;
-    if (profile.endsWith('.json') && (profile.toLowerCase().startsWith('bypass') || profile.toLowerCase().startsWith('proxy'))) {
-        profile = profile.slice(0, -5); // Remove the last 5 characters (".json")
-        route_profiles.push(profile);
-        route_profile_names[profile] = profile.replace(repl_reg, ' '); 
-    }
-});
-
-
-let resp2 = new HTTPResponse("https://raw.githubusercontent.com/qr243vbi/ruleset/refs/heads/main/"+locale+".txt");
-if (resp2.error == ''){
-    let lines = resp2.text.split('\n');
-    lines.forEach(line => {
-        let ll = line.split(':');
-        route_profile_names[ll[0]] = ll[1];
-    });
-}
-
-function route_profile_get_json(profile){
-    let url = "https://raw.githubusercontent.com/qr243vbi/ruleset/routeprofiles/" + profile + ".json";
-    resp = new HTTPResponse(get_jsdelivr_link(url));
-    let text = resp.text;
-    if (!(resp.error == '')) {
-        warning( translate("Requesting profile error: %1").replace("%1", resp.error + "\n" + text), translate("Download Profiles"));
-        return "";
-    } else {
-        info( translate("Requesting profile success: %1").replace("%1", route_profile_names[profile] || profile), translate("Download Profiles"));
-    }
-    return [text, url];
-}
-
+var route_profiles = [];
+var route_profile_names = {};
+let resp = new HTTPResponse("https://api.github.com/repos/qr243vbi/ruleset/git/trees/routeprofiles");
+let release = JSON.parse(resp.text); // Assuming resp.data is a JSON string
+
+let locale = get_locale();
+
+let repl_reg = new RegExp('_', 'g');
+
+release.tree.forEach(asset => {
+    let profile = asset.path;
+    if (profile.endsWith('.json') && (profile.toLowerCase().startsWith('bypass') || profile.toLowerCase().startsWith('proxy'))) {
+        profile = profile.slice(0, -5); // Remove the last 5 characters (".json")
+        route_profiles.push(profile);
+        route_profile_names[profile] = profile.replace(repl_reg, ' '); 
+    }
+});
+
+
+let resp2 = new HTTPResponse("https://raw.githubusercontent.com/qr243vbi/ruleset/refs/heads/main/"+locale+".txt");
+if (resp2.error == ''){
+    let lines = resp2.text.split('\n');
+    lines.forEach(line => {
+        let ll = line.split(':');
+        route_profile_names[ll[0]] = ll[1];
+    });
+}
+
+function route_profile_get_json(profile){
+    let url = "https://raw.githubusercontent.com/qr243vbi/ruleset/routeprofiles/" + profile + ".json";
+    resp = new HTTPResponse(get_jsdelivr_link(url));
+    let text = resp.text;
+    if (!(resp.error == '')) {
+        warning( translate("Requesting profile error: %1").replace("%1", resp.error + "\n" + text), translate("Download Profiles"));
+        return "";
+    } else {
+        info( translate("Requesting profile success: %1").replace("%1", route_profile_names[profile] || profile), translate("Download Profiles"));
+    }
+    return [text, url];
+}
+
diff --git a/cmake/nkr.cmake b/cmake/nkr.cmake
index ee8fa94d..058177f8 100755
--- a/cmake/nkr.cmake
+++ b/cmake/nkr.cmake
@@ -1,20 +1,22 @@
 set(NKR_VERSION "DYNAMIC" CACHE STRING "A custom version string for application")
-set(NKR_DEFAULT_VERSION "1.0.0" CACHE STRING "A custom version string for application")
+# Check if INPUT_VERSION environment variable is defined
+set(NKR_DEFAULT_VERSION "1.0.0" CACHE STRING "A custom default version string for application")
+
+string(TIMESTAMP CURRENT_DATE_TIME "%Y-%m-%d")
+# Func
+function(nkr_add_compile_definitions arg)
+    message("[add_compile_definitions] ${ARGV}")
+    add_compile_definitions(${ARGV})
+endfunction()
+
+nkr_add_compile_definitions(NKR_TIMESTAMP=\"${CURRENT_DATE_TIME}\")
 
 if(NKR_VERSION STREQUAL "DYNAMIC")
-    add_compile_definitions(NKR_DYNAMIC_VERSION)
-    add_compile_definitions(NKR_DEFAULT_VERSION=\"${NKR_DEFAULT_VERSION}\")
-    list(APPEND PLATFORM_SOURCES ${NEKOBOX_INCLUDE}/js/version.h src/js/version.cpp)
+    nkr_add_compile_definitions(NKR_DEFAULT_VERSION=\"${NKR_DEFAULT_VERSION}\")
 else()
-    add_compile_definitions(NKR_VERSION=\"${NKR_VERSION}\")
+    nkr_add_compile_definitions(NKR_VERSION=\"${NKR_VERSION}\")
 endif()
 # Release
 
 # Debug
 set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -DNKR_CPP_DEBUG")
-
-# Func
-function(nkr_add_compile_definitions arg)
-    message("[add_compile_definitions] ${ARGV}")
-    add_compile_definitions(${ARGV})
-endfunction()
diff --git a/cmake/unix/unix.cmake b/cmake/unix/unix.cmake
index a4dc9f57..25e39f8b 100755
--- a/cmake/unix/unix.cmake
+++ b/cmake/unix/unix.cmake
@@ -1,2 +1,5 @@
-set(PLATFORM_SOURCES src/sys/linux/LinuxCap.cpp)
+set(PLATFORM_SOURCES
+    src/sys/linux/LinuxCap.cpp
+    ${NEKOBOX_INCLUDE}/sys/linux/LinuxCap.h
+)
 set(PLATFORM_LIBRARIES dl)
diff --git a/core/server/go.mod b/core/server/go.mod
index f7f19aea..34dbcd19 100644
--- a/core/server/go.mod
+++ b/core/server/go.mod
@@ -1,6 +1,6 @@
 module nekobox_core
 
-go 1.24.1
+go 1.24.0
 
 require (
 	github.com/NullYing/npipe v0.0.0-20250430055250-2d2a4d962cf7
@@ -8,8 +8,8 @@ require (
 	github.com/dustin/go-humanize v1.0.1
 	github.com/gofrs/uuid/v5 v5.4.0
 	github.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510
-	github.com/sagernet/sing v0.7.13
-	github.com/sagernet/sing-box v1.12.13
+	github.com/sagernet/sing v0.7.14
+	github.com/sagernet/sing-box v1.12.14
 	github.com/sagernet/sing-tun v0.7.3
 	github.com/spf13/cobra v1.10.2
 	golang.org/x/sys v0.39.0
@@ -31,7 +31,7 @@ require (
 	github.com/cretz/bine v0.2.0 // indirect
 	github.com/dblohm7/wingoes v0.0.0-20240119213807-a09d6be7affa // indirect
 	github.com/digitalocean/go-smbios v0.0.0-20180907143718-390a4f403a8e // indirect
-	github.com/enfein/mieru/v3 v3.21.0 // indirect
+	github.com/enfein/mieru/v3 v3.26.2 // indirect
 	github.com/fsnotify/fsnotify v1.7.0 // indirect
 	github.com/fxamacker/cbor/v2 v2.7.0 // indirect
 	github.com/gaissmai/bart v0.11.1 // indirect
@@ -129,4 +129,4 @@ require (
 	lukechampine.com/blake3 v1.3.0 // indirect
 )
 
-replace github.com/sagernet/sing-box => github.com/qr243vbi/sing-box v1.12.14
+replace github.com/sagernet/sing-box => ./sing-box
diff --git a/core/server/go.sum b/core/server/go.sum
index fff012d7..af7576ff 100644
--- a/core/server/go.sum
+++ b/core/server/go.sum
@@ -39,8 +39,8 @@ github.com/digitalocean/go-smbios v0.0.0-20180907143718-390a4f403a8e h1:vUmf0yez
 github.com/digitalocean/go-smbios v0.0.0-20180907143718-390a4f403a8e/go.mod h1:YTIHhz/QFSYnu/EhlF2SpU2Uk+32abacUYA5ZPljz1A=
 github.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=
 github.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=
-github.com/enfein/mieru/v3 v3.21.0 h1:t1EBT3Szyj8Fi/kWRI/soVHf6ubJ2ijIPGgNC3BGf88=
-github.com/enfein/mieru/v3 v3.21.0/go.mod h1:zJBUCsi5rxyvHM8fjFf+GLaEl4OEjjBXr1s5F6Qd3hM=
+github.com/enfein/mieru/v3 v3.26.2 h1:U/2XJc+3vrJD9r815FoFdwToQFEcqSOzzzWIPPhjfEU=
+github.com/enfein/mieru/v3 v3.26.2/go.mod h1:zJBUCsi5rxyvHM8fjFf+GLaEl4OEjjBXr1s5F6Qd3hM=
 github.com/fsnotify/fsnotify v1.7.0 h1:8JEhPFa5W2WU7YfeZzPNqzMP6Lwt7L2715Ggo0nosvA=
 github.com/fsnotify/fsnotify v1.7.0/go.mod h1:40Bi/Hjc2AVfZrqy+aj+yEI+/bRxZnMJyTJwOpGvigM=
 github.com/fxamacker/cbor/v2 v2.7.0 h1:iM5WgngdRBanHcxugY4JySA0nk1wZorNOpTgCMedv5E=
@@ -143,8 +143,6 @@ github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2 h1:Jamvg5psRI
 github.com/pmezard/go-difflib v1.0.1-0.20181226105442-5d4384ee4fb2/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/prometheus-community/pro-bing v0.4.0 h1:YMbv+i08gQz97OZZBwLyvmmQEEzyfyrrjEaAchdy3R4=
 github.com/prometheus-community/pro-bing v0.4.0/go.mod h1:b7wRYZtCcPmt4Sz319BykUU241rWLe1VFXyiyWK/dH4=
-github.com/qr243vbi/sing-box v1.12.14 h1:JNrnsVLxYUB+jTyywKwxMAzvC0emgEkENgUlJGn9J5Q=
-github.com/qr243vbi/sing-box v1.12.14/go.mod h1:cCxx34aXIIAtPU62CwieDyRwYvvmVRtHawVg+QDKqWs=
 github.com/quic-go/qpack v0.5.1 h1:giqksBPnT/HDtZ6VhtFKgoLOWmlyo9Ei6u9PqzIMbhI=
 github.com/quic-go/qpack v0.5.1/go.mod h1:+PC4XFrEskIVkcLzpEkbLqq1uCoxPhQuvK5rH1ZgaEg=
 github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
@@ -165,8 +163,8 @@ github.com/sagernet/nftables v0.3.0-beta.4/go.mod h1:OQXAjvjNGGFxaTgVCSTRIhYB5/l
 github.com/sagernet/quic-go v0.52.0-sing-box-mod.3 h1:ySqffGm82rPqI1TUPqmtHIYd12pfEGScygnOxjTL56w=
 github.com/sagernet/quic-go v0.52.0-sing-box-mod.3/go.mod h1:OV+V5kEBb8kJS7k29MzDu6oj9GyMc7HA07sE1tedxz4=
 github.com/sagernet/sing v0.6.9/go.mod h1:ARkL0gM13/Iv5VCZmci/NuoOlePoIsW0m7BWfln/Hak=
-github.com/sagernet/sing v0.7.13 h1:XNYgd8e3cxMULs/LLJspdn/deHrnPWyrrglNHeCUAYM=
-github.com/sagernet/sing v0.7.13/go.mod h1:ARkL0gM13/Iv5VCZmci/NuoOlePoIsW0m7BWfln/Hak=
+github.com/sagernet/sing v0.7.14 h1:5QQRDCUvYNOMyVp3LuK/hYEBAIv0VsbD3x/l9zH467s=
+github.com/sagernet/sing v0.7.14/go.mod h1:ARkL0gM13/Iv5VCZmci/NuoOlePoIsW0m7BWfln/Hak=
 github.com/sagernet/sing-mux v0.3.3 h1:YFgt9plMWzH994BMZLmyKL37PdIVaIilwP0Jg+EcLfw=
 github.com/sagernet/sing-mux v0.3.3/go.mod h1:pht8iFY4c9Xltj7rhVd208npkNaeCxzyXCgulDPLUDA=
 github.com/sagernet/sing-quic v0.5.2-0.20250909083218-00a55617c0fb h1:5Wx3XeTiKrrrcrAky7Hc1bO3CGxrvho2Vu5b/adlEIM=
diff --git a/core/server/server.go b/core/server/server.go
index efaa9b8c..3c12efff 100755
--- a/core/server/server.go
+++ b/core/server/server.go
@@ -1,15 +1,15 @@
 package main
 
 import (
+	"context"
+	"errors"
+	"fmt"
+	"log"
 	"nekobox_core/gen"
 	"nekobox_core/internal/boxbox"
 	"nekobox_core/internal/boxmain"
 	"nekobox_core/internal/process"
 	"nekobox_core/internal/sys"
-	"context"
-	"errors"
-	"fmt"
-	"log"
 	"os"
 	"strings"
 	"time"
@@ -35,7 +35,6 @@ var debug bool
 type server struct {
 }
 
-
 // To returns a pointer to the given value.
 func To[T any](v T) *T {
 	return &v
diff --git a/core/server/sing-box b/core/server/sing-box
new file mode 160000
index 00000000..9a43ca08
--- /dev/null
+++ b/core/server/sing-box
@@ -0,0 +1 @@
+Subproject commit 9a43ca08cd0a2f9dbf1efc77650625f758020716
diff --git a/core/updater/go.mod b/core/updater/go.mod
old mode 100755
new mode 100644
index 8d635d73..0928af43
--- a/core/updater/go.mod
+++ b/core/updater/go.mod
@@ -1,14 +1,16 @@
 module updater
 
-go 1.23
-
-toolchain go1.24.4
+go 1.24.1
 
 require github.com/codeclysm/extract/v4 v4.0.0
 
 require (
 	github.com/h2non/filetype v1.1.3 // indirect
-	github.com/juju/errors v1.0.0 // indirect
-	github.com/klauspost/compress v1.18.2 // indirect
-	github.com/ulikunitz/xz v0.5.15 // indirect
+	github.com/juju/errors v0.0.0-20181118221551-089d3ea4e4d5 // indirect
+	github.com/juju/loggo v1.0.0 // indirect
+	github.com/klauspost/compress v1.15.13 // indirect
+	github.com/kr/text v0.2.0 // indirect
+	github.com/ulikunitz/xz v0.5.12 // indirect
+	gopkg.in/mgo.v2 v2.0.0-20190816093944-a6b53ec6cb22 // indirect
+	gopkg.in/yaml.v2 v2.4.0 // indirect
 )
diff --git a/core/updater/go.sum b/core/updater/go.sum
old mode 100755
new mode 100644
index c0553c37..712671ff
--- a/core/updater/go.sum
+++ b/core/updater/go.sum
@@ -2,33 +2,42 @@ github.com/arduino/go-paths-helper v1.12.1 h1:WkxiVUxBjKWlLMiMuYy8DcmVrkxdP7aKxQ
 github.com/arduino/go-paths-helper v1.12.1/go.mod h1:jcpW4wr0u69GlXhTYydsdsqAjLaYK5n7oWHfKqOG6LM=
 github.com/codeclysm/extract/v4 v4.0.0 h1:H87LFsUNaJTu2e/8p/oiuiUsOK/TaPQ5wxsjPnwPEIY=
 github.com/codeclysm/extract/v4 v4.0.0/go.mod h1:SFju1lj6as7FvUgalpSct7torJE0zttbJUWtryPRG6s=
+github.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=
 github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/h2non/filetype v1.1.3 h1:FKkx9QbD7HR/zjK1Ia5XiBsq9zdLi5Kf3zGyFTAFkGg=
 github.com/h2non/filetype v1.1.3/go.mod h1:319b3zT68BvV+WRj7cwy856M2ehB3HqNOt6sy1HndBY=
-github.com/juju/errors v0.0.0-20220331221717-b38fca44723b h1:AxFeSQJfcm2O3ov1wqAkTKYFsnMw2g1B4PkYujfAdkY=
-github.com/juju/errors v0.0.0-20220331221717-b38fca44723b/go.mod h1:jMGj9DWF/qbo91ODcfJq6z/RYc3FX3taCBZMCcpI4Ls=
-github.com/juju/errors v1.0.0 h1:yiq7kjCLll1BiaRuNY53MGI0+EQ3rF6GB+wvboZDefM=
-github.com/juju/errors v1.0.0/go.mod h1:B5x9thDqx0wIMH3+aLIMP9HjItInYWObRovoCFM5Qe8=
+github.com/juju/ansiterm v0.0.0-20180109212912-720a0952cc2a/go.mod h1:UJSiEoRfvx3hP73CvoARgeLjaIOjybY9vj8PUPPFGeU=
+github.com/juju/errors v0.0.0-20181118221551-089d3ea4e4d5 h1:rhqTjzJlm7EbkELJDKMTU7udov+Se0xZkWmugr6zGok=
+github.com/juju/errors v0.0.0-20181118221551-089d3ea4e4d5/go.mod h1:W54LbzXuIE0boCoNJfwqpmkKJ1O4TCTZMetAt6jGk7Q=
+github.com/juju/loggo v1.0.0 h1:Y6ZMQOGR9Aj3BGkiWx7HBbIx6zNwNkxhVNOHU2i1bl0=
+github.com/juju/loggo v1.0.0/go.mod h1:NIXFioti1SmKAlKNuUwbMenNdef59IF52+ZzuOmHYkg=
+github.com/juju/testing v0.0.0-20200510222523-6c8c298c77a0 h1:+WWUkhnTjV6RNOxkcwk79qrjeyHEHvBzlneueBsatX4=
+github.com/juju/testing v0.0.0-20200510222523-6c8c298c77a0/go.mod h1:hpGvhGHPVbNBraRLZEhoQwFLMrjK8PSlO4D3nDjKYXo=
 github.com/klauspost/compress v1.15.13 h1:NFn1Wr8cfnenSJSA46lLq4wHCcBzKTSjnBIexDMMOV0=
 github.com/klauspost/compress v1.15.13/go.mod h1:QPwzmACJjUTFsnSHH934V6woptycfrDDJnH7hvFVbGM=
-github.com/klauspost/compress v1.18.2 h1:iiPHWW0YrcFgpBYhsA6D1+fqHssJscY/Tm/y2Uqnapk=
-github.com/klauspost/compress v1.18.2/go.mod h1:R0h/fSBs8DE4ENlcrlib3PsXS61voFxhIs2DeRhCvJ4=
-github.com/kr/pretty v0.2.1 h1:Fmg33tUaq4/8ym9TJN1x7sLJnHVwhP33CNkpYV/7rwI=
-github.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=
 github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
 github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
+github.com/lunixbochs/vtclean v0.0.0-20160125035106-4fbf7632a2c6/go.mod h1:pHhQNgMf3btfWnGBVipUOjRYhoOsdGqdm/+2c2E2WMI=
+github.com/mattn/go-colorable v0.0.6/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=
+github.com/mattn/go-isatty v0.0.0-20160806122752-66b8e73f3f5c/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=
+github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e h1:fD57ERR4JtEqsWbfPhv4DMiApHyliiK5xCTNVSPiaAs=
+github.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=
 github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
 github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
 github.com/ulikunitz/xz v0.5.12 h1:37Nm15o69RwBkXM0J6A5OlE67RZTfzUxTj8fB3dfcsc=
 github.com/ulikunitz/xz v0.5.12/go.mod h1:nbz6k7qbPmH4IRqmfOplQw/tblSgqTqBwxkY0oWt/14=
-github.com/ulikunitz/xz v0.5.15 h1:9DNdB5s+SgV3bQ2ApL10xRc35ck0DuIX/isZvIk+ubY=
-github.com/ulikunitz/xz v0.5.15/go.mod h1:nbz6k7qbPmH4IRqmfOplQw/tblSgqTqBwxkY0oWt/14=
 golang.org/x/sys v0.16.0 h1:xWw16ngr6ZMtmxDyKyIgsE93KNKz5HKmMa3b8ALHidU=
 golang.org/x/sys v0.16.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
-gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
-gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
+gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/check.v1 v1.0.0-20160105164936-4f90aeace3a2/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f h1:BLraFXnmrev5lT+xlilqcH8XK9/i0At2xKjWk4p6zsU=
+gopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/mgo.v2 v2.0.0-20190816093944-a6b53ec6cb22 h1:VpOs+IwYnYBaFnrNAeB8UUWtL3vEUnzSCL1nVjPhqrw=
+gopkg.in/mgo.v2 v2.0.0-20190816093944-a6b53ec6cb22/go.mod h1:yeKp02qBN3iKW1OzL3MGk2IdtZzaj7SFntXj72NppTA=
+gopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=
+gopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=
 gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
 gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
diff --git a/core/updater/main.go b/core/updater/main.go
index b139b84e..06ab7d0f 100755
--- a/core/updater/main.go
+++ b/core/updater/main.go
@@ -1,71 +1 @@
 package main
-
-import (
-	"io"
-	"log"
-	"os"
-	"os/exec"
-	"path/filepath"
-	"time"
-	"runtime"
-	"flag"
-)
-
-func main() {
-	// update & launcher
-	exe, err := os.Executable()
-	if err != nil {
-		panic(err.Error())
-	}
-	
-	verbose := flag.Bool("verbose", false, "verbose mode")
-	json_str := flag.String("options", "{}", "json options")
-
-	// Parse the flags
-	flag.Parse()
-	
-	run_json(*json_str);
-
-	// Get the positional arguments
-	args := flag.Args()
-
-	wd := args[1]
-	os.Chdir(wd)
-	box := args[0]
-	exe = filepath.Base(os.Args[0])
-	log.Println("exe:", exe, "exe dir:", wd, "box: ", box)
-	{
-		time.Sleep(2 * time.Second)
-		{
-			os.Chdir(wd)
-			// 1. update files
-			Updater(box, *verbose)
-			// 2. start
-			if runtime.GOOS == "windows" {
-				exec.Command("./nekobox.exe",  args[2:]...).Start()
-			} else {
-				exec.Command("./nekobox",  args[2:]...).Start()
-			}
-		}
-		return
-	}
-}
-
-func Copy(src string, dst string) {
-	srcFile, err := os.Open(src)
-	if err != nil {
-		log.Println(err)
-		return
-	}
-	defer srcFile.Close()
-	dstFile, err := os.OpenFile(dst, os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0644)
-	if err != nil {
-		log.Println(err)
-		return
-	}
-	defer dstFile.Close()
-	_, err = io.Copy(dstFile, srcFile)
-	if err != nil {
-		log.Println(err)
-	}
-}
diff --git a/core/updater/main_linux.go b/core/updater/main_linux.go
index 6a24b930..b78db62b 100644
--- a/core/updater/main_linux.go
+++ b/core/updater/main_linux.go
@@ -1,4 +1,34 @@
 package main
 
-func run_json(text string){
-}
\ No newline at end of file
+import (
+	"flag"
+	"log"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"time"
+)
+
+func main() {
+	// update & launcher
+	exe, err := os.Executable()
+	if err != nil {
+		panic(err.Error())
+	}
+	verbose := flag.Bool("verbose", false, "verbose mode")
+	// Parse the flags
+	flag.Parse()
+	// Get the positional arguments
+	args := flag.Args()
+	wd := args[1]
+	box := args[0]
+	exe = filepath.Base(os.Args[0])
+	log.Println("exe:", exe, "exe dir:", wd, "box: ", box)
+	time.Sleep(2 * time.Second)
+	os.Chdir(wd)
+	Updater(box, *verbose)
+	os.Chmod("nekobox", 0755)
+	os.Chmod("nekobox_core", 0755)
+	os.Chmod("updater", 0755)
+	exec.Command("./nekobox", args[2:]...).Start()
+}
diff --git a/core/updater/main_windows.go b/core/updater/main_windows.go
index 098d84fd..ec69d451 100644
--- a/core/updater/main_windows.go
+++ b/core/updater/main_windows.go
@@ -1,40 +1,79 @@
 package main
 
 import (
-	"encoding/json"
-	"encoding/hex"
-	"os/exec"
+	"flag"
 	"fmt"
+	"log"
+	"os"
+	"os/exec"
+	"path/filepath"
+	"time"
 )
 
-func run_json(text string){
-	var m map[string]interface{}
-	text2, err := hex.DecodeString(text);
-	
-	if err != nil { 
-		panic(err)
+func LaunchCmd(cmd *exec.Cmd) error {
+	cmd.Stdout = os.Stdout
+	cmd.Stderr = os.Stderr
+	return cmd.Run()
+}
+
+func Launch(Path string, Args ...string) error {
+	log.Println(Path, Args)
+	cmd := exec.Command(Path, Args...)
+	return LaunchCmd(cmd)
+}
+
+func main() {
+	// update & launcher
+	exe, err := os.Executable()
+	if err != nil {
+		panic(err.Error())
 	}
-	
-	data := []byte(text2)
-	err = json.Unmarshal(data, &m); 
-	
-	if err != nil { 
-		panic(err)
+	log.Println(os.Args);
+
+	version := flag.String("version", "", "version")
+	chocolatey_source := flag.String("chocolatey_source", "", "install with chocolatey from source")
+	winget_install := flag.Bool("winget_install", false, "install with winget")
+	verbose := flag.Bool("verbose", false, "verbose mode")
+	name := flag.String("name", "nekobox", "software name")
+	// Parse the flags
+	flag.Parse()
+	// Get the positional arguments
+	args := flag.Args()
+	wd := args[1]
+	box := args[0]
+	exe = filepath.Base(os.Args[0])
+	log.Println("exe:", exe, "exe dir:", wd, "box: ", box)
+	time.Sleep(1 * time.Second)
+	// 1. update files
+	LaunchInstaller(box, wd, *version, *chocolatey_source, *winget_install, *verbose, *name)
+	// 2. start
+	os.Chdir(wd)
+	exec.Command("./nekobox.exe", args[2:]...).Start()
+}
+
+func LaunchInstaller(updatePackagePath string, installPath string, version string, chocolatey_source string, winget_install bool, verbose bool, name string) {
+	if winget_install {
+		Launch("winget", "install", "--version", version, updatePackagePath, "--override", "/S /WINGET=1 /UNPACK=1 /D="+filepath.Clean(installPath))
+	} else {
+		if chocolatey_source != "" {
+			run_chocolatey(version, chocolatey_source, name)
+		}
+		Launch(updatePackagePath, "/S", "/UNPACK=1", "/D="+filepath.Clean(installPath))
 	}
-	
-	version := m["version"].(string);
-	source := m["chocolatey_source"].(string);
-	
-	if (source != ""){
+}
+
+func run_chocolatey(version string, source string, name string) {
+	if source != "" {
 		command := exec.Command("powershell.exe", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", `
 $source="`+source+`"
 $version="`+version+`"
+$name="`+name+`"
 $IsAdmin = ([Security.Principal.WindowsPrincipal] `+"`"+`
 [Security.Principal.WindowsIdentity]::GetCurrent()
 ).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator) ;
     $psi = New-Object System.Diagnostics.ProcessStartInfo ;
     $psi.FileName = "choco" ;
-    $psi.Arguments = "install nekobox --version=`+"`"+`"$version`+"`"+`" --source=`+"`"+`"$source`+"`"+`" --skip-scripts" ;
+    $psi.Arguments = "install `+"`"+`"$name`+"`"+`" --version=`+"`"+`"$version`+"`"+`" --source=`+"`"+`"$source`+"`"+`" --skip-scripts" ;
 
 if (-not $IsAdmin) {
     Write-Host "Not elevated. Launching as Administrator..." ;
@@ -52,9 +91,7 @@ try {
 
 exit ;
 `)
-		fmt.Println("<<<<Run command>>>>")
-		fmt.Println(command)
-		fmt.Println("<<<>>>")
-		command.Run()
+		fmt.Println("<<<<Run Chocolatey Install>>>>")
+		LaunchCmd(command)
 	}
-}
\ No newline at end of file
+}
diff --git a/core/updater/updater.go b/core/updater/updater_linux.go
old mode 100755
new mode 100644
similarity index 87%
rename from core/updater/updater.go
rename to core/updater/updater_linux.go
index 46ea2c5d..047b672c
--- a/core/updater/updater.go
+++ b/core/updater/updater_linux.go
@@ -5,22 +5,19 @@ import (
 	"log"
 	"os"
 	"path/filepath"
-	"runtime"
 	"strings"
 
 	"github.com/codeclysm/extract/v4"
 )
 
-func Updater( updatePackagePath string, verbose bool) {
+func Updater(updatePackagePath string, verbose bool) {
 	pre_cleanup := func() {
-		if runtime.GOOS == "linux" {
-			os.RemoveAll("./usr")
-		}
+		os.RemoveAll("./usr")
 		os.RemoveAll("./nekobox_update")
 	}
 
 	// find update package
-	if ! Exist(updatePackagePath) {
+	if !Exist(updatePackagePath) {
 		log.Fatalln("no update")
 	}
 	log.Println("updating from", updatePackagePath)
@@ -55,12 +52,6 @@ func Updater( updatePackagePath string, verbose bool) {
 	}
 
 	// remove old file
-	removeAll("./*.dll")	
-	removeAll("./*.dmp")
-	removeAll("./*.js")
-	removeAll("./*.json")
-	removeAll("./*.txt")
-	os.RemoveAll("./nekobox_update/nekobox/public")
 
 	// update move
 	err = Mv("./nekobox_update/nekobox", "./")
@@ -110,6 +101,7 @@ func Mv(src, dst string) error {
 		if err != nil {
 			return err
 		}
+		os.RemoveAll(dst)
 		err = os.Rename(src, dst)
 		if err != nil {
 			return err
@@ -117,10 +109,11 @@ func Mv(src, dst string) error {
 	}
 	return nil
 }
-
+/*
 func removeAll(glob string) {
 	files, _ := filepath.Glob(glob)
 	for _, f := range files {
 		os.Remove(f)
 	}
 }
+*/
diff --git a/script/build_go.sh b/script/build_go.sh
index b799277c..e34c262c 100755
--- a/script/build_go.sh
+++ b/script/build_go.sh
@@ -26,7 +26,7 @@ if [ -z $DEST ]; then
 fi
 
 echo "DESTINATION IS $DEST FOR MACHINE $GOARCH with platform $GOOS"
-TAGS="with_clash_api,with_gvisor,with_quic,with_wireguard,with_utls,with_dhcp,with_tailscale"
+TAGS="with_clash_api,with_gvisor,with_quic,with_wireguard,with_utls,with_dhcp,with_tailscale,with_shadowtls"
 
 GOCMD="${GOCMD:-go}"
 
diff --git a/script/deploy_linux64.sh b/script/deploy_linux64.sh
index c9bced1f..bedf4fb3 100755
--- a/script/deploy_linux64.sh
+++ b/script/deploy_linux64.sh
@@ -26,11 +26,14 @@ cp $BUILD/nekobox $DEST
 #### copy nekobox.png ####
 cp ./res/nekobox.ico $DEST/nekobox.ico
 
+if [[ -d download-artifact ]]
+then
 (
 cd download-artifact
 cd *linux-$ARCH
 tar xvzf artifacts.tgz -C ../../
 ) ||:
+fi
 
 [[ -x linuxdeploy-$ARCH1.AppImage ]] || wget -c https://github.com/linuxdeploy/linuxdeploy/releases/download/1-alpha-20250213-2/linuxdeploy-$ARCH1.AppImage
 [[ -x linuxdeploy-plugin-qt-$ARCH1.AppImage ]] || wget -c https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/1-alpha-20250213-1/linuxdeploy-plugin-qt-$ARCH1.AppImage
@@ -66,28 +69,36 @@ patchelf --set-rpath '$ORIGIN/../../lib' ./usr/plugins/platformthemes/libqgtk3.s
 patchelf --set-rpath '$ORIGIN/../../lib' ./usr/plugins/platformthemes/libqxdgdesktopportal.so ||:
 
 # fix extra libs...
-mkdir ./usr/lib2
-ls ./usr/lib/
-cp ./usr/lib/libQt* ./usr/lib/libxcb-cursor* ./usr/lib/libxcb-util* ./usr/lib/libicuuc* ./usr/lib/libicui18n* ./usr/lib/libicudata* ./usr/lib2 ||:
-rm -r ./usr/lib ||:
-mv ./usr/lib2 ./usr/lib
+#mkdir ./usr/lib2
+#ls ./usr/lib/
+#cp ./usr/lib/libQt* ./usr/lib/libxcb-cursor* ./usr/lib/libxcb-util* ./usr/lib/libicuuc* ./usr/lib/libicui18n* ./usr/lib/libicudata* ./usr/lib2 ||:
+#rm -r ./usr/lib ||:
+#mv ./usr/lib2 ./usr/lib
 
 # fix lib rpath
 cp $CURDIR/*.js $DEST
 cp -RT $CURDIR/res/public $DEST/public
-echo "$INPUT_VERSION" > $DEST/version.txt
+echo "[General]" > $DEST/global.ini
+echo "software_name=NelBox" >> $DEST/global.ini
+echo "software_version=$INPUT_VERSION" >> $DEST/global.ini
 
 cd $DEST
 patchelf --set-rpath '$ORIGIN/usr/lib' ./nekobox
 
 shopt -s extglob
 
+rm -rfv nekobox_directory
+mkdir nekobox_directory
+mv !(nekobox_directory) nekobox_directory
+mv nekobox_directory nekobox
+tar -czvf $DEPLOYMENT/$version_standalone-linux-${ARCH}.tar.gz nekobox
+
 mkdir -p appimage/AppDir
 cd appimage
 
 
 chmod 755 *
-cp -Rfv ../!(updater|appimage|nekobox-${ARCH1}.AppImage) ./AppDir
+cp -Rfv ../nekobox/!(updater|appimage|nekobox-${ARCH1}.AppImage) ./AppDir
 (
 cd AppDir
 mv nekobox_core .nekobox_core_binary_file
@@ -141,7 +152,9 @@ Exec=nekobox
 Icon=Tun
 EOF
 rm -rfv *.old.* ||:
-$CURDIR/appimagetool-${ARCH1}.AppImage AppDir ../nekobox-${ARCH1}.AppImage --runtime-file $CURDIR/runtime-${ARCH1}
+$CURDIR/appimagetool-${ARCH1}.AppImage AppDir $DEPLOYMENT/$version_standalone-${ARCH1}-linux.AppImage --runtime-file $CURDIR/runtime-${ARCH1}
 
 cd ../
 rm -rfv appimage
+rm -rfv nekobox
+rmdir $DEST ||:
diff --git a/script/deploy_vendor.sh b/script/deploy_vendor.sh
index d461f204..b8a3b219 100755
--- a/script/deploy_vendor.sh
+++ b/script/deploy_vendor.sh
@@ -4,7 +4,12 @@ pushd "$SRC_ROOT"/core/server
 pushd gen
  ./update_libs.sh
 popd
+
+if [[ ! -f srslist.json ]]
+then
 curl -fLso "$SRC_ROOT/srslist.json" "https://github.com/qr243vbi/ruleset/raw/refs/heads/rule-set/srslist.json"
+fi
+
 go mod tidy
 go mod vendor
 go list -m -f '{{.Version}}' github.com/sagernet/sing-box > "$SRC_ROOT/SingBox.Version"
@@ -17,12 +22,15 @@ then
  git commit -am "initial commit"
 fi
 
-echo $INPUT_VERSION > version.txt
+echo "[General]" > global.ini
+echo "software_version=$INPUT_VERSION" >> global.ini
+echo "software_name=HelBox" >> global.ini
 
-git add -f srslist* version.txt core/server/gen/*.go core/server/gen/libcore_service-remote core/server/vendor SingBox.Version
+git add -f srslist* global.ini core/server/gen/*.go core/server/gen/libcore_service-remote core/server/vendor SingBox.Version
 
 git -c user.name="qr243vbi" -c user.email="my@email.org" commit -am "New Update"
 
+
 if [[ ! -e "$DEPLOYMENT" ]]
 then
  mkdir "$DEPLOYMENT"
diff --git a/script/deploy_windows.sh b/script/deploy_windows.sh
index 2fe5d705..d9e1a7c6 100755
--- a/script/deploy_windows.sh
+++ b/script/deploy_windows.sh
@@ -5,22 +5,27 @@ export CURDIR=$PWD
 source script/env_deploy.sh
 if [[ $1 == "new-x86_64" || -z $1 ]]; then
   ARCH="windows-amd64"
-  DEST=$DEPLOYMENT/windows64
+  DEST="$DEPLOYMENT/windows64"
+  INST="$DEPLOYMENT/nekobox_setup"
 else if [[ $1 == "new-arm64" || -z $1 ]]; then
   ARCH="windows-arm64"
-  DEST=$DEPLOYMENT/windows-arm64
+  DEST="$DEPLOYMENT/windows-arm64"
+  INST="$DEPLOYMENT/nekobox_setup_arm64"
 else if [[ $1 == 'i686' ]]; then
   ARCH="windowslegacy-386"
-  DEST=$DEPLOYMENT/windows32
+  DEST="$DEPLOYMENT/windows32"
+  INST="$DEPLOYMENT/nekobox_setup32"
 else if [[ $1 == 'x86_64' ]]; then
   ARCH="windowslegacy-amd64"
-  DEST=$DEPLOYMENT/windowslegacy64
+  DEST="$DEPLOYMENT/windowslegacy64"
+  INST="$DEPLOYMENT/nekobox_setup_legacy"
 else if [[ $1 == "arm64" ]]; then
   ARCH="windowslegacy-arm64"
-  DEST=$DEPLOYMENT/windowslegacy-arm64
+  DEST="$DEPLOYMENT/windowslegacy-arm64"
+  INST="$DEPLOYMENT/nekobox_setup_legacy_arm64"
 fi; fi; fi; fi; fi;
 
-rm -rf $DEST
+#rm -rf $DEST
 mkdir -p $DEST
 
 #### get the pdb ####
@@ -38,14 +43,19 @@ mv nekobox.pdb $DEST
 fi
 
 #### copy srslist ####
+if [[ ! -f srslist.json ]]
+then
+curl -fLso srslist.json "https://github.com/qr243vbi/ruleset/raw/refs/heads/rule-set/srslist.json"
+fi
 cp srslist.json $DEST/srslist.json
 
 #### copy exe ####
 cp $CURDIR/*.js $DEST
 cp $BUILD/nekobox.exe $DEST || cp $BUILD/Release/nekobox.exe $DEST
-echo 'DeleteToUseThisDirectoryForConfig' > $DEST/config
 cp -RT $CURDIR/res/public $DEST/public
-echo "$INPUT_VERSION" > $DEST/version.txt
+echo "[General]" > $DEST/global.ini
+echo "software_name=NelBox" >> $DEST/global.ini
+echo "software_version=$INPUT_VERSION" >> $DEST/global.ini
 
 if [[ "$COMPILER" != "MinGW" ]]
 then
@@ -56,43 +66,17 @@ rm -rf dxcompiler.dll dxil.dll ||:
 popd
 fi
 
-cd download-artifact
-ls
-cd *$ARCH
-tar xvzf artifacts.tgz -C ../../
-cd ../..
-
-
+if [[ -d download-artifact ]]
+then
+ cd download-artifact
+ cd *$ARCH
+ tar xvzf artifacts.tgz -C ../../
+ cd ../..
+fi
 
-#(
-#cd "$CURDIR"
-#cp '.\script\windows_installer.nsi' .
 
-#if [[ "$ARCH" == "windows-amd64" ]];
-#then
-#makensis.exe windows_installer.nsi
-#install -D nekobox_setup.exe deployment/nekobox_setup.exe
-#else
-#if [[ "$ARCH" == "windowslegacy-386" ]];
-#then
-#makensis "/DDIRECTORY=windows32"  windows_installer.nsi
-#install -D nekobox_setup.exe deployment/nekobox_setup32.exe
-#else
-#if [[ "$ARCH" == "windows-arm64" ]];
-#then
-#makensis "/DDIRECTORY=windows-arm64" windows_installer.nsi
-#install -D nekobox_setup.exe deployment/nekobox_setup_arm64.exe
-#else
-#if [[ "$ARCH" == "windowslegacy-amd64" ]]; then
-#makensis "/DDIRECTORY=windowslegacy64" windows_installer.nsi
-#install -D nekobox_setup.exe deployment/nekobox_setup_legacy.exe
-#else
-#if [[ "$ARCH" == "windowslegacy-arm64" ]]; then
-#makensis "/DDIRECTORY=windowslegacy-arm64" windows_installer.nsi
-#install -D nekobox_setup.exe deployment/nekobox_setup_legacy_arm64.exe
-#fi
-#fi
-#fi
-#fi
-#fi
-#)
+(
+cd "$CURDIR"
+pwd
+makensis.exe "-DSOFTWARE_VERSION=$INPUT_VERSION" "-DSOFTWARE_NAME=NekoBox" "-DDIRECTORY=$DEST" "-DOUTFILE=$INST" "-NOCD" 'script/windows_installer.nsi'
+)
diff --git a/script/generate_pkgbuild.sh b/script/generate_pkgbuild.sh
index ad334859..11f6c7cf 100755
--- a/script/generate_pkgbuild.sh
+++ b/script/generate_pkgbuild.sh
@@ -4,4 +4,5 @@ asset_res="$(echo "$text"  | jq '.assets[] | select(.browser_download_url | ends
 url_res="$(echo "$asset_res" | jq -r '.browser_download_url' | sed "s~$INPUT_VERSION~\${pkgver}~g")"
 sha_res="$(echo "$asset_res" | jq -r '.digest' | sed 's~sha256:~~g')"
 
-sed "s@pkgver=.*@pkgver=${INPUT_VERSION}@g; s@sha256sums=(.*@sha256sums=(\"$sha_res\")@g; s@source=(.*@source=(\"$url_res\")@g;" ./script/nekobox_aur/PKGBUILD > ./PKGBUILD
+wget https://codefloe.com/qr243vbi/nekobox/raw/branch/main/PKGBUILD
+sed -i "s@pkgver=.*@pkgver=${INPUT_VERSION}@g; s@sha256sums=(.*@sha256sums=(\"$sha_res\")@g; s@source=(.*@source=(\"$url_res\")@g;" ./PKGBUILD
diff --git a/script/nekobox_aur/PKGBUILD b/script/nekobox_aur/PKGBUILD
index 17a76ada..d4b76f38 100755
--- a/script/nekobox_aur/PKGBUILD
+++ b/script/nekobox_aur/PKGBUILD
@@ -64,9 +64,9 @@ package_nekobox() {
 
     cd "nekobox-unified-source-${pkgver}"
     install -Dm644 srslist.json -t "${pkgdir}/usr/lib/NekoBox"
+    install -Dm644 global.ini -t "${pkgdir}/usr/lib/NekoBox"
     cp *.js "${pkgdir}/usr/lib/NekoBox"
     cp -RfvT "res/public" "${pkgdir}/usr/lib/NekoBox/public"
-    echo "${pkgver}" > "${pkgdir}/usr/lib/NekoBox/version.txt"
     install -Dm644 res/public/icon.png "${pkgdir}/usr/share/pixmaps/nekobox.png"
 }
 
diff --git a/script/nekobox_template/nekobox.nuspec b/script/nekobox_template/nekobox.nuspec
index 6ba5fef7..986026f1 100755
--- a/script/nekobox_template/nekobox.nuspec
+++ b/script/nekobox_template/nekobox.nuspec
@@ -3,15 +3,15 @@
   <metadata>
     <id>nekobox</id>
     <version>5.1.18</version>
-    <title>nekobox (Install)</title>
+    <title>NekoBox (Install)</title>
     <authors>qr243vbi</authors>
 	<licenseUrl>https://www.gnu.org/licenses/gpl-3.0.txt</licenseUrl>
 	<iconUrl>https://raw.githubusercontent.com/qr243vbi/nekobox/refs/heads/main/res/public/Tun.png</iconUrl>
     <projectUrl>https://github.com/qr243vbi/nekobox</projectUrl>
     <projectSourceUrl>https://github.com/qr243vbi/nekobox</projectSourceUrl>
     <packageSourceUrl>https://github.com/qr243vbi/nekobox/tree/main/script/nekobox_template</packageSourceUrl>
-    <tags>nekobox proxy</tags>
-    <summary>Nekobox For PC</summary>
+    <tags>nekobox proxy rahubox</tags>
+    <summary>NekoBox For PC</summary>
 	<releaseNotes /> 
     <mailingListUrl>https://github.com/qr243vbi/nekobox/discussions</mailingListUrl>
     <docsUrl>https://github.com/qr243vbi/nekobox/blob/main/README.md</docsUrl>
diff --git a/script/nekobox_template/tools/LICENSE.txt b/script/nekobox_template/tools/LICENSE.txt
deleted file mode 100755
index c3a2e928..00000000
--- a/script/nekobox_template/tools/LICENSE.txt
+++ /dev/null
@@ -1,678 +0,0 @@
-From: https://www.gnu.org/licenses/gpl-3.0.txt
-
-LICENSE
-
-					GNU GENERAL PUBLIC LICENSE
-                      Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The GNU General Public License is a free, copyleft license for
-software and other kinds of works.
-
-  The licenses for most software and other practical works are designed
-to take away your freedom to share and change the works.  By contrast,
-the GNU General Public License is intended to guarantee your freedom to
-share and change all versions of a program--to make sure it remains free
-software for all its users.  We, the Free Software Foundation, use the
-GNU General Public License for most of our software; it applies also to
-any other work released this way by its authors.  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-them if you wish), that you receive source code or can get it if you
-want it, that you can change the software or use pieces of it in new
-free programs, and that you know you can do these things.
-
-  To protect your rights, we need to prevent others from denying you
-these rights or asking you to surrender the rights.  Therefore, you have
-certain responsibilities if you distribute copies of the software, or if
-you modify it: responsibilities to respect the freedom of others.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must pass on to the recipients the same
-freedoms that you received.  You must make sure that they, too, receive
-or can get the source code.  And you must show them these terms so they
-know their rights.
-
-  Developers that use the GNU GPL protect your rights with two steps:
-(1) assert copyright on the software, and (2) offer you this License
-giving you legal permission to copy, distribute and/or modify it.
-
-  For the developers' and authors' protection, the GPL clearly explains
-that there is no warranty for this free software.  For both users' and
-authors' sake, the GPL requires that modified versions be marked as
-changed, so that their problems will not be attributed erroneously to
-authors of previous versions.
-
-  Some devices are designed to deny users access to install or run
-modified versions of the software inside them, although the manufacturer
-can do so.  This is fundamentally incompatible with the aim of
-protecting users' freedom to change the software.  The systematic
-pattern of such abuse occurs in the area of products for individuals to
-use, which is precisely where it is most unacceptable.  Therefore, we
-have designed this version of the GPL to prohibit the practice for those
-products.  If such problems arise substantially in other domains, we
-stand ready to extend this provision to those domains in future versions
-of the GPL, as needed to protect the freedom of users.
-
-  Finally, every program is threatened constantly by software patents.
-States should not allow patents to restrict development and use of
-software on general-purpose computers, but in those that do, we wish to
-avoid the special danger that patents applied to a free program could
-make it effectively proprietary.  To prevent this, the GPL assures that
-patents cannot be used to render the program non-free.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                       TERMS AND CONDITIONS
-
-  0. Definitions.
-
-  "This License" refers to version 3 of the GNU General Public License.
-
-  "Copyright" also means copyright-like laws that apply to other kinds of
-works, such as semiconductor masks.
-
-  "The Program" refers to any copyrightable work licensed under this
-License.  Each licensee is addressed as "you".  "Licensees" and
-"recipients" may be individuals or organizations.
-
-  To "modify" a work means to copy from or adapt all or part of the work
-in a fashion requiring copyright permission, other than the making of an
-exact copy.  The resulting work is called a "modified version" of the
-earlier work or a work "based on" the earlier work.
-
-  A "covered work" means either the unmodified Program or a work based
-on the Program.
-
-  To "propagate" a work means to do anything with it that, without
-permission, would make you directly or secondarily liable for
-infringement under applicable copyright law, except executing it on a
-computer or modifying a private copy.  Propagation includes copying,
-distribution (with or without modification), making available to the
-public, and in some countries other activities as well.
-
-  To "convey" a work means any kind of propagation that enables other
-parties to make or receive copies.  Mere interaction with a user through
-a computer network, with no transfer of a copy, is not conveying.
-
-  An interactive user interface displays "Appropriate Legal Notices"
-to the extent that it includes a convenient and prominently visible
-feature that (1) displays an appropriate copyright notice, and (2)
-tells the user that there is no warranty for the work (except to the
-extent that warranties are provided), that licensees may convey the
-work under this License, and how to view a copy of this License.  If
-the interface presents a list of user commands or options, such as a
-menu, a prominent item in the list meets this criterion.
-
-  1. Source Code.
-
-  The "source code" for a work means the preferred form of the work
-for making modifications to it.  "Object code" means any non-source
-form of a work.
-
-  A "Standard Interface" means an interface that either is an official
-standard defined by a recognized standards body, or, in the case of
-interfaces specified for a particular programming language, one that
-is widely used among developers working in that language.
-
-  The "System Libraries" of an executable work include anything, other
-than the work as a whole, that (a) is included in the normal form of
-packaging a Major Component, but which is not part of that Major
-Component, and (b) serves only to enable use of the work with that
-Major Component, or to implement a Standard Interface for which an
-implementation is available to the public in source code form.  A
-"Major Component", in this context, means a major essential component
-(kernel, window system, and so on) of the specific operating system
-(if any) on which the executable work runs, or a compiler used to
-produce the work, or an object code interpreter used to run it.
-
-  The "Corresponding Source" for a work in object code form means all
-the source code needed to generate, install, and (for an executable
-work) run the object code and to modify the work, including scripts to
-control those activities.  However, it does not include the work's
-System Libraries, or general-purpose tools or generally available free
-programs which are used unmodified in performing those activities but
-which are not part of the work.  For example, Corresponding Source
-includes interface definition files associated with source files for
-the work, and the source code for shared libraries and dynamically
-linked subprograms that the work is specifically designed to require,
-such as by intimate data communication or control flow between those
-subprograms and other parts of the work.
-
-  The Corresponding Source need not include anything that users
-can regenerate automatically from other parts of the Corresponding
-Source.
-
-  The Corresponding Source for a work in source code form is that
-same work.
-
-  2. Basic Permissions.
-
-  All rights granted under this License are granted for the term of
-copyright on the Program, and are irrevocable provided the stated
-conditions are met.  This License explicitly affirms your unlimited
-permission to run the unmodified Program.  The output from running a
-covered work is covered by this License only if the output, given its
-content, constitutes a covered work.  This License acknowledges your
-rights of fair use or other equivalent, as provided by copyright law.
-
-  You may make, run and propagate covered works that you do not
-convey, without conditions so long as your license otherwise remains
-in force.  You may convey covered works to others for the sole purpose
-of having them make modifications exclusively for you, or provide you
-with facilities for running those works, provided that you comply with
-the terms of this License in conveying all material for which you do
-not control copyright.  Those thus making or running the covered works
-for you must do so exclusively on your behalf, under your direction
-and control, on terms that prohibit them from making any copies of
-your copyrighted material outside their relationship with you.
-
-  Conveying under any other circumstances is permitted solely under
-the conditions stated below.  Sublicensing is not allowed; section 10
-makes it unnecessary.
-
-  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
-
-  No covered work shall be deemed part of an effective technological
-measure under any applicable law fulfilling obligations under article
-11 of the WIPO copyright treaty adopted on 20 December 1996, or
-similar laws prohibiting or restricting circumvention of such
-measures.
-
-  When you convey a covered work, you waive any legal power to forbid
-circumvention of technological measures to the extent such circumvention
-is effected by exercising rights under this License with respect to
-the covered work, and you disclaim any intention to limit operation or
-modification of the work as a means of enforcing, against the work's
-users, your or third parties' legal rights to forbid circumvention of
-technological measures.
-
-  4. Conveying Verbatim Copies.
-
-  You may convey verbatim copies of the Program's source code as you
-receive it, in any medium, provided that you conspicuously and
-appropriately publish on each copy an appropriate copyright notice;
-keep intact all notices stating that this License and any
-non-permissive terms added in accord with section 7 apply to the code;
-keep intact all notices of the absence of any warranty; and give all
-recipients a copy of this License along with the Program.
-
-  You may charge any price or no price for each copy that you convey,
-and you may offer support or warranty protection for a fee.
-
-  5. Conveying Modified Source Versions.
-
-  You may convey a work based on the Program, or the modifications to
-produce it from the Program, in the form of source code under the
-terms of section 4, provided that you also meet all of these conditions:
-
-    a) The work must carry prominent notices stating that you modified
-    it, and giving a relevant date.
-
-    b) The work must carry prominent notices stating that it is
-    released under this License and any conditions added under section
-    7.  This requirement modifies the requirement in section 4 to
-    "keep intact all notices".
-
-    c) You must license the entire work, as a whole, under this
-    License to anyone who comes into possession of a copy.  This
-    License will therefore apply, along with any applicable section 7
-    additional terms, to the whole of the work, and all its parts,
-    regardless of how they are packaged.  This License gives no
-    permission to license the work in any other way, but it does not
-    invalidate such permission if you have separately received it.
-
-    d) If the work has interactive user interfaces, each must display
-    Appropriate Legal Notices; however, if the Program has interactive
-    interfaces that do not display Appropriate Legal Notices, your
-    work need not make them do so.
-
-  A compilation of a covered work with other separate and independent
-works, which are not by their nature extensions of the covered work,
-and which are not combined with it such as to form a larger program,
-in or on a volume of a storage or distribution medium, is called an
-"aggregate" if the compilation and its resulting copyright are not
-used to limit the access or legal rights of the compilation's users
-beyond what the individual works permit.  Inclusion of a covered work
-in an aggregate does not cause this License to apply to the other
-parts of the aggregate.
-
-  6. Conveying Non-Source Forms.
-
-  You may convey a covered work in object code form under the terms
-of sections 4 and 5, provided that you also convey the
-machine-readable Corresponding Source under the terms of this License,
-in one of these ways:
-
-    a) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by the
-    Corresponding Source fixed on a durable physical medium
-    customarily used for software interchange.
-
-    b) Convey the object code in, or embodied in, a physical product
-    (including a physical distribution medium), accompanied by a
-    written offer, valid for at least three years and valid for as
-    long as you offer spare parts or customer support for that product
-    model, to give anyone who possesses the object code either (1) a
-    copy of the Corresponding Source for all the software in the
-    product that is covered by this License, on a durable physical
-    medium customarily used for software interchange, for a price no
-    more than your reasonable cost of physically performing this
-    conveying of source, or (2) access to copy the
-    Corresponding Source from a network server at no charge.
-
-    c) Convey individual copies of the object code with a copy of the
-    written offer to provide the Corresponding Source.  This
-    alternative is allowed only occasionally and noncommercially, and
-    only if you received the object code with such an offer, in accord
-    with subsection 6b.
-
-    d) Convey the object code by offering access from a designated
-    place (gratis or for a charge), and offer equivalent access to the
-    Corresponding Source in the same way through the same place at no
-    further charge.  You need not require recipients to copy the
-    Corresponding Source along with the object code.  If the place to
-    copy the object code is a network server, the Corresponding Source
-    may be on a different server (operated by you or a third party)
-    that supports equivalent copying facilities, provided you maintain
-    clear directions next to the object code saying where to find the
-    Corresponding Source.  Regardless of what server hosts the
-    Corresponding Source, you remain obligated to ensure that it is
-    available for as long as needed to satisfy these requirements.
-
-    e) Convey the object code using peer-to-peer transmission, provided
-    you inform other peers where the object code and Corresponding
-    Source of the work are being offered to the general public at no
-    charge under subsection 6d.
-
-  A separable portion of the object code, whose source code is excluded
-from the Corresponding Source as a System Library, need not be
-included in conveying the object code work.
-
-  A "User Product" is either (1) a "consumer product", which means any
-tangible personal property which is normally used for personal, family,
-or household purposes, or (2) anything designed or sold for incorporation
-into a dwelling.  In determining whether a product is a consumer product,
-doubtful cases shall be resolved in favor of coverage.  For a particular
-product received by a particular user, "normally used" refers to a
-typical or common use of that class of product, regardless of the status
-of the particular user or of the way in which the particular user
-actually uses, or expects or is expected to use, the product.  A product
-is a consumer product regardless of whether the product has substantial
-commercial, industrial or non-consumer uses, unless such uses represent
-the only significant mode of use of the product.
-
-  "Installation Information" for a User Product means any methods,
-procedures, authorization keys, or other information required to install
-and execute modified versions of a covered work in that User Product from
-a modified version of its Corresponding Source.  The information must
-suffice to ensure that the continued functioning of the modified object
-code is in no case prevented or interfered with solely because
-modification has been made.
-
-  If you convey an object code work under this section in, or with, or
-specifically for use in, a User Product, and the conveying occurs as
-part of a transaction in which the right of possession and use of the
-User Product is transferred to the recipient in perpetuity or for a
-fixed term (regardless of how the transaction is characterized), the
-Corresponding Source conveyed under this section must be accompanied
-by the Installation Information.  But this requirement does not apply
-if neither you nor any third party retains the ability to install
-modified object code on the User Product (for example, the work has
-been installed in ROM).
-
-  The requirement to provide Installation Information does not include a
-requirement to continue to provide support service, warranty, or updates
-for a work that has been modified or installed by the recipient, or for
-the User Product in which it has been modified or installed.  Access to a
-network may be denied when the modification itself materially and
-adversely affects the operation of the network or violates the rules and
-protocols for communication across the network.
-
-  Corresponding Source conveyed, and Installation Information provided,
-in accord with this section must be in a format that is publicly
-documented (and with an implementation available to the public in
-source code form), and must require no special password or key for
-unpacking, reading or copying.
-
-  7. Additional Terms.
-
-  "Additional permissions" are terms that supplement the terms of this
-License by making exceptions from one or more of its conditions.
-Additional permissions that are applicable to the entire Program shall
-be treated as though they were included in this License, to the extent
-that they are valid under applicable law.  If additional permissions
-apply only to part of the Program, that part may be used separately
-under those permissions, but the entire Program remains governed by
-this License without regard to the additional permissions.
-
-  When you convey a copy of a covered work, you may at your option
-remove any additional permissions from that copy, or from any part of
-it.  (Additional permissions may be written to require their own
-removal in certain cases when you modify the work.)  You may place
-additional permissions on material, added by you to a covered work,
-for which you have or can give appropriate copyright permission.
-
-  Notwithstanding any other provision of this License, for material you
-add to a covered work, you may (if authorized by the copyright holders of
-that material) supplement the terms of this License with terms:
-
-    a) Disclaiming warranty or limiting liability differently from the
-    terms of sections 15 and 16 of this License; or
-
-    b) Requiring preservation of specified reasonable legal notices or
-    author attributions in that material or in the Appropriate Legal
-    Notices displayed by works containing it; or
-
-    c) Prohibiting misrepresentation of the origin of that material, or
-    requiring that modified versions of such material be marked in
-    reasonable ways as different from the original version; or
-
-    d) Limiting the use for publicity purposes of names of licensors or
-    authors of the material; or
-
-    e) Declining to grant rights under trademark law for use of some
-    trade names, trademarks, or service marks; or
-
-    f) Requiring indemnification of licensors and authors of that
-    material by anyone who conveys the material (or modified versions of
-    it) with contractual assumptions of liability to the recipient, for
-    any liability that these contractual assumptions directly impose on
-    those licensors and authors.
-
-  All other non-permissive additional terms are considered "further
-restrictions" within the meaning of section 10.  If the Program as you
-received it, or any part of it, contains a notice stating that it is
-governed by this License along with a term that is a further
-restriction, you may remove that term.  If a license document contains
-a further restriction but permits relicensing or conveying under this
-License, you may add to a covered work material governed by the terms
-of that license document, provided that the further restriction does
-not survive such relicensing or conveying.
-
-  If you add terms to a covered work in accord with this section, you
-must place, in the relevant source files, a statement of the
-additional terms that apply to those files, or a notice indicating
-where to find the applicable terms.
-
-  Additional terms, permissive or non-permissive, may be stated in the
-form of a separately written license, or stated as exceptions;
-the above requirements apply either way.
-
-  8. Termination.
-
-  You may not propagate or modify a covered work except as expressly
-provided under this License.  Any attempt otherwise to propagate or
-modify it is void, and will automatically terminate your rights under
-this License (including any patent licenses granted under the third
-paragraph of section 11).
-
-  However, if you cease all violation of this License, then your
-license from a particular copyright holder is reinstated (a)
-provisionally, unless and until the copyright holder explicitly and
-finally terminates your license, and (b) permanently, if the copyright
-holder fails to notify you of the violation by some reasonable means
-prior to 60 days after the cessation.
-
-  Moreover, your license from a particular copyright holder is
-reinstated permanently if the copyright holder notifies you of the
-violation by some reasonable means, this is the first time you have
-received notice of violation of this License (for any work) from that
-copyright holder, and you cure the violation prior to 30 days after
-your receipt of the notice.
-
-  Termination of your rights under this section does not terminate the
-licenses of parties who have received copies or rights from you under
-this License.  If your rights have been terminated and not permanently
-reinstated, you do not qualify to receive new licenses for the same
-material under section 10.
-
-  9. Acceptance Not Required for Having Copies.
-
-  You are not required to accept this License in order to receive or
-run a copy of the Program.  Ancillary propagation of a covered work
-occurring solely as a consequence of using peer-to-peer transmission
-to receive a copy likewise does not require acceptance.  However,
-nothing other than this License grants you permission to propagate or
-modify any covered work.  These actions infringe copyright if you do
-not accept this License.  Therefore, by modifying or propagating a
-covered work, you indicate your acceptance of this License to do so.
-
-  10. Automatic Licensing of Downstream Recipients.
-
-  Each time you convey a covered work, the recipient automatically
-receives a license from the original licensors, to run, modify and
-propagate that work, subject to this License.  You are not responsible
-for enforcing compliance by third parties with this License.
-
-  An "entity transaction" is a transaction transferring control of an
-organization, or substantially all assets of one, or subdividing an
-organization, or merging organizations.  If propagation of a covered
-work results from an entity transaction, each party to that
-transaction who receives a copy of the work also receives whatever
-licenses to the work the party's predecessor in interest had or could
-give under the previous paragraph, plus a right to possession of the
-Corresponding Source of the work from the predecessor in interest, if
-the predecessor has it or can get it with reasonable efforts.
-
-  You may not impose any further restrictions on the exercise of the
-rights granted or affirmed under this License.  For example, you may
-not impose a license fee, royalty, or other charge for exercise of
-rights granted under this License, and you may not initiate litigation
-(including a cross-claim or counterclaim in a lawsuit) alleging that
-any patent claim is infringed by making, using, selling, offering for
-sale, or importing the Program or any portion of it.
-
-  11. Patents.
-
-  A "contributor" is a copyright holder who authorizes use under this
-License of the Program or a work on which the Program is based.  The
-work thus licensed is called the contributor's "contributor version".
-
-  A contributor's "essential patent claims" are all patent claims
-owned or controlled by the contributor, whether already acquired or
-hereafter acquired, that would be infringed by some manner, permitted
-by this License, of making, using, or selling its contributor version,
-but do not include claims that would be infringed only as a
-consequence of further modification of the contributor version.  For
-purposes of this definition, "control" includes the right to grant
-patent sublicenses in a manner consistent with the requirements of
-this License.
-
-  Each contributor grants you a non-exclusive, worldwide, royalty-free
-patent license under the contributor's essential patent claims, to
-make, use, sell, offer for sale, import and otherwise run, modify and
-propagate the contents of its contributor version.
-
-  In the following three paragraphs, a "patent license" is any express
-agreement or commitment, however denominated, not to enforce a patent
-(such as an express permission to practice a patent or covenant not to
-sue for patent infringement).  To "grant" such a patent license to a
-party means to make such an agreement or commitment not to enforce a
-patent against the party.
-
-  If you convey a covered work, knowingly relying on a patent license,
-and the Corresponding Source of the work is not available for anyone
-to copy, free of charge and under the terms of this License, through a
-publicly available network server or other readily accessible means,
-then you must either (1) cause the Corresponding Source to be so
-available, or (2) arrange to deprive yourself of the benefit of the
-patent license for this particular work, or (3) arrange, in a manner
-consistent with the requirements of this License, to extend the patent
-license to downstream recipients.  "Knowingly relying" means you have
-actual knowledge that, but for the patent license, your conveying the
-covered work in a country, or your recipient's use of the covered work
-in a country, would infringe one or more identifiable patents in that
-country that you have reason to believe are valid.
-
-  If, pursuant to or in connection with a single transaction or
-arrangement, you convey, or propagate by procuring conveyance of, a
-covered work, and grant a patent license to some of the parties
-receiving the covered work authorizing them to use, propagate, modify
-or convey a specific copy of the covered work, then the patent license
-you grant is automatically extended to all recipients of the covered
-work and works based on it.
-
-  A patent license is "discriminatory" if it does not include within
-the scope of its coverage, prohibits the exercise of, or is
-conditioned on the non-exercise of one or more of the rights that are
-specifically granted under this License.  You may not convey a covered
-work if you are a party to an arrangement with a third party that is
-in the business of distributing software, under which you make payment
-to the third party based on the extent of your activity of conveying
-the work, and under which the third party grants, to any of the
-parties who would receive the covered work from you, a discriminatory
-patent license (a) in connection with copies of the covered work
-conveyed by you (or copies made from those copies), or (b) primarily
-for and in connection with specific products or compilations that
-contain the covered work, unless you entered into that arrangement,
-or that patent license was granted, prior to 28 March 2007.
-
-  Nothing in this License shall be construed as excluding or limiting
-any implied license or other defenses to infringement that may
-otherwise be available to you under applicable patent law.
-
-  12. No Surrender of Others' Freedom.
-
-  If conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot convey a
-covered work so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you may
-not convey it at all.  For example, if you agree to terms that obligate you
-to collect a royalty for further conveying from those to whom you convey
-the Program, the only way you could satisfy both those terms and this
-License would be to refrain entirely from conveying the Program.
-
-  13. Use with the GNU Affero General Public License.
-
-  Notwithstanding any other provision of this License, you have
-permission to link or combine any covered work with a work licensed
-under version 3 of the GNU Affero General Public License into a single
-combined work, and to convey the resulting work.  The terms of this
-License will continue to apply to the part which is the covered work,
-but the special requirements of the GNU Affero General Public License,
-section 13, concerning interaction through a network will apply to the
-combination as such.
-
-  14. Revised Versions of this License.
-
-  The Free Software Foundation may publish revised and/or new versions of
-the GNU General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-  Each version is given a distinguishing version number.  If the
-Program specifies that a certain numbered version of the GNU General
-Public License "or any later version" applies to it, you have the
-option of following the terms and conditions either of that numbered
-version or of any later version published by the Free Software
-Foundation.  If the Program does not specify a version number of the
-GNU General Public License, you may choose any version ever published
-by the Free Software Foundation.
-
-  If the Program specifies that a proxy can decide which future
-versions of the GNU General Public License can be used, that proxy's
-public statement of acceptance of a version permanently authorizes you
-to choose that version for the Program.
-
-  Later license versions may give you additional or different
-permissions.  However, no additional obligations are imposed on any
-author or copyright holder as a result of your choosing to follow a
-later version.
-
-  15. Disclaimer of Warranty.
-
-  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
-APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
-HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
-OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
-IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
-ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. Limitation of Liability.
-
-  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
-THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
-GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
-USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
-DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
-PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
-EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGES.
-
-  17. Interpretation of Sections 15 and 16.
-
-  If the disclaimer of warranty and limitation of liability provided
-above cannot be given local legal effect according to their terms,
-reviewing courts shall apply local law that most closely approximates
-an absolute waiver of all civil liability in connection with the
-Program, unless a warranty or assumption of liability accompanies a
-copy of the Program in return for a fee.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-state the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software: you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation, either version 3 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-Also add information on how to contact you by electronic and paper mail.
-
-  If the program does terminal interaction, make it output a short
-notice like this when it starts in an interactive mode:
-
-    <program>  Copyright (C) <year>  <name of author>
-    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, your program's commands
-might be different; for a GUI interface, you would use an "about box".
-
-  You should also get your employer (if you work as a programmer) or school,
-if any, to sign a "copyright disclaimer" for the program, if necessary.
-For more information on this, and how to apply and follow the GNU GPL, see
-<https://www.gnu.org/licenses/>.
-
-  The GNU General Public License does not permit incorporating your program
-into proprietary programs.  If your program is a subroutine library, you
-may consider it more useful to permit linking proprietary applications with
-the library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.  But first, please read
-<https://www.gnu.org/licenses/why-not-lgpl.html>.
\ No newline at end of file
diff --git a/script/nekobox_template/tools/chocolateyinstall.ps1 b/script/nekobox_template/tools/chocolateyinstall.ps1
index 049bf4f3..f3a8d196 100755
--- a/script/nekobox_template/tools/chocolateyinstall.ps1
+++ b/script/nekobox_template/tools/chocolateyinstall.ps1
@@ -1,25 +1,33 @@
 $ErrorActionPreference = 'Stop'
 $toolsDir   = "$(Split-Path -parent $MyInvocation.MyCommand.Definition)"
 
+$process = Get-Process "nekobox*" -ea 0
+
+if ($process) {
+  $processPath = $process | Where-Object { $_.Path } | Select-Object -First 1 -ExpandProperty Path
+  Write-Host "Found Running instance of NekoBox. Will stop during install..."
+#  $process | Stop-Process
+  $programRunning = $processPath
+}
+
 $packageArgs = @{
   packageName   = $env:ChocolateyPackageName
   unzipLocation = $toolsDir
   fileType      = 'exe'
-  url           = '@URL_x86@'
+#  url           = '@URL_x86@'
   url64bit      = '@URL_x64@'
   softwareName  = 'nekobox*'
-  checksum      = '@SHA_x86@'
-  checksumType  = 'sha256'
+#  checksum      = '@SHA_x86@'
+#  checksumType  = 'sha256'
   checksum64    = '@SHA_x64@'
   checksumType64= 'sha256'
-  silentArgs    = "/S"
+  silentArgs    = "/S /D=C:\tools\NekoBox"
   validExitCodes= @(0, 3010, 1641)
 }
 
 Install-ChocolateyPackage @packageArgs 
 
-
-$nekobox_path = Join-Path $env:ProgramFiles "nekobox"
+$nekobox_path = Get-AppInstallLocation $packageArgs.softwareName
 
 if (Test-Path "$nekobox_path" -PathType Container) {
     $global_ini_path = Join-Path $nekobox_path "global.ini"
@@ -30,3 +38,6 @@ chocolatey_package=true
 
 } 
 
+if ($programRunning -and (Test-Path $programRunning)) {
+  Write-Host "Please reopen NekoBox to continue using."
+}
diff --git a/script/trigger_winget_pkgs.sh b/script/trigger_winget_pkgs.sh
new file mode 100755
index 00000000..17eaafc4
--- /dev/null
+++ b/script/trigger_winget_pkgs.sh
@@ -0,0 +1,57 @@
+#!/bin/bash
+
+REPO_TO_FORK="microsoft/winget-pkgs"
+BASE_BRANCH="master"
+USERNAME="qr243vbi"
+PROGID="NekoBox"
+A='q'
+OLDVER='5.9.25'
+
+text="$(curl -s -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/qr243vbi/nekobox/releases/tags/$INPUT_VERSION)"
+asset_res="$(echo "$text"  | jq '.assets[] | select(.browser_download_url | endswith("-installer.exe"))')"
+
+
+PATTERN="s~/S /WINGET=1~/S /NOSCRIPT=1 /WINGET=1~g;s~$OLDVER~$INPUT_VERSION~g;s~2025-01-03~$(date +%Y-%m-%d)~g;$(echo $asset_res | jq -r '"\(.name)_\(.digest | ascii_upcase)"' | sed 's~.*arm64.*:\(.*\)~s@55DE53FA4B6CA5C3DC4DCB9A0EDE9AB933511C206E1289930DD35075E9C22147@\1@g;~g;s~.*windows64.*:\(.*\)~s@0AC94CBAA96CE3F101B9C8773E7227ABD053BE7DA18A84A3F3D6B6DBD7632CC5@\1@g;~g;' | sed ':a;N;$!ba;s/\n//g')"
+
+NEW_BRANCH_NAME="NekoBox-branch-$INPUT_VERSION-$(date +'%Y%m%d%H%M%S')"
+git clone --depth 10 "https://${USERNAME}:${GITHUB_TOKEN}@github.com/${USERNAME}/winget-pkgs" ||:
+
+cd "$(basename "$REPO_TO_FORK")" || { echo "Failed to change directory"; exit 1; }
+
+git config user.email "${EMAIL:-github-action@users.noreply.github.com}"
+git config user.name "${USERNAME}"
+
+git remote set-url origin "https://${USERNAME}:${GITHUB_TOKEN}@github.com/${USERNAME}/winget-pkgs"
+
+git fetch origin
+
+git checkout "$BASE_BRANCH"
+git reset --hard "origin/$BASE_BRANCH"
+git reset --hard HEAD^1
+git pull
+
+# Create and switch to the new branch
+git checkout -b "$NEW_BRANCH_NAME"
+
+abr(){
+  mkdir -p "$1" ||:
+  cd "$1"
+}
+
+abr manifests/${A}/${USERNAME}/${PROGID}/${INPUT_VERSION}
+cp ../${OLDVER}/* ./
+for i in *
+do
+ sed -i "$PATTERN" "$i"
+done
+
+echo "Successfully set up branch '$NEW_BRANCH_NAME' based on '$BASE_BRANCH'."
+
+git add --all
+git commit -am update 
+
+git push --set-upstream origin "$NEW_BRANCH_NAME"
+
+gh repo set-default "$REPO_TO_FORK"
+gh pr create --base "$BASE_BRANCH" --head "$USERNAME:$NEW_BRANCH_NAME" --title "New version: qr243vbi.NekoBox version ${INPUT_VERSION}" --body ""
+
diff --git a/script/windows_installer.nsi b/script/windows_installer.nsi
old mode 100755
new mode 100644
index 59b9818c..40252da8
--- a/script/windows_installer.nsi
+++ b/script/windows_installer.nsi
@@ -1,13 +1,32 @@
-Name "nekobox"
+!ifdef SOFTWARE_NAME
+    Name "${SOFTWARE_NAME}"
+!else
+	!define SOFTWARE_NAME nekobox
+    Name "nekobox"
+!endif
 
 !ifdef OUTFILE
     OutFile "${OUTFILE}.exe"
 !else
     OutFile "nekobox_setup.exe"
 !endif
-InstallDir $PROGRAMFILES\nekobox
-RequestExecutionLevel admin
+InstallDir $WINDIR\qr243vbi\non_exists_directory
+RequestExecutionLevel user
+
+!ifdef SOFTWARE_VERSION
+!else
+!define SOFTWARE_VERSION "1.0.0"
+!endif
 
+; Optional: version info for Windows file properties 
+VIProductVersion "${SOFTWARE_VERSION}.0" 
+VIAddVersionKey "ProductName" "${SOFTWARE_NAME}" 
+VIAddVersionKey "ProductVersion" "${SOFTWARE_VERSION}" 
+VIAddVersionKey "CompanyName" "qr243vbi" 
+VIAddVersionKey "FileDescription" "Installer for ${SOFTWARE_NAME}" 
+VIAddVersionKey "LegalCopyright" " 2026 qr243vbi"
+
+!include FileFunc.nsh
 !include MUI2.nsh
 !include LogicLib.nsh
 !include x64.nsh
@@ -16,7 +35,46 @@ RequestExecutionLevel admin
 ; --- Global Variables declared at the top level ---
 Var VCRedistNeeded
 Var VCRedistDownload
+Var VCRedistFile
 Var isInstalled
+Var isAdmin
+Var Winget
+Var UnpackOnly
+Var NoScript
+
+!ifndef PSEXEC_INCLUDED
+!define PSEXEC_INCLUDED
+ 
+!macro PowerShellExecMacro PSCommand
+  InitPluginsDir
+  ;Save command in a temp file
+  Push $R1
+  FileOpen $R1 $PLUGINSDIR\tempfile.ps1 w
+  FileWrite $R1 "${PSCommand}"
+  FileClose $R1
+  Pop $R1
+ 
+  !insertmacro PowerShellExecFileMacro "$PLUGINSDIR\tempfile.ps1"
+!macroend
+ 
+!macro PowerShellExecFileMacro PSFile
+  !define PSExecID ${__LINE__}
+  Push $R0
+ 
+  nsExec::ExecToLog 'powershell -NoLogo -InputFormat none -NoProfile -ExecutionPolicy Bypass -File "${PSFile}"  '
+  Pop $R0 ;return value is on stack
+  IntCmp $R0 0 finish_${PSExecID}
+  SetErrorLevel 2
+ 
+finish_${PSExecID}:
+  Pop $R0
+  !undef PSExecID
+!macroend
+ 
+!define PowerShellExec `!insertmacro PowerShellExecMacro`
+!define PowerShellExecFile `!insertmacro PowerShellExecFileMacro`
+ 
+!endif
 
 Function openLinkNewWindow
   ; (Function body remains the same, it works fine)
@@ -72,52 +130,79 @@ ${IfNot} ${IsNativeARM64}
   ${If} ${RunningX64}
     ;check H-KEY registry
     ReadRegDWORD $isInstalled HKLM "SOFTWARE\Wow6432Node\Microsoft\VisualStudio\14.0\VC\Runtimes\x64" "Installed"
-    StrCpy $VCRedistDownload "aka.ms"
+    StrCpy $VCRedistDownload "https://aka.ms/vc14/vc_redist.x64.exe"
+	StrCpy $VCRedistFile "vc14_redist.x64.exe"
   ${Else}
     ReadRegDWORD $isInstalled HKLM "SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\x86" "Installed"
-    StrCpy $VCRedistDownload "aka.ms"
+    StrCpy $VCRedistDownload "https://aka.ms/vc14/vc_redist.x86.exe"
+	StrCpy $VCRedistFile "vc14_redist.x86.exe"
   ${EndIf}
 ${Else}
     ReadRegDWORD $isInstalled HKLM "SOFTWARE\Microsoft\VisualStudio\14.0\VC\Runtimes\ARM64" "Installed"
-    StrCpy $VCRedistDownload "aka.ms"
+    StrCpy $VCRedistDownload "https://aka.ms/vc14/vc_redist.arm64.exe"
+	StrCpy $VCRedistFile "vc14_redist.arm64.exe"
 ${EndIf}
 
 
   ${If} $isInstalled != "1"
-    StrCpy $VCRedistNeeded "1" ; Mark that it was needed
     MessageBox MB_YESNO "NOTE: This application requires$\r$\n\
       'Microsoft Visual C++ Redistributable'$\r$\n\
       to function properly.$\r$\n$\r$\n\
       Download and install now?" /SD IDYES IDNO VSRedistInstalled
 
-    ${OpenURL} "$VCRedistDownload"
+   ; ${OpenURL} "$VCRedistDownload"
+    StrCpy $VCRedistNeeded "1" ; Mark that it was needed
   ${Else}
     StrCpy $VCRedistNeeded "0" ; Mark that it was not needed
   ${EndIf}
 
 
   VSRedistInstalled:
-  ;jumped from message box, nothing to do here
+!macroend
+
+
+!macro HasFlag FLAG OUTVAR
+    ${GetParameters} $R9
+    ${GetOptions} $R9 "${FLAG}" $R8
+    StrCpy ${OUTVAR} $R8
 !macroend
 
 
 Function .onInit
-    ${If} ${RunningX64}
-        StrCpy $INSTDIR "$PROGRAMFILES64\nekobox"
-    ${Else}
-        StrCpy $INSTDIR "$PROGRAMFILES\nekobox"
-    ${EndIf}
+    !insertmacro HasFlag "/WINGET=" $Winget
+	!insertmacro HasFlag "/UNPACK=" $UnpackOnly
+	!insertmacro HasFlag "/NOSCRIPT=" $NoScript
+	UserInfo::GetAccountType 
+	Pop $0 
+	${If} $0 != "Admin" 
+		StrCpy $isAdmin "0"
+	${Else}
+		StrCpy $isAdmin "1"
+	${EndIf}
+	${If} "$INSTDIR" != "$WINDIR\qr243vbi\non_exists_directory"
+		
+	${Else}
+		${If} "$isAdmin" == "1"
+			${If} ${RunningX64}
+				StrCpy $INSTDIR "$PROGRAMFILES64\nekobox"
+			${Else}
+				StrCpy $INSTDIR "$PROGRAMFILES\nekobox"
+			${EndIf}
+		${Else}
+			StrCpy $INSTDIR "$APPDATA\NekoBox"
+		${EndIf}
+	${EndIf}
 FunctionEnd
 
 !define MUI_ICON "res\nekobox.ico"
 !define MUI_ABORTWARNING
-!define MUI_WELCOMEPAGE_TITLE "Welcome to nekobox Installer"
-!define MUI_WELCOMEPAGE_TEXT "This wizard will guide you through the installation of nekobox."
+!define MUI_WELCOMEPAGE_TITLE "Welcome to ${SOFTWARE_NAME} Installer"
+!define MUI_WELCOMEPAGE_TEXT "This wizard will guide you through the installation of ${SOFTWARE_NAME}."
 
 ; --- Finish Page Settings ---
 !define MUI_FINISHPAGE_RUN "$INSTDIR\nekobox.exe"
-!define MUI_FINISHPAGE_RUN_TEXT "Launch nekobox"
-!define MUI_FINISHPAGE_RUN_NOTCHECKED
+!define MUI_FINISHPAGE_RUN_TEXT "Launch ${SOFTWARE_NAME}"
+;!define MUI_FINISHPAGE_RUN_NOTCHECKED
 
 !addplugindir .\script\
 
@@ -125,34 +210,124 @@ FunctionEnd
 !insertmacro MUI_PAGE_DIRECTORY
 !insertmacro MUI_PAGE_INSTFILES
 !insertmacro MUI_PAGE_FINISH
-
 !insertmacro MUI_LANGUAGE "English"
 
+!macro RegString NAME TARGET ICON 
+	${If} "$isAdmin" == "0" 
+		WriteRegStr HKCU ${NAME} ${TARGET} ${ICON}
+	${Else}
+		WriteRegStr HKLM ${NAME} ${TARGET} ${ICON}
+	${EndIf}
+!macroend
+
+!macro RegInteger NAME TARGET ICON 
+	${If} "$isAdmin" == "0" 
+		WriteRegDWORD HKCU ${NAME} ${TARGET} ${ICON}
+	${Else}
+		WriteRegDWORD HKLM ${NAME} ${TARGET} ${ICON}
+	${EndIf}
+!macroend
+
+!macro DropReg NAME 
+	${If} "$isAdmin" == "0" 
+		DeleteRegKey HKCU ${NAME}
+	${Else}
+		DeleteRegKey HKLM ${NAME}
+	${EndIf}
+!macroend
+
+
+Function WriteToFile
+Exch $0 ;file to write to
+Exch
+Exch $1 ;text to write
+ 
+  FileOpen $0 $0 a #open file
+  FileSeek $0 0 END #go to end
+  FileWrite $0 $1 #write to file
+  FileClose $0
+ 
+Pop $1
+Pop $0
+FunctionEnd
+ 
+!macro WriteToFile NewLine File String
+  !if `${NewLine}` == true
+  Push `${String}$\r$\n`
+  !else
+  Push `${String}`
+  !endif
+  Push `${File}`
+  Call WriteToFile
+!macroend
+!define WriteToFile `!insertmacro WriteToFile false`
+!define WriteLineToFile `!insertmacro WriteToFile true`
+
 Section "Install"
 
   SetOutPath "$INSTDIR"
   SetOverwrite on
 
   !insertmacro "checkVcRedist"
+  
+  ${If} "$NoScript" != "1"
+  ${PowerShellExec} "\
+    Write-Host $\"=> $INSTDIR$\" ;				\
+	if ($\"$VCRedistNeeded$\" -eq $\"1$\") {					\
+		$$url = $\"$VCRedistDownload$\" ;						\
+		$$download=$$env:USERPROFILE + $\"\Downloads$\"	;		\
+		$$path = $\"$$download\$VCRedistFile$\" ;				\
+		if (-not (Test-Path $$path)) {							\
+			Invoke-WebRequest -Uri $\"$$url$\" -OutFile $$path;	\
+		} ;														\
+		Start-Process $$path -Wait ;							\
+	}; 															\
+	$$procs = Get-CimInstance Win32_Process | Where-Object { 	\
+		$$_.ExecutablePath -like $\"$INSTDIR\*.exe$\" ;			\
+	}; 															\
+	foreach ($$proc in $$procs) { 								\
+		Write-Host $\"!! $$proc$\" ;							\
+		Stop-Process -Id $$proc.ProcessId -Force ; 				\
+	}; 															\
+	"
+  ${EndIf}
 
   !ifdef DIRECTORY
-    File /r  ".\deployment\${DIRECTORY}\*"
-    ;/x "updater.exe"
+    File /r  "${DIRECTORY}\*"
   !else
     File /r  ".\deployment\windows64\*"
   !endif
+  
+  ${If} "$Winget" == "1"
+    ${If} ${FileExists} "$INSTDIR\global.ini"
+    ${Else}
+        FileOpen $0 "$INSTDIR\global.ini" w
+        FileWrite $0 "[General]$\n"
+		FileClose $0
+    ${EndIf}
+    ${WriteLineToFile} "$INSTDIR\global.ini" "winget_package=true$\n"
+  ${EndIf}
 
-  CreateShortcut "$desktop\nekobox.lnk" "$INSTDIR\nekobox.exe" "" "$INSTDIR\nekobox.exe" 0
-  CreateShortcut "$SMPROGRAMS\nekobox.lnk" "$INSTDIR\nekobox.exe" "" "$INSTDIR\nekobox.exe" 0
-
-  WriteRegStr HKCU "Software\nekobox" "InstallPath" "$INSTDIR"
-
-  WriteRegStr HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "DisplayName" "nekobox"
-  WriteRegStr HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "UninstallString" "$INSTDIR\uninstall.exe"
-  WriteRegStr HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "InstallLocation" "$INSTDIR"
-  WriteRegDWORD HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "NoModify" 1
-  WriteRegDWORD HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "NoRepair" 1
-  WriteUninstaller "uninstall.exe"
+  ${If} "$UnpackOnly" != "1"
+    FileOpen $0 "$INSTDIR\config" w
+    FileWrite $0 "DeleteToUseThisDirectoryForConfig"
+	FileClose $0
+
+    CreateShortcut "$desktop\${SOFTWARE_NAME}.lnk" "$INSTDIR\nekobox.exe" "" "$INSTDIR\nekobox.exe" 0
+    CreateShortcut "$SMPROGRAMS\${SOFTWARE_NAME}.lnk" "$INSTDIR\nekobox.exe" "" "$INSTDIR\nekobox.exe" 0
+
+    !insertmacro RegString "Software\nekobox" "InstallPath" "$INSTDIR"
+    !insertmacro RegString "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "DisplayName" "${SOFTWARE_NAME}"
+	!insertmacro RegString "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "DisplayIcon" "$INSTDIR\nekobox.exe"
+    !insertmacro RegString "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "UninstallString" "$INSTDIR\uninstall.exe"
+    !insertmacro RegString "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "InstallLocation" "$INSTDIR"
+    !insertmacro RegString "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "Publisher" "qr243vbi"
+	${GetSize} "$INSTDIR" "/S=0K" $0 $1 $2
+    !insertmacro RegInteger "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "EstimatedSize" $0
+    !insertmacro RegInteger "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "NoModify" 1
+    !insertmacro RegInteger "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox" "NoRepair" 1
+    WriteUninstaller "uninstall.exe"
+  ${EndIf}
 SectionEnd
 
 Section "Uninstall"
@@ -165,5 +340,6 @@ Section "Uninstall"
 
   Delete "$INSTDIR\uninstall.exe"
 
-  DeleteRegKey HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox"
+  !insertmacro DropReg "Software\Microsoft\Windows\CurrentVersion\Uninstall\nekobox"
+  
 SectionEnd
diff --git a/src/api/RPC.cpp b/src/api/RPC.cpp
index 87f3b4c3..134abe15 100755
--- a/src/api/RPC.cpp
+++ b/src/api/RPC.cpp
@@ -318,4 +318,28 @@ try{
         }
     }
 
+    std::tuple<QString, std::shared_ptr<Configs::BuildConfigResult>> Client::StartEntity(bool *rpcOK,
+                            const std::shared_ptr<Configs::ProxyEntity> ent) {
+        std::shared_ptr<Configs::BuildConfigResult> result = Configs::BuildConfig(ent, false, false);
+
+        if (!result->error.isEmpty()) {
+            *rpcOK = false;
+            return std::make_tuple(result->error, result);
+        }
+
+        libcore::LoadConfigReq req;
+        req.core_config =
+        (QJsonObject2QString(result->coreConfig, true)).toStdString();
+        req.disable_stats = (Configs::dataStore->disable_traffic_stats);
+        if (ent->type == "extracore") {
+            req.need_extra_process = (true);
+            req.extra_process_path = (result->extraCoreData->path).toStdString();
+            req.extra_process_args = (result->extraCoreData->args).toStdString();
+            req.extra_process_conf = (result->extraCoreData->config).toStdString();
+            req.extra_process_conf_dir = (result->extraCoreData->configDir).toStdString();
+            req.extra_no_out = (result->extraCoreData->noLog);
+        }
+        return std::make_tuple(Start(rpcOK, req), result);
+    };
+
 } // namespace API
diff --git a/src/configs/ConfigBuilder.cpp b/src/configs/ConfigBuilder.cpp
index 8e59577c..ea5de9ee 100755
--- a/src/configs/ConfigBuilder.cpp
+++ b/src/configs/ConfigBuilder.cpp
@@ -2,11 +2,11 @@
 #include <winsock2.h>
 #include <windows.h>
 #endif
-#include "nekobox/configs/ConfigBuilder.hpp"
-#include "nekobox/dataStore/Database.hpp"
-#include "nekobox/configs/proxy/includes.h"
-#include "nekobox/configs/proxy/Preset.hpp"
-#include "nekobox/api/RPC.h"
+#include <nekobox/configs/ConfigBuilder.hpp>
+#include <nekobox/dataStore/Database.hpp>
+#include <nekobox/configs/proxy/includes.h>
+#include <nekobox/configs/proxy/Preset.hpp>
+#include <nekobox/api/RPC.h>
 
 #include <QApplication>
 #include <QFile>
@@ -1035,9 +1035,9 @@ namespace Configs {
         {
             if (dataStore->core_box_clash_api > 0){
                 clash_api = {
-                {"external_controller", dataStore->core_box_clash_listen_addr + ":" + QString::number(dataStore->core_box_clash_api)},
-                {"secret", dataStore->core_box_clash_api_secret},
-                {"external_ui", "dashboard"},
+                    {"external_controller", dataStore->core_box_clash_listen_addr + ":" + QString::number(dataStore->core_box_clash_api)},
+                    {"secret", dataStore->core_box_clash_api_secret},
+                    {"external_ui", "dashboard"},
                 };
             }
             if (dataStore->core_box_clash_api > 0 || dataStore->connection_statistics)
@@ -1048,24 +1048,12 @@ namespace Configs {
             auto cachePath = QStandardPaths::writableLocation(QStandardPaths::CacheLocation);
             QDir().mkpath(cachePath);//create parent dir tree
 
-            QString cache_database;
-            QString cacheFile;
-            if ((cache_database = Configs::dataStore->cache_database) == "" ){
-                label1:
-                cache_database = Configs::dataStore->cache_database = GetRandomString(16);
-                cacheFile = cachePath + "/nekobox_cache_" + cache_database;
-            } else {
-                cacheFile = cachePath + "/nekobox_cache_" + cache_database;
-                if (!QFile::exists(cacheFile)){
-                    goto label1;
-                }
-            }
 
             QJsonObject cache_file = {
                 {"enabled", true},
                 {"store_fakeip", true},
                 {"store_rdrc", true},
-                {"path", cacheFile + ".db"}
+                {"path", cachePath + "/nekobox_cache_" + GetRandomString(17) + ".db"}
             };
             experimentalObj["cache_file"] = cache_file;
         }
diff --git a/src/configs/proxy/Bean2CoreObj_box.cpp b/src/configs/proxy/Bean2CoreObj_box.cpp
index 9ff15182..62e02f9b 100755
--- a/src/configs/proxy/Bean2CoreObj_box.cpp
+++ b/src/configs/proxy/Bean2CoreObj_box.cpp
@@ -1,8 +1,78 @@
-#include "nekobox/dataStore/ProxyEntity.hpp"
-#include "nekobox/configs/proxy/includes.h"
+#include <nekobox/dataStore/ProxyEntity.hpp>
+#include <nekobox/configs/proxy/includes.h>
+
 #include <qjsonobject.h>
 
 namespace Configs {
+    static QJsonObject getXbadoptionRange(const QJsonValue & value);
+
+    static QJsonObject getXmux(const QJsonValue & value){
+        QJsonObject obj;
+        for (auto [k, value]: asKeyValueRange(value.toObject())){
+            QString key = k.toString().toLower().replace("_", "");
+            if (key == "maxconcurrency"){
+                obj["max_concurrency"] = getXbadoptionRange(value);
+            } else if (key == "maxconnections"){
+                obj["max_connections"] = getXbadoptionRange(value);
+            } else if (key == "cmaxreusetimes"){
+                obj["c_max_reuse_times"] = getXbadoptionRange(value);
+            } else if (key == "hmaxrequesttimes"){
+                obj["h_max_request_times"] = getXbadoptionRange(value);
+            } else if (key == "hmaxreusablesecs"){
+                obj["h_max_reusable_secs"] = getXbadoptionRange(value);
+            } else if (key == "hkeepaliveperiod"){
+                obj["h_keep_alive_period"] = value.toInteger();
+            }
+        }
+        return obj;
+    }
+
+    static QJsonObject getXbadoptionRange(const QJsonValue & value){
+        QJsonObject obj ;
+        if (value.isString()){
+            QString str = value.toString();
+            auto ptr = str.split("-");
+            obj.insert("from", ptr[0].toInt());
+            obj.insert("to", ptr[1].toInt());
+        } else if (value.isObject()){
+            auto objv = value.toObject();
+            obj.insert("from", objv.value("from").toInt());
+            obj.insert("to", objv.value("to").toInt());
+        } else {
+            obj.insert("from", value.toInt());
+            obj.insert("to", value.toInt());
+        }
+        return obj;
+    }
+
+    static void parseExtraXhttp(QJsonObject & transport, QString extra){
+        extra = extra.replace("+", "");
+        for (auto [k, value]: asKeyValueRange(QJsonDocument::fromJson(extra.toUtf8()).object())){
+            QString key = k.toString().toLower().replace("_", "");
+            if (key == "xpaddingbytes"){
+                transport["x_padding_bytes"] = getXbadoptionRange(value);
+            } else if (key == "nogrpcheader"){
+                transport["no_grpc_header"] = value.toBool();
+            } else if (key == "nosseheader"){
+                transport["no_sse_header"] = value.toBool();
+            } else if (key == "scmaxeachpostbytes"){
+                transport["sc_max_each_post_bytes"] = getXbadoptionRange(value);
+            } else if (key == "scminpostsintervalms"){
+                transport["sc_min_posts_interval_ms"] = getXbadoptionRange(value);
+            } else if (key == "scmaxbufferedposts"){
+                transport["sc_max_buffered_posts"] = value.toInteger();
+            } else if (key == "scstreamupserversecs"){
+                transport["sc_stream_up_server_secs"] = getXbadoptionRange(value);
+            } else if (key == "domainstrategy"){
+                transport["domain_strategy"] = value.toInt();
+            } else if (key == "headers"){
+                transport["headers"] = value.toObject();
+            } else if (key == "xmux"){
+                transport["xmux"] = getXmux(value);
+            }
+        }
+    }
+
     void V2rayStreamSettings::BuildStreamSettingsSingBox(QJsonObject *outbound) {
         // https://sing-box.sagernet.org/configuration/shared/v2ray-transport
 
@@ -54,6 +124,7 @@ namespace Configs {
                 if (!path.isEmpty()) transport["path"] = path;
                 if (!host.isEmpty()) transport["host"] = host;
                 transport["mode"] = xhttp_mode;
+                parseExtraXhttp(transport, xhttp_extra);
             }
             if (!network.trimmed().isEmpty()) outbound->insert("transport", transport);
         } else if (header_type == "http") {
@@ -445,4 +516,18 @@ namespace Configs {
         return result;
     }
 
+
+    CoreObjOutboundBuildResult TorBean::BuildCoreObjSingBox()
+    {
+        CoreObjOutboundBuildResult result;
+        QJsonObject outbound {
+            {"type", "tor"},
+            {"executable_path", this->executable_path},
+            {"extra_args", QListStr2QJsonArray(this->extra_args)},
+            {"data_directory", this->data_directory},
+            {"torrc", QJsonObject::fromVariantMap(this->torrc)}
+        };
+        result.outbound = outbound;
+        return result;
+    }
 } // namespace Configs
diff --git a/src/configs/proxy/Bean2Link.cpp b/src/configs/proxy/Bean2Link.cpp
index 9f4a30cc..4407e120 100755
--- a/src/configs/proxy/Bean2Link.cpp
+++ b/src/configs/proxy/Bean2Link.cpp
@@ -3,25 +3,16 @@
 #include "nekobox/configs/proxy/includes.h"
 
 #include <QUrlQuery>
+#include <QProcess>
 #include <qurlquery.h>
 
 namespace Configs {
 
-    static void add_query_nonempty(const char * name, QUrlQuery & query, QString & value){
-        if (!value.isEmpty()){
-            query.addQueryItem(name, value);
-        }
-    }
-
-    static void add_query_int(const char * name, QUrlQuery & query, int value){
-            query.addQueryItem(name, QString::number(value));
-    }
-
-    static void add_query_int_natural(const char * name, QUrlQuery & query, int value){
-        if (value > 0){
-            add_query_int(name, query, value);
-        }
-    }
+    inline void add_query_int_natural(const char * name, QUrlQuery & query, int value){ AddQueryNatural(query, name, value); };
+    inline void add_query_int(const char * name, QUrlQuery & query, int value){ AddQueryInt(query, name, value); };
+    inline void add_query_nonempty(const char * name, QUrlQuery & query, const QString &value){ AddQueryString(query, name, value); };
+    inline void add_query_args_nonempty(const char * name, QUrlQuery & query, const QStringList & value) { AddQueryStringList(query, name, value); };
+    inline void add_query_map_nonempty(const char * name, QUrlQuery & query, const QVariantMap & value) { AddQueryMap(query, name, value); };
 
     QString SocksHttpBean::ToShareLink() {
         QUrl url;
@@ -382,17 +373,17 @@ namespace Configs {
         url.setHost("tailscale");
         if (!name.isEmpty()) url.setFragment(name);
         QUrlQuery q;
-        q.addQueryItem("state_directory", QUrl::toPercentEncoding(state_directory));
-        q.addQueryItem("auth_key", QUrl::toPercentEncoding(auth_key));
-        q.addQueryItem("control_url", QUrl::toPercentEncoding(control_url));
-        q.addQueryItem("ephemeral", ephemeral ? "true" : "false");
-        q.addQueryItem("hostname", QUrl::toPercentEncoding(hostname));
-        q.addQueryItem("accept_routes", accept_routes ? "true" : "false");
-        q.addQueryItem("exit_node", exit_node);
-        q.addQueryItem("exit_node_allow_lan_access", exit_node_allow_lan_access ? "true" : "false");
-        q.addQueryItem("advertise_routes", QUrl::toPercentEncoding(advertise_routes.join(",")));
-        q.addQueryItem("advertise_exit_node", advertise_exit_node ? "true" : "false");
-        q.addQueryItem("global_dns", globalDNS ? "true" : "false");
+        add_query_nonempty("state_directory", q, QUrl::toPercentEncoding(state_directory));
+        add_query_nonempty("auth_key", q, QUrl::toPercentEncoding(auth_key));
+        add_query_nonempty("control_url", q, QUrl::toPercentEncoding(control_url));
+        add_query_nonempty("ephemeral", q, ephemeral ? "true" : "false");
+        add_query_nonempty("hostname", q, QUrl::toPercentEncoding(hostname));
+        add_query_nonempty("accept_routes", q, accept_routes ? "true" : "false");
+        add_query_nonempty("exit_node", q, exit_node);
+        add_query_nonempty("exit_node_allow_lan_access", q, exit_node_allow_lan_access ? "true" : "false");
+        add_query_nonempty("advertise_routes", q, QUrl::toPercentEncoding(advertise_routes.join(",")));
+        add_query_nonempty("advertise_exit_node", q, advertise_exit_node ? "true" : "false");
+        add_query_nonempty("global_dns", q, globalDNS ? "true" : "false");
         url.setQuery(q);
         return url.toString(QUrl::FullyEncoded);
     }
@@ -404,22 +395,22 @@ namespace Configs {
         url.setPort(serverPort);
         if (!name.isEmpty()) url.setFragment(name);
         QUrlQuery q;
-        q.addQueryItem("user", user);
-        q.addQueryItem("password", password);
-        q.addQueryItem("private_key", privateKey.toUtf8().toBase64(QByteArray::OmitTrailingEquals));
-        q.addQueryItem("private_key_path", privateKeyPath);
-        q.addQueryItem("private_key_passphrase", privateKeyPass);
+        add_query_nonempty("user", q, user);
+        add_query_nonempty("password", q, password);
+        add_query_nonempty("private_key", q, privateKey.toUtf8().toBase64(QByteArray::OmitTrailingEquals));
+        add_query_nonempty("private_key_path", q, privateKeyPath);
+        add_query_nonempty("private_key_passphrase", q, privateKeyPass);
         QStringList b64HostKeys = {};
         for (const auto& item: hostKey) {
             b64HostKeys << item.toUtf8().toBase64(QByteArray::OmitTrailingEquals);
         }
-        q.addQueryItem("host_key", b64HostKeys.join("-"));
+        add_query_nonempty("host_key", q, b64HostKeys.join("-"));
         QStringList b64HostKeyAlgs = {};
         for (const auto& item: hostKeyAlgs) {
             b64HostKeyAlgs << item.toUtf8().toBase64(QByteArray::OmitTrailingEquals);
         }
-        q.addQueryItem("host_key_algorithms", b64HostKeyAlgs.join("-"));
-        q.addQueryItem("client_version", clientVersion);
+        add_query_nonempty("host_key_algorithms", q, b64HostKeyAlgs.join("-"));
+        add_query_nonempty("client_version", q, clientVersion);
         url.setQuery(q);
         return url.toString(QUrl::FullyEncoded);
     }
@@ -429,6 +420,20 @@ namespace Configs {
         return "Unsupported for now";
     }
 
+    QString TorBean::ToShareLink(){
+        QUrl url;
+        url.setScheme("tor");
+        url.setHost("tor");
+        QUrlQuery q;
+        add_query_args_nonempty( "extra_args", q, extra_args);
+        add_query_nonempty("executable_path", q, executable_path);
+        add_query_nonempty("data_directory", q, data_directory);
+        add_query_map_nonempty("torrc", q, torrc);
+
+        url.setQuery(q);
+        return url.toString(QUrl::FullyEncoded);
+    }
+
     QString MieruBean::ToShareLink(){
         QUrl url;
         url.setScheme("mieru");
@@ -436,11 +441,11 @@ namespace Configs {
         url.setPort(serverPort);
         if (!name.isEmpty()) url.setFragment(name);
         QUrlQuery q;
-        q.addQueryItem("username", username);
-        q.addQueryItem("password", password);
-        q.addQueryItem("transport", "TCP");
-        q.addQueryItem("multiplexing", multiplexing);
-        q.addQueryItem("server_ports", serverPorts.join(","));
+        add_query_nonempty( "username", q, username);
+        add_query_nonempty( "password", q, password);
+        add_query_nonempty( "transport", q, "TCP");
+        add_query_nonempty( "multiplexing", q, multiplexing);
+        add_query_nonempty( "server_ports", q, serverPorts.join(","));
         url.setQuery(q);
 
         return url.toString(QUrl::FullyEncoded);
diff --git a/src/configs/proxy/Json2Bean.cpp b/src/configs/proxy/Json2Bean.cpp
index 4ec337d5..58c1246d 100755
--- a/src/configs/proxy/Json2Bean.cpp
+++ b/src/configs/proxy/Json2Bean.cpp
@@ -286,6 +286,15 @@ namespace Configs
         return false;
     }
 
+    bool TorBean::TryParseJson(const QJsonObject &obj){
+        name = obj["tag"].toString();
+        executable_path = obj["executable_path"].toString();
+        extra_args = QJsonArray2QListString(obj["extra_args"].toArray());
+        data_directory = obj["data_directory"].toString();
+        torrc = obj["torrc"].toObject().toVariantMap();
+        return true;
+    };
+
     bool MieruBean::TryParseJson(const QJsonObject& obj)
     {
         name = obj["tag"].toString();
diff --git a/src/configs/proxy/Link2Bean.cpp b/src/configs/proxy/Link2Bean.cpp
index 68692fc9..2ca03d9b 100755
--- a/src/configs/proxy/Link2Bean.cpp
+++ b/src/configs/proxy/Link2Bean.cpp
@@ -78,7 +78,7 @@ namespace Configs {
         if (serverPort == -1) serverPort = 443;
         this->idle_session_check_interval = GetQueryValue(query, "idle_session_check_interval", "30s");
         this->idle_session_timeout = GetQueryValue(query, "idle_session_timeout", "30s");
-        this->min_idle_session = GetQueryValue(query, "min_idle_session", "0").toInt();
+        this->min_idle_session = GetQueryIntValue(query, "min_idle_session", 0);
         // security
         parse_security(stream, query);
 
@@ -95,7 +95,7 @@ namespace Configs {
         serverPort = url.port();
         password = url.userName();
         if (serverPort == -1) serverPort = 443;
-        this->shadowtls_version = GetQueryValue(query, "version", "0").toInt();
+        this->shadowtls_version = GetQueryIntValue(query, "version", 0);
         // security
         parse_security(stream, query);
 
@@ -253,10 +253,13 @@ namespace Configs {
             auto net = objN["net"].toString();
             if (!net.isEmpty()) {
                 if (net == "h2") {
+					net_type_ret:
                     net = "http";
                 }
                 stream->network = net;
-            }
+            } else if (objN["type"].toString() == "http"){
+				goto net_type_ret;
+			}
             auto scy = objN["scy"].toString();
             if (!scy.isEmpty()) security = scy;
             // TLS (XTLS?)
@@ -360,8 +363,8 @@ namespace Configs {
             if (serverPort > 0) serverPort = url.port();
             obfsPassword = QUrl::fromPercentEncoding(query.queryItemValue("obfsParam").toUtf8());
             allowInsecure = QStringList{"1", "true"}.contains(query.queryItemValue("insecure"));
-            uploadMbps = query.queryItemValue("upmbps").toInt();
-            downloadMbps = query.queryItemValue("downmbps").toInt();
+            uploadMbps = GetQueryIntValue(query, "upmbps");
+            downloadMbps = GetQueryIntValue(query, "downmbps");
 
             auto protocolStr = (query.hasQueryItem("protocol") ? query.queryItemValue("protocol") : "udp").toLower();
             if (protocolStr == "faketcp") {
@@ -378,8 +381,8 @@ namespace Configs {
             alpn = query.queryItemValue("alpn");
             sni = FIRST_OR_SECOND(query.queryItemValue("peer"), query.queryItemValue("sni"));
 
-            connectionReceiveWindow = query.queryItemValue("recv_window").toInt();
-            streamReceiveWindow = query.queryItemValue("recv_window_conn").toInt();
+            connectionReceiveWindow = GetQueryIntValue(query, "recv_window");
+            streamReceiveWindow = GetQueryIntValue(query, "recv_window_conn");
 
             if (query.hasQueryItem("mport")) {
                 serverPorts = query.queryItemValue("mport").split(",");
@@ -453,21 +456,21 @@ namespace Configs {
         if (!rawLocalAddr.isEmpty()) {
             for (const auto &item: rawLocalAddr.split("-")) localAddress += item;
         }
-        persistentKeepalive = query.queryItemValue("persistent_keepalive").toInt();
-        MTU = query.queryItemValue("mtu").toInt();
+        persistentKeepalive = GetQueryIntValue(query, "persistent_keepalive");
+        MTU = GetQueryIntValue(query, "mtu");
         useSystemInterface = query.queryItemValue("use_system_interface") == "true";
-        workerCount = query.queryItemValue("workers").toInt();
+        workerCount = GetQueryIntValue(query, "workers");
 
         enable_amnezia = query.queryItemValue("enable_amnezia") == "true";
-        junk_packet_count = query.queryItemValue("junk_packet_count").toInt();
-        junk_packet_min_size = query.queryItemValue("junk_packet_min_size").toInt();
-        junk_packet_max_size = query.queryItemValue("junk_packet_max_size").toInt();
-        init_packet_junk_size = query.queryItemValue("init_packet_junk_size").toInt();
-        response_packet_junk_size = query.queryItemValue("response_packet_junk_size").toInt();
-        init_packet_magic_header = query.queryItemValue("init_packet_magic_header").toInt();
-        response_packet_magic_header = query.queryItemValue("response_packet_magic_header").toInt();
-        underload_packet_magic_header = query.queryItemValue("underload_packet_magic_header").toInt();
-        transport_packet_magic_header = query.queryItemValue("transport_packet_magic_header").toInt();
+        junk_packet_count = GetQueryIntValue(query, "junk_packet_count");
+        junk_packet_min_size = GetQueryIntValue(query, "junk_packet_min_size");
+        junk_packet_max_size = GetQueryIntValue(query, "junk_packet_max_size");
+        init_packet_junk_size = GetQueryIntValue(query, "init_packet_junk_size");
+        response_packet_junk_size = GetQueryIntValue(query, "response_packet_junk_size");
+        init_packet_magic_header = GetQueryIntValue(query, "init_packet_magic_header");
+        response_packet_magic_header = GetQueryIntValue(query, "response_packet_magic_header");
+        underload_packet_magic_header = GetQueryIntValue(query, "underload_packet_magic_header");
+        transport_packet_magic_header = GetQueryIntValue(query, "transport_packet_magic_header");
 
         return true;
     }
@@ -527,6 +530,18 @@ namespace Configs {
         return false;
     }
 
+    bool TorBean::TryParseLink(const QString &link){
+        auto url = QUrl(link);
+        if (!url.isValid()) return false;
+        auto q = GetQuery(url);
+
+        extra_args = GetQueryListValue(q, "extra_args");
+        executable_path = GetQueryValue(q, "executable_path");
+        data_directory = GetQueryValue(q, "data_directory");
+        torrc = GetQueryMapValue(q, "torrc");
+        return true;
+    };
+
     bool MieruBean::TryParseLink(const QString& link)
     {
         auto url = QUrl(link);
diff --git a/src/configs/sub/GroupUpdater.cpp b/src/configs/sub/GroupUpdater.cpp
index e5deb722..38315f6e 100755
--- a/src/configs/sub/GroupUpdater.cpp
+++ b/src/configs/sub/GroupUpdater.cpp
@@ -248,6 +248,14 @@ namespace Subscription {
             if (!ok) return;
         }
 
+        // tor
+        if (str.startsWith("tor://")) {
+            needFix = false;
+            ent = Configs::ProfileManager::NewProxyEntity("tor");
+            auto ok = ent->TorBean()->TryParseLink(str);
+            if (!ok) return;
+        }
+
         if (ent == nullptr) return;
 
         // Fix
@@ -402,6 +410,13 @@ namespace Subscription {
                 if (!ok) continue;
             }
 
+            // Tor
+            if (out["type"] == "tor") {
+                ent = Configs::ProfileManager::NewProxyEntity("tor");
+                auto ok = ent->TorBean()->TryParseJson(out);
+                if (!ok) continue;
+            }
+
             if (ent == nullptr) continue;
 
             updated_order += ent;
@@ -827,13 +842,13 @@ namespace Subscription {
                 updated_order += ent;
             }
         } catch (const fkyaml::exception &ex) {
-            runOnUiThread([=,this] {
-                MessageBoxWarning("YAML Exception", ex.what());
-            });
+   //         runOnUiThread([=,this] {
+                qDebug() << ("YAML Exception") <<  ex.what();
+     //       });
         }
     }
 
-    //  thread 
+    //
     void GroupUpdater::AsyncUpdate(const QString &str, int _sub_gid, const std::function<void()> &finish) {
         auto content = str.trimmed();
         bool asURL = false;
@@ -871,19 +886,19 @@ namespace Subscription {
     }
 
     void GroupUpdater::Update(const QString &_str, int _sub_gid, bool _not_sub_as_url) {
-        //  rawUpdater
+        //
         Configs::dataStore->imported_count = 0;
         auto rawUpdater = std::make_unique<RawUpdater>();
         rawUpdater->gid_add_to = _sub_gid;
 
-        // 
+        //
         QString sub_user_info;
-        bool asURL = _sub_gid >= 0 || _not_sub_as_url; //  _str  url 
+        bool asURL = _sub_gid >= 0 || _not_sub_as_url;
         auto content = _str.trimmed();
         auto group = Configs::profileManager->GetGroup(_sub_gid);
         if (group != nullptr && group->archive) return;
 
-        // 
+        //
         if (asURL) {
             auto groupName = group == nullptr ? content : group->name;
             MW_show_log(">>>>>>>> " + QObject::tr("Requesting subscription: %1").arg(groupName));
@@ -900,13 +915,13 @@ namespace Subscription {
             MW_show_log("<<<<<<<< " + QObject::tr("Subscription request fininshed: %1").arg(groupName));
         }
 
-        QList<std::shared_ptr<Configs::ProxyEntity>> in;          // 
-        QList<std::shared_ptr<Configs::ProxyEntity>> out_all;     //  + 
-        QList<std::shared_ptr<Configs::ProxyEntity>> out;         // 
-        QList<std::shared_ptr<Configs::ProxyEntity>> only_in;     // 
-        QList<std::shared_ptr<Configs::ProxyEntity>> only_out;    // 
-        QList<std::shared_ptr<Configs::ProxyEntity>> update_del;  // 
-        QList<std::shared_ptr<Configs::ProxyEntity>> update_keep; // 
+        QList<std::shared_ptr<Configs::ProxyEntity>> in;          //
+        QList<std::shared_ptr<Configs::ProxyEntity>> out_all;     //
+        QList<std::shared_ptr<Configs::ProxyEntity>> out;         //
+        QList<std::shared_ptr<Configs::ProxyEntity>> only_in;     //
+        QList<std::shared_ptr<Configs::ProxyEntity>> only_out;    //
+        QList<std::shared_ptr<Configs::ProxyEntity>> update_del;  //
+        QList<std::shared_ptr<Configs::ProxyEntity>> update_keep; //
 
         if (group != nullptr) {
             in = group->GetProfileEnts();
diff --git a/src/dataStore/Configs.cpp b/src/dataStore/Configs.cpp
index b1717046..75f4af0e 100755
--- a/src/dataStore/Configs.cpp
+++ b/src/dataStore/Configs.cpp
@@ -21,7 +21,7 @@
 #include <memory>
 #include <utility>
 #include <nekobox/api/RPC.h>
-
+#include <QVariantMap>
 #include <nekobox/js/version.h>
 #include <QCryptographicHash>
 
@@ -109,6 +109,11 @@ namespace Configs_ConfigItem {
                         }
                     } 
                     break;
+                case itemType::type_stringMap:
+                    {
+                        object.insert(name, QJsonObject::fromVariantMap( *(QVariantMap *) ptr ));
+                    }
+                    break;
                 case itemType::type_jsonStoreList:
                     QJsonArray jsonArray;
                     auto arr = *(QList<JsonStore*> *) ptr;
@@ -145,7 +150,7 @@ namespace Configs_ConfigItem {
             auto item = _map.value(key).get();
 
             if (item == nullptr)
-                continue; // 
+                continue;
 
             auto ptr = (void*)(((size_t)(void*)this) + item->ptr);
             switch (item->type) {
@@ -197,6 +202,13 @@ namespace Configs_ConfigItem {
                         store->FromJson(value.toObject());
                     }
                     break;
+                case itemType::type_stringMap:
+                    if (value.type() != QJsonValue::Object){
+                        continue;
+                    }
+                    {
+                        *(QVariantMap*) ptr = value.toObject().toVariantMap();
+                    }
                 case itemType::type_jsonStoreList:
                     break;
             }
@@ -224,6 +236,15 @@ namespace Configs_ConfigItem {
             case itemType::type_integer64:
                 *(long long *) ptr = *(long long *) p;
                 break;
+            case itemType::type_integerList:
+                *(QList<int> *) ptr = *(QList<int> *) p;
+                break;
+            case itemType::type_stringList:
+                *(QList<QString> *) ptr = *(QList<QString> *) p;
+                break;
+            case itemType::type_stringMap:
+                *(QVariantMap *) ptr = *(QVariantMap *) p;
+                break;
             // others...
             default:
                 break;
@@ -272,7 +293,7 @@ namespace Configs_ConfigItem {
         bool ok = file.open(QIODevice::ReadOnly);
         if (!ok) {
             if (load_control_must){
-                MessageBoxWarning("error", "can not open config " + fn + "\n" + file.errorString());
+                qDebug() << ("can not open config " + fn + "\n" + file.errorString());
             }
         } else {
             last_save_content = file.readAll();
@@ -373,7 +394,7 @@ namespace Configs {
         ADD_MAP("speedtest_timeout_ms", speed_test_timeout_ms, integer);
         ADD_MAP("urltest_timeout_ms", url_test_timeout_ms, integer);
         ADD_MAP("show_system_dns", show_system_dns, boolean);
-        ADD_MAP("cache_database_name", cache_database, string);
+   //     ADD_MAP("cache_database_name", cache_database, string);
 
         ADD_MAP("auto_test_enable", auto_test_enable, boolean);
         ADD_MAP("auto_test_interval_seconds", auto_test_interval_seconds, integer);
diff --git a/src/dataStore/Database.cpp b/src/dataStore/Database.cpp
index 33ea68d0..eb00aeb8 100755
--- a/src/dataStore/Database.cpp
+++ b/src/dataStore/Database.cpp
@@ -12,6 +12,8 @@
 namespace Configs {
 
     ProfileManager *profileManager = new ProfileManager();
+    
+    QMap<QString, QString> profileDisplayNames;
 
     ProfileManager::ProfileManager() : JsonStore("groups/pm.json") {
     }
@@ -167,10 +169,22 @@ namespace Configs {
         return routingChain;
     }
 
-    //   fn  id
 
-    std::shared_ptr<ProxyEntity> ProfileManager::NewProxyEntity(const QString &type) {
-        Configs::AbstractBean *bean;
+    QString ProfileManager::GetDisplayType(const QString & type){
+        QString ret = profileDisplayNames.value(type, "");
+        if (ret == ""){
+            auto proxy = NewProxyEntity(type, true);
+            if (proxy != nullptr){
+                ret = proxy->bean->DisplayType();
+                proxy.reset();
+                profileDisplayNames[type] = ret;
+            }
+        }
+        return ret;
+    }
+
+    std::shared_ptr<ProxyEntity> ProfileManager::NewProxyEntity(const QString &type, bool nullok) {
+        Configs::AbstractBean *bean = nullptr;
 
         if (type == "socks") {
             bean = new Configs::SocksHttpBean(Configs::SocksHttpBean::type_Socks5);
@@ -208,14 +222,23 @@ namespace Configs {
             bean = new Configs::CustomBean();
         } else if (type == "extracore") {
             bean = new Configs::ExtraCoreBean();
+        } else if (type == "tor"){
+            bean = new Configs::TorBean();
         } else {
-            bean = new Configs::AbstractBean(-114514);
+            if (!nullok){
+                bean = new Configs::AbstractBean(-114514);
+            } else {
+                return nullptr;
+            }
         }
-
         auto ent = std::make_shared<ProxyEntity>(bean, type);
         return ent;
     }
 
+    std::shared_ptr<ProxyEntity> ProfileManager::NewProxyEntity(const QString &type) {
+        return NewProxyEntity(type, false);
+    } 
+
     std::shared_ptr<Group> ProfileManager::NewGroup() {
         auto ent = std::make_shared<Group>();
         return ent;
diff --git a/src/dataStore/Group.cpp b/src/dataStore/Group.cpp
index 04e5deb0..8f6e72e3 100755
--- a/src/dataStore/Group.cpp
+++ b/src/dataStore/Group.cpp
@@ -1,9 +1,8 @@
 #include <nekobox/dataStore/Group.hpp>
 #include <QFile>
-#include "nekobox/ui/profile/dialog_edit_profile.h"
 #include "nekobox/dataStore/Utils.hpp"
 #include "nekobox/configs/proxy/AbstractBean.hpp"
-
+#include "nekobox/dataStore/Database.hpp"
 
 namespace Configs
 {
diff --git a/src/dataStore/ProxyEntity.cpp b/src/dataStore/ProxyEntity.cpp
index 071ff1d3..b0d4a950 100755
--- a/src/dataStore/ProxyEntity.cpp
+++ b/src/dataStore/ProxyEntity.cpp
@@ -1,6 +1,7 @@
 #include <nekobox/dataStore/ProxyEntity.hpp>
 #include <nekobox/configs/proxy/AbstractBean.hpp>
 #include <qnamespace.h>
+#include <QCoreApplication>
 
 namespace Configs
 {
@@ -59,43 +60,4 @@ namespace Configs
         return result;
     }
 
-    std::list<ColorRule> latencyColorList = {  
-        {1, 5, 0, 0, false, Qt::darkGreen},
-        {6, 5, 0, 0, false, QColor(128, 0, 128)},
-        {0,0,0,0, false, QColor(255, 165, 0)},
-        {0, 0, 0, 0, true, Qt::red}  
-    };
-
-    QColor ProxyEntity::DisplayLatencyColor() const {
-        if (latencyInt < 0){
-            for (auto & color: latencyColorList){
-                if (color.unavailable){
-                    return color.color;
-                }
-            }
-        } else {
-            for (auto & color: latencyColorList){
-                if (!color.unavailable){
-                    if (color.orderRange > 0){
-                        if (latencyOrder < (int)color.orderMin){
-                            continue;
-                        }
-                        if (latencyOrder > (int)(color.orderMin + color.orderRange)){
-                            continue;
-                        }
-                    }
-                    if (color.latencyRange > 0){
-                        if (latencyInt < (int)color.latencyMin){
-                            continue;
-                        }
-                        if (latencyInt > (int)(color.latencyMin + color.latencyRange)){
-                            continue;
-                        }
-                    }
-                    return color.color;
-                }
-            }
-        }
-        return Qt::black;
-    }
 }
diff --git a/src/dataStore/Utils.cpp b/src/dataStore/Utils.cpp
index 3e5c5857..2a1b13d3 100755
--- a/src/dataStore/Utils.cpp
+++ b/src/dataStore/Utils.cpp
@@ -17,11 +17,30 @@
 #include <QJsonDocument>
 #include <QRegularExpression>
 #include <QDateTime>
+#include <QTimer>
+#include <functional>
 #include <QLocale>
 
-#ifdef Q_OS_WIN
-#include "nekobox/sys/windows/guihelper.h"
-#endif
+
+void runOnNewThread(const std::function<void()> &callback) {
+    createQThread(callback)->start();
+}
+
+void runOnThread(const std::function<void()> &callback, QObject *parent) {
+    auto *timer = new QTimer();
+    auto thread = dynamic_cast<QThread *>(parent);
+    if (thread == nullptr) {
+        timer->moveToThread(parent->thread());
+    } else {
+        timer->moveToThread(thread);
+    }
+    timer->setSingleShot(true);
+    QObject::connect(timer, &QTimer::timeout, [=]() {
+        callback();
+        timer->deleteLater();
+    });
+    QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection, Q_ARG(int, 0));
+}
 
 QStringList SplitLines(const QString &_string) {
     return _string.split(QRegularExpression("[\r\n]"), Qt::SplitBehaviorFlags::SkipEmptyParts);
@@ -260,84 +279,125 @@ QString DisplayTime(long long time, int formatType) {
     return QLocale().toString(t, QLocale::FormatType(formatType));
 }
 
-QWidget *GetMessageBoxParent() {
-    auto activeWindow = QApplication::activeWindow();
-    if (activeWindow == nullptr && mainwindow != nullptr) {
-        if (mainwindow->isVisible()) return mainwindow;
-        return nullptr;
+
+const char * getSoftwareVersion(){
+    static const char * VERSION_STATIC = nullptr;
+    if (VERSION_STATIC == nullptr){
+        VERSION_STATIC = 	
+#ifdef _MSC_VER
+	_strdup
+#else
+	strdup
+#endif
+		(software_version.toUtf8().constData());
+    }
+    return VERSION_STATIC;
+}
+
+int GetQueryIntValue(const QUrlQuery &q, const QString &key, int def){
+    QString str = GetQueryValue(q, key);
+    if (!str.isEmpty()){
+        return str.toInt();
+    } else {
+        return def;
     }
-    return activeWindow;
+};
+
+QString SubStrBefore(QString str, const QString &sub) {
+    if (!str.contains(sub)) return str;
+    return str.left(str.indexOf(sub));
 }
 
-int MessageBoxWarning(const QString &title, const QString &text) {
-    return QMessageBox::warning(GetMessageBoxParent(), title, text);
+QString SubStrAfter(QString str, const QString &sub) {
+    if (!str.contains(sub)) return str;
+    return str.right(str.length() - str.indexOf(sub) - sub.length());
 }
 
-int MessageBoxInfo(const QString &title, const QString &text) {
-    return QMessageBox::information(GetMessageBoxParent(), title, text);
+
+// [2001:4860:4860::8888] -> 2001:4860:4860::8888
+QString UnwrapIPV6Host(QString &str) {
+    return str.replace("[", "").replace("]", "");
 }
 
-void ActivateWindow(QWidget *w) {
-    ToggleWindow(w);
+// [2001:4860:4860::8888] or 2001:4860:4860::8888 -> [2001:4860:4860::8888]
+QString WrapIPV6Host(QString &str) {
+    if (!IsIpAddressV6(str)) return str;
+    return "[" + UnwrapIPV6Host(str) + "]";
 }
 
-void ToggleWindow(QWidget *w) {
-    if (w->isVisible() && !(w->windowState() & Qt::WindowMinimized)) {
-        // Window is visible  minimize / hide
-        w->hide();
-    } else {
-        // Window is hidden or minimized  show
-        w->setWindowState(w->windowState() & ~Qt::WindowMinimized);
-        w->setVisible(true);
-#ifdef Q_OS_WIN
-        Windows_QWidget_SetForegroundWindow(w);
-#endif
-        w->raise();
-        w->activateWindow();
+QString DisplayAddress(QString serverAddress, int serverPort) {
+    if (serverAddress.isEmpty() && serverPort == 0) return {};
+    return WrapIPV6Host(serverAddress) + ":" + QString::number(serverPort);
+}
+
+QString DisplayDest(const QString& dest, QString domain)
+{
+    if (domain.isEmpty() || dest.split(":").first() == domain) return dest;
+    return dest + " (" + domain + ")";
+}
+
+bool InRange(unsigned x, unsigned low, unsigned high) {
+    return (low <= x && x <= high);
+}
+
+bool IsValidPort(int port) {
+    return InRange(port, 1, 65535);
+}
+
+void AddQueryString( QUrlQuery & query, const QString& name, const QString & value){
+    if (!value.isEmpty()){
+        query.addQueryItem(name, value);
     }
 }
 
-void runOnUiThread(const std::function<void()> &callback) {
-    // any thread
-    auto *timer = new QTimer();
-    auto thread = mainwindow->thread();
-    timer->moveToThread(thread);
-    timer->setSingleShot(true);
-    QObject::connect(timer, &QTimer::timeout, [=]() {
-        // main thread
-        callback();
-        timer->deleteLater();
-    });
-    QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection, Q_ARG(int, 0));
+void AddQueryStringList( QUrlQuery & query, const QString& name, const QStringList & value){
+    if (!value.isEmpty()){
+        AddQueryString(query, name,
+            QString::fromUtf8(QJsonDocument(QListStr2QJsonArray(value)).toJson())
+        );
+    }
 }
 
-void runOnNewThread(const std::function<void()> &callback) {
-    createQThread(callback)->start();
+void AddQueryMap( QUrlQuery & query, const QString& name, const QVariantMap & value){
+    if (!value.isEmpty()){
+        AddQueryString(query, name,
+            QString::fromUtf8(QJsonDocument(QJsonObject::fromVariantMap(value)).toJson())
+        );
+    }
 }
 
-void runOnThread(const std::function<void()> &callback, QObject *parent) {
-    auto *timer = new QTimer();
-    auto thread = dynamic_cast<QThread *>(parent);
-    if (thread == nullptr) {
-        timer->moveToThread(parent->thread());
-    } else {
-        timer->moveToThread(thread);
+void AddQueryInt( QUrlQuery & query, const QString& name, int value){
+    query.addQueryItem(name, QString::number(value));
+}
+
+
+void AddQueryNatural( QUrlQuery & query, const QString& name,int value){
+    if (value > 0){
+        AddQueryInt(query, name, value);
     }
-    timer->setSingleShot(true);
-    QObject::connect(timer, &QTimer::timeout, [=]() {
-        callback();
-        timer->deleteLater();
-    });
-    QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection, Q_ARG(int, 0));
 }
 
-void setTimeout(const std::function<void()> &callback, QObject *obj, int timeout) {
-    auto t = new QTimer;
-    QObject::connect(t, &QTimer::timeout, obj, [=] {
-        callback();
-        t->deleteLater();
-    });
-    t->setSingleShot(true);
-    t->setInterval(timeout);
-    t->start();
+QStringList GetQueryListValue(const QUrlQuery &q, const QString &key){
+    return QJsonArray2QListString(QString2QJsonArray(GetQueryValue(q, key)));
+}
+
+QVariantMap QString2QMap(const QString &key){
+    QJsonDocument doc = QJsonDocument::fromJson(key.toUtf8());
+
+    QVariantMap map;
+    if (!doc.isNull() && doc.isObject()) {
+        map = doc.object().toVariantMap();
+    }
+    return map;
 }
+
+QVariantMap GetQueryMapValue(const QUrlQuery &q, const QString &key){
+    return QString2QMap(GetQueryValue(q, key, "{}"));
+}
+
+QString QMap2QString(const QVariantMap &map) {
+    QJsonObject jsonObject = QJsonObject::fromVariantMap(map);
+    QJsonDocument jsonDoc(jsonObject);
+    return jsonDoc.toJson(QJsonDocument::Indented);  // Use Compact for a minified string
+}
+
diff --git a/src/global/GuiUtils.cpp b/src/global/GuiUtils.cpp
new file mode 100644
index 00000000..b1c43a08
--- /dev/null
+++ b/src/global/GuiUtils.cpp
@@ -0,0 +1,115 @@
+#include <nekobox/global/GuiUtils.hpp>
+#include <qnamespace.h>
+
+QWidget *GetMessageBoxParent() {
+  auto activeWindow = QApplication::activeWindow();
+  if (activeWindow == nullptr && mainwindow != nullptr) {
+    if (mainwindow->isVisible())
+      return mainwindow;
+    return nullptr;
+  }
+  return activeWindow;
+}
+/*
+int MessageBoxWarning(const QString &title, const QString &text) {
+    return QMessageBox::warning(GetMessageBoxParent(), title, text);
+}
+
+int MessageBoxInfo(const QString &title, const QString &text) {
+    return QMessageBox::information(GetMessageBoxParent(), title, text);
+}
+*/
+void ActivateWindow(QWidget *w) { ToggleWindow(w); }
+
+void ToggleWindow(QWidget *w) {
+  if (w->isVisible() && !(w->windowState() & Qt::WindowMinimized)) {
+    // Window is visible  minimize / hide
+    w->hide();
+  } else {
+    // Window is hidden or minimized  show
+    w->setWindowState(w->windowState() & ~Qt::WindowMinimized);
+    w->setVisible(true);
+#ifdef Q_OS_WIN
+    Windows_QWidget_SetForegroundWindow(w);
+#endif
+    w->raise();
+    w->activateWindow();
+  }
+}
+
+void runOnUiThread(const std::function<void()> &callback) {
+  // any thread
+  auto *timer = new QTimer();
+  auto thread = mainwindow->thread();
+  timer->moveToThread(thread);
+  timer->setSingleShot(true);
+  QObject::connect(timer, &QTimer::timeout, [=]() {
+    // main thread
+    callback();
+    timer->deleteLater();
+  });
+  QMetaObject::invokeMethod(timer, "start", Qt::QueuedConnection,
+                            Q_ARG(int, 0));
+}
+
+void setTimeout(const std::function<void()> &callback, QObject *obj,
+                int timeout) {
+  auto t = new QTimer;
+  QObject::connect(t, &QTimer::timeout, obj, [=] {
+    callback();
+    t->deleteLater();
+  });
+  t->setSingleShot(true);
+  t->setInterval(timeout);
+  t->start();
+}
+
+std::list<ProxyColorRule> latencyColorList = {
+    {1, 5, 0, 0, false, Qt::darkGreen},
+    {6, 5, 0, 0, false, QColor(128, 0, 128)},
+    {0, 0, 0, 0, false, QColor(255, 165, 0)},
+    {0, 0, 0, 0, true, Qt::red}};
+
+
+QColor DisplayLatencyColor(Configs::ProxyEntity *e) {
+  if (e != nullptr) {
+    if (e->latencyInt < 0) {
+      for (auto &color : latencyColorList) {
+        if (color.unavailable) {
+          return color.color;
+        }
+      }
+    } else {
+      for (auto &color : latencyColorList) {
+        if (!color.unavailable) {
+          if (color.orderRange > 0) {
+            if (e->latencyOrder < (int)color.orderMin) {
+              continue;
+            }
+            if (e->latencyOrder > (int)(color.orderMin + color.orderRange)) {
+              continue;
+            }
+          }
+          if (color.latencyRange > 0) {
+            if (e->latencyInt < (int)color.latencyMin) {
+              continue;
+            }
+            if (e->latencyInt > (int)(color.latencyMin + color.latencyRange)) {
+              continue;
+            }
+          }
+          return color.color;
+        }
+      }
+    }
+  }
+  return Qt::black;
+}
+
+std::map<Icon::TrayIconStatus, IndicatorRule> indicatorRuleMap = {
+    {Icon::TrayIconStatus::VPN, {0.4, 0.04, 0.4, QColor(165, 42, 42)}},
+    {Icon::TrayIconStatus::DNS, {0.4, 0.04, 0.4, Qt::darkMagenta}},
+    {Icon::TrayIconStatus::SYSTEM_PROXY, {0.4, 0.04, 0.4, Qt::blue}},
+    {Icon::TrayIconStatus::SYSTEM_PROXY_DNS, {0.4, 0.04, 0.4, Qt::darkMagenta}},
+    {Icon::TrayIconStatus::RUNNING, {0.4, 0.04, 0.4, Qt::darkGreen}}
+};
diff --git a/src/js/js_updater.cpp b/src/js/js_updater.cpp
index 5f77022c..fd3d52a7 100755
--- a/src/js/js_updater.cpp
+++ b/src/js/js_updater.cpp
@@ -5,7 +5,7 @@
 #include <QFile>
 #include <iostream>
 #include "nekobox/configs/ConfigBuilder.hpp"
-#include "nekobox/dataStore/Utils.hpp"
+#include "nekobox/global/GuiUtils.hpp"
 #include <nekobox/js/version.h>
 #include <nekobox/sys/Settings.h>
 #include <iostream>
@@ -94,8 +94,7 @@ void JsUpdaterWindow::unlock(){
 };
 
 QString JsUpdaterWindow::curdir(){
-    QDir dir("temp");
-    return dir.absolutePath();
+    return QDir::currentPath();
 }
 
 void JsUpdaterWindow::open_url(const QVariant url){
@@ -209,15 +208,19 @@ bool jsInit(
     QJSValue jsFactory = ctx->newQObject(factory);
 
     ctx->globalObject().setProperty("window", jsFactory);
-    jsFactory = ctx->newQMetaObject(&JsHTTPRequest::staticMetaObject);
-
-
+    
+	jsFactory = ctx->newQMetaObject(&JsHTTPRequest::staticMetaObject);
     ctx->globalObject().setProperty("HTTPResponse", jsFactory);
+	
+	jsFactory = ctx->newQMetaObject(&JsTextWriter::staticMetaObject);
+    ctx->globalObject().setProperty("TextWriter", jsFactory);
+	
     ctx->globalObject().setProperty("archive_name", "nekobox.zip");
 
     ctx->globalObject().setProperty("NKR_VERSION", NKR_VERSION);
     ctx->globalObject().setProperty("APPLICATION_DIR_PATH", root_directory);
 
+    ctx->globalObject().setProperty("NKR_SOFTWARE_NAME", software_name);
 
     QString script;
 
@@ -340,7 +343,9 @@ bool jsUpdater( JsUpdaterWindow* factory,
                 QString * archive_name,
                 bool * is_newer,
                 QStringList * args,
-                bool allow_updater){
+                bool allow_updater,
+                bool * keep_running
+){
     QJSEngine ctx;
     ctx.globalObject().setProperty("search", *search);
     ctx.globalObject().setProperty("UpdaterExists", allow_updater);
@@ -352,6 +357,7 @@ bool jsUpdater( JsUpdaterWindow* factory,
     getString(ctx, "archive_name", archive_name);
     getString(ctx, "search", search);
     getBoolean(ctx, "is_newer", is_newer);
+    getBoolean(ctx, "keep_running", keep_running);
     getStringList(ctx, "updater_args", args);
 
     return true;
diff --git a/src/js/version.cpp b/src/js/version.cpp
deleted file mode 100755
index f7599bd7..00000000
--- a/src/js/version.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-#include <nekobox/js/version.h>
-
-#ifdef NKR_DYNAMIC_VERSION
-
-#include <QCoreApplication>
-#include <QFile>
-#include <QTextStream>
-#include <QDebug>
-#include "nekobox/sys/Settings.h"
-
-const char * getVersionString(){
-    static const char * VERSION = nullptr;
-    if (VERSION == nullptr){
-        QString filePath = getResource("version.txt");
-        QFile file(filePath);
-        QString source;
-        if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
-#ifdef NKR_DEFAULT_VERSION
-            source = NKR_DEFAULT_VERSION;
-#else
-            source = "1.0.0";
-#endif
-        } else {
-            QTextStream in(&file);
-            source = in.readAll();
-            file.close();
-        }
-        QByteArray tempByteArray = source.simplified().toUtf8();
-        VERSION = strdup(tempByteArray.constData());
-    }
-    return VERSION;
-}
-
-#else
-
-const char * getVersionString(){
-    return NKR_VERSION;
-}
-
-#endif
diff --git a/src/main.cpp b/src/main.cpp
index 25736b09..daeb4d7d 100755
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -4,7 +4,6 @@
 #endif
 #include <csignal>
 
-#include <QApplication>
 #include <QCryptographicHash>
 #include <QDir>
 #include <QTranslator>
@@ -14,6 +13,8 @@
 #include <QLocalServer>
 #include <QThread>
 #include <QFileInfo>
+#include <QApplication>
+
 
 #ifdef Q_OS_WIN
 #include <3rdparty/WinCommander.hpp>
@@ -29,12 +30,14 @@
 #include "nekobox/sys/Settings.h"
 #include "nekobox/dataStore/ResourceEntity.hpp"
 
-#include "nekobox/ui/mainwindow_interface.h"
-#include "nekobox/dataStore/Utils.hpp"
+#include <nekobox/ui/mainwindow_interface.h>
+#include <nekobox/global/GuiUtils.hpp>
 
 std::map<std::string, std::string> ruleSetMap;
+QWidget *mainwindow;
 
 #ifdef Q_OS_UNIX
+#include <nekobox/sys/linux/LinuxCap.h>
 #include <qfontdatabase.h>
 #endif
 #define disable_run_admin windows_no_admin
@@ -92,6 +95,9 @@ int main(int argc, char** argv) {
 #ifdef Q_OS_WIN
     Windows_SetCrashHandler();
 #endif
+#ifdef Q_OS_LINUX
+    Unix_SetCrashHandler();
+#endif
 
     QApplication::setAttribute(Qt::AA_DontUseNativeDialogs);
     QApplication::setQuitOnLastWindowClosed(false);
@@ -195,7 +201,8 @@ int main(int argc, char** argv) {
     }
     
     Configs::resourceManager->Load();
-    if (Configs::resourceManager->symlinks_supported = createSymlink(getApplicationPath(), "resources/qr243vbi.lnk.lnk")){
+    bool supported = Configs::resourceManager->symlinks_supported = createSymlink(getApplicationPath(), "resources/qr243vbi.lnk.lnk");
+    if (supported){
         QFile::remove("resources/qr243vbi.lnk.lnk");
     };
 
diff --git a/src/nekobox/api/RPC.h b/src/nekobox/api/RPC.h
index c1136894..079ffcb5 100755
--- a/src/nekobox/api/RPC.h
+++ b/src/nekobox/api/RPC.h
@@ -1,47 +1,56 @@
 #pragma once
+#include "nekobox/configs/ConfigBuilder.hpp"
+#include <QString>
 #include <gen-cpp/libcore_types.h>
 #include <optional>
-#include <QString>
-
 
 namespace API {
-    class Client {
-    public:
-        explicit Client(std::function<void(const QString &)> onError, const QString &host, int port);
+class Client {
+public:
+  explicit Client(std::function<void(const QString &)> onError,
+                  const QString &host, int port);
+
+  // QString returns is error string
 
-        // QString returns is error string
+  QString Start(bool *rpcOK, const libcore::LoadConfigReq &request);
 
-        QString Start(bool *rpcOK, const libcore::LoadConfigReq &request);
+  std::tuple<QString, std::shared_ptr<Configs::BuildConfigResult>> StartEntity(bool *rpcOK,
+                      const std::shared_ptr<Configs::ProxyEntity> ent);
 
-        QString Stop(bool *rpcOK);
+  QString Stop(bool *rpcOK);
 
-        std::optional<libcore::QueryStatsResp> QueryStats();
+  std::optional<libcore::QueryStatsResp> QueryStats();
 
-        std::optional<libcore::TestResp> Test(bool *rpcOK, const libcore::TestReq &request);
+  std::optional<libcore::TestResp> Test(bool *rpcOK,
+                                        const libcore::TestReq &request);
 
-        void StopTests(bool *rpcOK);
+  void StopTests(bool *rpcOK);
 
-        std::optional<libcore::QueryURLTestResponse> QueryURLTest(bool *rpcOK);
+  std::optional<libcore::QueryURLTestResponse> QueryURLTest(bool *rpcOK);
 
-        QString SetSystemDNS(bool *rpcOK, bool clear) const;
+  QString SetSystemDNS(bool *rpcOK, bool clear) const;
 
-        std::optional<libcore::ListConnectionsResp> ListConnections(bool *rpcOK) const;
+  std::optional<libcore::ListConnectionsResp>
+  ListConnections(bool *rpcOK) const;
 
-        QString CheckConfig(bool *rpcOK, const QString& config) const;
+  QString CheckConfig(bool *rpcOK, const QString &config) const;
 
-        bool IsPrivileged(bool *rpcOK) const;
+  bool IsPrivileged(bool *rpcOK) const;
 
-        std::optional<libcore::SpeedTestResponse> SpeedTest(bool *rpcOK, const libcore::SpeedTestRequest &request);
+  std::optional<libcore::SpeedTestResponse>
+  SpeedTest(bool *rpcOK, const libcore::SpeedTestRequest &request);
 
-        std::optional<libcore::QuerySpeedTestResponse> QueryCurrentSpeedTests(bool *rpcOK);
+  std::optional<libcore::QuerySpeedTestResponse>
+  QueryCurrentSpeedTests(bool *rpcOK);
 
-        std::optional<libcore::QueryCountryTestResponse> QueryCountryTestResults(bool *rpcOK);
+  std::optional<libcore::QueryCountryTestResponse>
+  QueryCountryTestResults(bool *rpcOK);
 
-    private:
-        std::string domain;
-        int port;
-        std::function<void(const QString &)> onError;
-    };
+private:
+  std::string domain;
+  int port;
+  std::function<void(const QString &)> onError;
+};
 
-    inline Client *defaultClient;
+inline Client *defaultClient;
 } // namespace API
diff --git a/src/nekobox/configs/proxy/Preset.hpp b/src/nekobox/configs/proxy/Preset.hpp
index c893a498..589b6be0 100755
--- a/src/nekobox/configs/proxy/Preset.hpp
+++ b/src/nekobox/configs/proxy/Preset.hpp
@@ -24,7 +24,7 @@ namespace Preset::SingBox {
     "chacha20-ietf", 
     "xchacha20"
   };
-  inline QStringList V2RAYTransports = {"http", "grpc", "quic", "httpupgrade", "ws", "tcp"};
+  inline QStringList V2RAYTransports = {"http", "grpc", "quic", "httpupgrade", "ws", "tcp", "xhttp", "kcp"};
   inline QStringList Flows = {"xtls-rprx-vision"};
   inline QStringList SniffProtocols = {"http", "tls", "quic", "stun", "dns", "bittorrent", "dtls", "ssh", "rdp"};
   inline QStringList ActionTypes = {"route", "reject", "hijack-dns", "route-options", "sniff", "resolve"};
diff --git a/src/nekobox/configs/proxy/TorBean.hpp b/src/nekobox/configs/proxy/TorBean.hpp
new file mode 100755
index 00000000..45ef6d1a
--- /dev/null
+++ b/src/nekobox/configs/proxy/TorBean.hpp
@@ -0,0 +1,35 @@
+#pragma once
+
+#include "AbstractBean.hpp"
+#include "V2RayStreamSettings.hpp"
+#include "Preset.hpp"
+
+namespace Configs {
+    class TorBean : public AbstractBean {
+    public:
+        QString executable_path;
+        QStringList extra_args;
+        QString data_directory;
+        QVariantMap torrc;
+
+        TorBean() : AbstractBean(0) {
+        }
+        
+        INIT_MAP
+            ADD_MAP("executable_path", executable_path, string);
+            ADD_MAP("extra_args", extra_args, stringList);
+            ADD_MAP("data_directory", data_directory, string);
+            ADD_MAP("torrc", torrc, stringMap);
+        STOP_MAP
+
+        QString DisplayType() override { return "Tor"; };
+
+        CoreObjOutboundBuildResult BuildCoreObjSingBox() override;
+
+        bool TryParseLink(const QString &link);
+
+        bool TryParseJson(const QJsonObject &obj);
+
+        QString ToShareLink() override;
+    };
+} // namespace Configs
diff --git a/src/nekobox/configs/proxy/includes.h b/src/nekobox/configs/proxy/includes.h
index 0b6a224d..760a47c4 100755
--- a/src/nekobox/configs/proxy/includes.h
+++ b/src/nekobox/configs/proxy/includes.h
@@ -15,3 +15,4 @@
 #include "ExtraCore.h"
 #include "MieruBean.hpp"
 #include "ShadowTLSBean.hpp"
+#include "TorBean.hpp"
diff --git a/src/nekobox/dataStore/ConfigItem.hpp b/src/nekobox/dataStore/ConfigItem.hpp
index 2c036d2b..2e71b12b 100755
--- a/src/nekobox/dataStore/ConfigItem.hpp
+++ b/src/nekobox/dataStore/ConfigItem.hpp
@@ -17,7 +17,7 @@ typedef ConfJsMapStat & ConfJsMap;
 //}
 
 namespace Configs_ConfigItem {
-    // config 
+    // config
     enum itemType {
         type_string,
         type_integer,
@@ -27,6 +27,7 @@ namespace Configs_ConfigItem {
         type_integerList,
         type_jsonStore,
         type_jsonStoreList,
+        type_stringMap
     };
 
     class configItem {
@@ -74,14 +75,10 @@ namespace Configs_ConfigItem {
 
         void _setValue(const QString &name, void *p);
 
-   //     void _add(configItem *item);
-
         QString _name(void *p);
 
         std::shared_ptr<configItem> _get(const QString &name);
 
-//        void _setValue(const QString &name, void *p);
-
         QJsonObject ToJson(const QStringList &without = {});
 
         QByteArray ToJsonBytes();
@@ -96,4 +93,4 @@ namespace Configs_ConfigItem {
     };
 } // namespace Configs_ConfigItem
 
-using namespace Configs_ConfigItem;
\ No newline at end of file
+using namespace Configs_ConfigItem;
diff --git a/src/nekobox/dataStore/DataStore.hpp b/src/nekobox/dataStore/DataStore.hpp
index 2be574af..29b9d2f4 100755
--- a/src/nekobox/dataStore/DataStore.hpp
+++ b/src/nekobox/dataStore/DataStore.hpp
@@ -82,7 +82,7 @@ namespace Configs {
         bool flag_dns_set = false;
 
         // Saved
-        QString cache_database = "";
+   //     QString cache_database = "";
 
         // Misc
         QString log_level = "info";
diff --git a/src/nekobox/dataStore/Database.hpp b/src/nekobox/dataStore/Database.hpp
index 8a71ea30..1c2be67b 100755
--- a/src/nekobox/dataStore/Database.hpp
+++ b/src/nekobox/dataStore/Database.hpp
@@ -8,6 +8,12 @@
 namespace Configs {
     const int INVALID_ID = -99999;
 
+    class ProfileManager;
+
+    extern ProfileManager *profileManager;
+
+    extern QMap<QString, QString> profileDisplayNames; 
+
     class ProfileManager : private JsonStore {
     public:
         // JsonStore
@@ -29,6 +35,10 @@ namespace Configs {
 
         void SaveManager();
 
+        [[nodiscard]] static QString GetDisplayType(const QString & type);
+
+        [[nodiscard]] static std::shared_ptr<ProxyEntity> NewProxyEntity(const QString &type, bool nullok);
+
         [[nodiscard]] static std::shared_ptr<ProxyEntity> NewProxyEntity(const QString &type);
 
         [[nodiscard]] static std::shared_ptr<Group> NewGroup();
diff --git a/src/nekobox/dataStore/ProxyEntity.hpp b/src/nekobox/dataStore/ProxyEntity.hpp
index d5a4587b..45782257 100755
--- a/src/nekobox/dataStore/ProxyEntity.hpp
+++ b/src/nekobox/dataStore/ProxyEntity.hpp
@@ -4,6 +4,7 @@
 #include "nekobox/global/CountryHelper.hpp"
 #include "nekobox/stats/traffic/TrafficData.hpp"
 #include "nekobox/configs/proxy/AbstractBean.hpp"
+#include <QColor>
 #include "nekobox/configs/proxy/ExtraCore.h"
 
 namespace Configs {
@@ -31,23 +32,14 @@ namespace Configs {
 
     class SSHBean;
 
+    class TorBean;
+
     class CustomBean;
 
     class ChainBean;
 }; // namespace Configs
 
 namespace Configs {
-    struct ColorRule{
-        uint orderMin;
-        uint orderRange;
-        uint latencyMin;
-        uint latencyRange;
-        bool unavailable;
-        QColor color;
-    };
-
-    extern std::list<ColorRule> latencyColorList;
-
     class ProxyEntity : public JsonStore {
     private:
         Stats::TrafficData * traffic_data_pointer = nullptr;
@@ -76,7 +68,7 @@ namespace Configs {
 
         [[nodiscard]] QString DisplayTestResult() const;
 
-        [[nodiscard]] QColor DisplayLatencyColor() const;
+   //     [[nodiscard]] QColor DisplayLatencyColor() const;
 
         [[nodiscard]] Configs::ChainBean *ChainBean() const {
             return (Configs::ChainBean *) bean.get();
@@ -131,6 +123,10 @@ namespace Configs {
             return (Configs::SSHBean *) bean.get();
         };
 
+        [[nodiscard]] Configs::TorBean *TorBean() const {
+            return (Configs::TorBean *) bean.get();
+        };
+
         [[nodiscard]] Configs::CustomBean *CustomBean() const {
             return (Configs::CustomBean *) bean.get();
         };
diff --git a/src/nekobox/dataStore/Utils.hpp b/src/nekobox/dataStore/Utils.hpp
index f256f51e..6f09c551 100755
--- a/src/nekobox/dataStore/Utils.hpp
+++ b/src/nekobox/dataStore/Utils.hpp
@@ -5,15 +5,105 @@
 #include <memory>
 #include <QObject>
 #include <QString>
+#include <QUrlQuery>
+#include <QJsonArray>
+#include <QVariantMap>
 #include <QDebug>
-#include <QApplication>
-#include <QStyle>
 #include <QFile>
 #if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
 #include <QStyleHints>
 #endif
 //
 
+#ifndef KEY_VALUE_RANGE
+#define KEY_VALUE_RANGE
+#include <type_traits>
+#include <utility>
+template<typename T> class KeyValueRange {
+private:
+    T iterable; // This is either a reference or a moved-in value. The map data isn't copied.
+public:
+    KeyValueRange(T &iterable) : iterable(iterable) { }
+    KeyValueRange(std::remove_reference_t<T> &&iterable) noexcept : iterable(std::move(iterable)) { }
+    auto begin() const { return iterable.keyValueBegin(); }
+    auto end() const { return iterable.keyValueEnd(); }
+};
+
+template <typename T> auto asKeyValueRange(T &iterable) { return KeyValueRange<T &>(iterable); }
+template <typename T> auto asKeyValueRange(const T &iterable) { return KeyValueRange<const T &>(iterable); }
+template <typename T> auto asKeyValueRange(T &&iterable) noexcept { return KeyValueRange<T>(std::move(iterable)); }
+
+
+#include <QList>
+#include <cstddef>
+
+template<typename T>
+class ListRange {
+private:
+    T list;
+
+public:
+    ListRange(T &iterable) : list(iterable) { }
+    ListRange(std::remove_reference_t<T> &&iterable) noexcept : list(std::move(iterable)) { }
+
+    class iterator {
+        using ListType =
+        std::remove_reference_t<T>;
+        using BaseIter =
+        std::conditional_t<
+        std::is_const_v<ListType>,
+        typename ListType::const_iterator,
+        typename ListType::iterator>;
+
+        BaseIter it;
+        std::size_t index;
+
+    public:
+        iterator(BaseIter it, std::size_t index)
+        : it(it), index(index) {}
+
+        auto operator*() const {
+            return std::pair<std::size_t, decltype(*it)>(index, *it);
+        }
+
+        iterator& operator++() {
+            ++it;
+            ++index;
+            return *this;
+        }
+
+        bool operator!=(const iterator& other) const {
+            return it != other.it;
+        }
+    };
+
+    auto begin() {
+        return iterator(list.begin(), 0);
+    }
+
+    auto end() {
+        return iterator(list.end(), 0);
+    }
+};
+
+template<typename T>
+auto asListRange(QList<T>& list) {
+    return ListRange<QList<T>&>(list);
+}
+
+template<typename T>
+auto asListRange(const QList<T>& list) {
+    return ListRange<const QList<T>&>(list);
+}
+
+template<typename T>
+auto asListRange(QList<T>&& list) {
+    return ListRange<QList<T>>(std::move(list));
+}
+
+#endif
+
+
 
 #ifndef ADD_MAP
 
@@ -41,6 +131,14 @@ return ptr;      \
 #define ADD_MAP(X, Y, B) _put(ptr, X, &this->Y, ITEM_TYPE(B))
 #endif
 
+#ifndef NKR_VERSION
+inline QString software_version;
+const char * getSoftwareVersion();
+#define NKR_VERSION getSoftwareVersion()
+#define NKR_DYNAMIC_VERSION dynamic
+#endif
+
+inline QString software_build_date;
 inline QString software_name;
 inline QString software_core_name;
 
@@ -48,8 +146,6 @@ inline QString software_core_name;
 #define software_path   QApplication::applicationFilePath()
 
 // MainWindow functions
-class QWidget;
-inline QWidget *mainwindow;
 inline std::function<void(QString)> MW_show_log;
 inline std::function<void(QString, QString)> MW_dialog_message;
 
@@ -70,15 +166,9 @@ inline std::function<void(int)> TM_auto_update_subsctiption_Reset_Minute;
 
 inline const QString UNICODE_LRO = QString::fromUtf8(QByteArray::fromHex("E280AD"));
 
-inline QString SubStrBefore(QString str, const QString &sub) {
-    if (!str.contains(sub)) return str;
-    return str.left(str.indexOf(sub));
-}
+QString SubStrBefore(QString str, const QString &sub);
 
-inline QString SubStrAfter(QString str, const QString &sub) {
-    if (!str.contains(sub)) return str;
-    return str.right(str.length() - str.indexOf(sub) - sub.length());
-}
+QString SubStrAfter(QString str, const QString &sub);
 
 QString QStringList2Command(const QStringList &list);
 
@@ -98,6 +188,9 @@ class QUrlQuery;
 
 QString GetQueryValue(const QUrlQuery &q, const QString &key, const QString &def = "");
 
+int GetQueryIntValue(const QUrlQuery &q, const QString &key, int def = 0);
+QStringList GetQueryListValue(const QUrlQuery &q, const QString &key);
+
 QString GetRandomString(int randomStringLength);
 
 void MoveDirToTrash(const QString &path);
@@ -148,26 +241,14 @@ bool IsIpAddressV6(const QString &str);
 
 
 // [2001:4860:4860::8888] -> 2001:4860:4860::8888
-inline QString UnwrapIPV6Host(QString &str) {
-    return str.replace("[", "").replace("]", "");
-}
+QString UnwrapIPV6Host(QString &str);
 
 // [2001:4860:4860::8888] or 2001:4860:4860::8888 -> [2001:4860:4860::8888]
-inline QString WrapIPV6Host(QString &str) {
-    if (!IsIpAddressV6(str)) return str;
-    return "[" + UnwrapIPV6Host(str) + "]";
-}
+QString WrapIPV6Host(QString &str);
 
-inline QString DisplayAddress(QString serverAddress, int serverPort) {
-    if (serverAddress.isEmpty() && serverPort == 0) return {};
-    return WrapIPV6Host(serverAddress) + ":" + QString::number(serverPort);
-}
+QString DisplayAddress(QString serverAddress, int serverPort);
 
-inline QString DisplayDest(const QString& dest, QString domain)
-{
-    if (domain.isEmpty() || dest.split(":").first() == domain) return dest;
-    return dest + " (" + domain + ")";
-}
+QString DisplayDest(const QString& dest, QString domain);
 
 // Format & Misc
 
@@ -177,49 +258,28 @@ QString DisplayTime(long long time, int formatType = 0);
 
 QString ReadableSize(const qint64 &size);
 
-inline bool InRange(unsigned x, unsigned low, unsigned high) {
-    return (low <= x && x <= high);
-}
-
-inline bool IsValidPort(int port) {
-    return InRange(port, 1, 65535);
-}
-
-// UI
+bool InRange(unsigned x, unsigned low, unsigned high);
 
-QWidget *GetMessageBoxParent();
+bool IsValidPort(int port);
 
-int MessageBoxWarning(const QString &title, const QString &text);
+void runOnNewThread(const std::function<void()> &callback);
 
-int MessageBoxInfo(const QString &title, const QString &text);
+void runOnThread(const std::function<void()> &callback, QObject *parent);
 
-void ActivateWindow(QWidget *w);
+void AddQueryString(QUrlQuery & query, const QString & name, const QString & value);
 
-void ToggleWindow(QWidget *w);
+void AddQueryStringList( QUrlQuery & query, const QString & name, const QStringList & value);
 
-void runOnUiThread(const std::function<void()> &callback);
+void AddQueryMap( QUrlQuery & query, const QString &  name, const QVariantMap & value);
 
-void runOnNewThread(const std::function<void()> &callback);
+void AddQueryInt( QUrlQuery & query, const QString &  name, int value);
 
-void runOnThread(const std::function<void()> &callback, QObject *parent);
+void AddQueryNatural( QUrlQuery & query, const QString & name, int value);
 
-template<typename EMITTER, typename SIGNAL, typename RECEIVER, typename ReceiverFunc>
-inline void connectOnce(EMITTER *emitter, SIGNAL signal, RECEIVER *receiver, ReceiverFunc f,
-                        Qt::ConnectionType connectionType = Qt::AutoConnection) {
-    auto connection = std::make_shared<QMetaObject::Connection>();
-    auto onTriggered = [connection, f](auto... arguments) {
-        std::invoke(f, arguments...);
-        QObject::disconnect(*connection);
-    };
+QStringList GetQueryListValue(const QUrlQuery &q, const QString &key);
 
-    *connection = QObject::connect(emitter, signal, receiver, onTriggered, connectionType);
-}
+QVariantMap QString2QMap(const QString &key);
 
-void setTimeout(const std::function<void()> &callback, QObject *obj, int timeout = 0);
+QString QMap2QString(const QVariantMap &map);
 
-inline bool isDarkMode() {
-#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
-    return qApp->styleHints()->colorScheme() == Qt::ColorScheme::Dark;
-#endif
-    return qApp->style()->standardPalette().window().color().lightness() < qApp->style()->standardPalette().windowText().color().lightness();
-}
+QVariantMap GetQueryMapValue(const QUrlQuery &q, const QString &key);
diff --git a/src/nekobox/global/GuiUtils.hpp b/src/nekobox/global/GuiUtils.hpp
index 21576187..d05ca535 100755
--- a/src/nekobox/global/GuiUtils.hpp
+++ b/src/nekobox/global/GuiUtils.hpp
@@ -1,5 +1,30 @@
 #pragma once
 
+#include "3rdparty/qv2ray/wrapper.hpp"
+#include "3rdparty/QThreadCreateThread.hpp"
+#include <nekobox/ui/setting/Icon.hpp>
+#include <nekobox/dataStore/ProxyEntity.hpp>
+#include <nekobox/dataStore/Utils.hpp>
+#include <functional>
+#include <memory>
+#include <QObject>
+#include <QApplication>
+#include <QTimer>
+#include <QString>
+#include <QDebug>
+#include <QWidget>
+#include <QProcess>
+#include <QThread>
+#include <QFile>
+#include <QMessageBox>
+#include <QStyle>
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
+#include <QStyleHints>
+#endif
+
+#ifdef Q_OS_WIN
+#include "nekobox/sys/windows/guihelper.h"
+#endif
 // Dialogs
 
 #define Dialog_DialogBasicSettings "DialogBasicSettings"
@@ -19,9 +44,28 @@
 #define D_C_LOAD_STRING(a) CACHE.a = Configs::dataStore->a;
 #define D_C_SAVE_STRING(a) Configs::dataStore->a = CACHE.a;
 
+
+inline QString joinCommand(const QStringList &arguments) {
+    QString command;
+    for (QString arg : arguments) {
+        // Check for spaces or special characters
+        if (arg.contains(' ') || arg.contains('"')) {
+            command += '"' + arg.replace("\"", "\\\"") + "\" ";  // Escape existing quotes
+        } else {
+            command += arg + " ";
+        }
+    }
+    return command.trimmed(); // Remove trailing space
+}
+
+
 #define P_LOAD_STRING(a) ui->a->setText(bean->a);
+#define P_LOAD_STRINGLIST(a) ui->a->setText(joinCommand(bean->a));
+#define P_LOAD_STRINGMAP(a) ui->a->setText(QMap2QString(bean->a));
 #define P_LOAD_STRING_PLAIN(a) ui->a->setPlainText(bean->a);
 #define P_SAVE_STRING(a) bean->a = ui->a->text();
+#define P_SAVE_STRINGMAP(a) bean->a = QString2QMap(ui->a->toPlainText());
+#define P_SAVE_STRINGLIST(a) bean->a = QProcess::splitCommand(ui->a->text());
 #define P_SAVE_STRING_PLAIN(a) bean->a = ui->a->toPlainText();
 
 #define D_LOAD_STRING(a) ui->a->setText(Configs::dataStore->a);
@@ -115,3 +159,72 @@
             checkBox->setText(text + "*");                           \
         }                                                            \
     }
+
+
+// UI
+extern QWidget *mainwindow;
+
+QWidget *GetMessageBoxParent();
+
+#define MessageBoxWarning(T, X) \
+    runOnUiThread([=, this](){                                      \
+      QMessageBox::warning(this, T, X) ;                            \
+})                                                                  \
+
+#define MessageBoxInfo(T, X) \
+    runOnUiThread([=, this](){                                      \
+      QMessageBox::information(this, T, X) ;                        \
+})                                                                  \
+
+void ActivateWindow(QWidget *w);
+
+void ToggleWindow(QWidget *w);
+
+void runOnUiThread(const std::function<void()> &callback);
+
+
+template<typename EMITTER, typename SIGNAL, typename RECEIVER, typename ReceiverFunc>
+inline void connectOnce(EMITTER *emitter, SIGNAL signal, RECEIVER *receiver, ReceiverFunc f,
+                        Qt::ConnectionType connectionType = Qt::AutoConnection) {
+    auto connection = std::make_shared<QMetaObject::Connection>();
+    auto onTriggered = [connection, f](auto... arguments) {
+        std::invoke(f, arguments...);
+        QObject::disconnect(*connection);
+    };
+
+    *connection = QObject::connect(emitter, signal, receiver, onTriggered, connectionType);
+}
+
+void setTimeout(const std::function<void()> &callback, QObject *obj, int timeout = 0);
+
+
+inline bool isDarkMode() {
+#if QT_VERSION >= QT_VERSION_CHECK(6, 5, 0)
+    return qApp->styleHints()->colorScheme() == Qt::ColorScheme::Dark;
+#else
+    return qApp->style()->standardPalette().window().color().lightness() < qApp->style()->standardPalette().windowText().color().lightness();
+#endif
+}
+
+struct ProxyColorRule{
+    uint orderMin;
+    uint orderRange;
+    uint latencyMin;
+    uint latencyRange;
+    bool unavailable;
+    QColor color;
+};
+
+struct IndicatorRule{
+    double radius;
+    double margin;
+    double diameter;
+    QColor color;
+};
+
+extern std::list<ProxyColorRule> latencyColorList;
+
+extern std::map<Icon::TrayIconStatus, IndicatorRule> indicatorRuleMap;
+
+QColor DisplayLatencyColor(Configs::ProxyEntity *e);
+
diff --git a/src/nekobox/global/keyvaluerange.h b/src/nekobox/global/keyvaluerange.h
index 636beac4..7b45df59 100755
--- a/src/nekobox/global/keyvaluerange.h
+++ b/src/nekobox/global/keyvaluerange.h
@@ -1,87 +1,2 @@
-#ifndef KEY_VALUE_RANGE
-#define KEY_VALUE_RANGE
-#include <type_traits>
-#include <utility>
-template<typename T> class KeyValueRange {
-private:
-    T iterable; // This is either a reference or a moved-in value. The map data isn't copied.
-public:
-    KeyValueRange(T &iterable) : iterable(iterable) { }
-    KeyValueRange(std::remove_reference_t<T> &&iterable) noexcept : iterable(std::move(iterable)) { }
-    auto begin() const { return iterable.keyValueBegin(); }
-    auto end() const { return iterable.keyValueEnd(); }
-};
-
-template <typename T> auto asKeyValueRange(T &iterable) { return KeyValueRange<T &>(iterable); }
-template <typename T> auto asKeyValueRange(const T &iterable) { return KeyValueRange<const T &>(iterable); }
-template <typename T> auto asKeyValueRange(T &&iterable) noexcept { return KeyValueRange<T>(std::move(iterable)); }
-
-
-#include <QList>
-#include <cstddef>
-
-template<typename T>
-class ListRange {
-private:
-    T list;
-
-public:
-    ListRange(T &iterable) : list(iterable) { }
-    ListRange(std::remove_reference_t<T> &&iterable) noexcept : list(std::move(iterable)) { }
-
-    class iterator {
-        using ListType =
-            std::remove_reference_t<T>;
-        using BaseIter =
-            std::conditional_t<
-                std::is_const_v<ListType>,
-                typename ListType::const_iterator,
-                typename ListType::iterator>;
-
-        BaseIter it;
-        std::size_t index;
-
-    public:
-        iterator(BaseIter it, std::size_t index)
-            : it(it), index(index) {}
-
-        auto operator*() const {
-            return std::pair<std::size_t, decltype(*it)>(index, *it);
-        }
-
-        iterator& operator++() {
-            ++it;
-            ++index;
-            return *this;
-        }
-
-        bool operator!=(const iterator& other) const {
-            return it != other.it;
-        }
-    };
-
-    auto begin() {
-        return iterator(list.begin(), 0);
-    }
-
-    auto end() {
-        return iterator(list.end(), 0);
-    }
-};
-
-template<typename T>
-auto asListRange(QList<T>& list) {
-    return ListRange<QList<T>&>(list);
-}
-
-template<typename T>
-auto asListRange(const QList<T>& list) {
-    return ListRange<const QList<T>&>(list);
-}
-
-template<typename T>
-auto asListRange(QList<T>&& list) {
-    return ListRange<QList<T>>(std::move(list));
-}
-
-#endif
+#pragma once
+#include "nekobox/dataStore/Utils.hpp"
diff --git a/src/nekobox/js/js_updater.h b/src/nekobox/js/js_updater.h
index bc067a3d..fa09dfb0 100755
--- a/src/nekobox/js/js_updater.h
+++ b/src/nekobox/js/js_updater.h
@@ -85,7 +85,9 @@ bool jsUpdater( JsUpdaterWindow* bQueue,
   QString * archive_name,
   bool * is_newer,
   QStringList * args,
-  bool allow_updater);
+  bool allow_updater,
+  bool * keep_running
+);
 
 bool jsRouteProfileGetter(
     JsUpdaterWindow * factory,
diff --git a/src/nekobox/js/version.h b/src/nekobox/js/version.h
old mode 100755
new mode 100644
index da564ed8..75bc1a5e
--- a/src/nekobox/js/version.h
+++ b/src/nekobox/js/version.h
@@ -1,10 +1 @@
-#ifndef VERSION_GETTER
-#define VERSION_GETTER
-
-#ifndef NKR_VERSION
-#define NKR_VERSION getVersionString()
-const char * getVersionString();
-
-#endif
-
-#endif
+#include <nekobox/dataStore/Utils.hpp>
diff --git a/src/nekobox/sys/Process.hpp b/src/nekobox/sys/Process.hpp
index e4e38732..9aa3c647 100755
--- a/src/nekobox/sys/Process.hpp
+++ b/src/nekobox/sys/Process.hpp
@@ -13,9 +13,10 @@
 #endif
 
 namespace Configs_sys {
-    class CoreProcess : public QProcess
+    class CoreProcess: public QObject
     {
     public:
+        QProcess process;
         QString tag;
         QString program;
         QStringList arguments;
diff --git a/src/nekobox/sys/linux/LinuxCap.h b/src/nekobox/sys/linux/LinuxCap.h
index 553ac7de..53dfd267 100755
--- a/src/nekobox/sys/linux/LinuxCap.h
+++ b/src/nekobox/sys/linux/LinuxCap.h
@@ -1,5 +1,6 @@
 #pragma once
 
-#include <QString>
 
-bool Linux_HavePkexec();
+bool Unix_HavePkexec();
+
+void Unix_SetCrashHandler();
diff --git a/src/nekobox/ui/group/dialog_edit_group.h b/src/nekobox/ui/group/dialog_edit_group.h
index 9dacf4ba..a0c9cb0b 100755
--- a/src/nekobox/ui/group/dialog_edit_group.h
+++ b/src/nekobox/ui/group/dialog_edit_group.h
@@ -5,6 +5,7 @@
 #include <QString>
 #include <QEvent>
 #include <qtmetamacros.h>
+#include "nekobox/ui/setting/RouteItem.h"
 #include "nekobox/dataStore/Group.hpp"
 #include <vector>
 #include "ui_dialog_edit_group.h"
@@ -58,14 +59,18 @@ private:
     std::vector<int> groups;
     int selected_id = -1;
     int default_id = -1;
+    int last_id = -1;
+    bool is_for_routeprofile = false;
 
 public:
+    friend class RouteItem;
     Ui::DialogGroupChooseProxy *ui;
     explicit DialogGroupChooseProxy(QWidget *parent = nullptr);
 
     ~DialogGroupChooseProxy() override;
 signals: 
     void set_proxy(int id);
+    void select_proxy(int id);
 
 public slots:
     void change_tab(int id);
diff --git a/src/nekobox/ui/mainwindow.h b/src/nekobox/ui/mainwindow.h
index 5301172b..a52b8f74 100755
--- a/src/nekobox/ui/mainwindow.h
+++ b/src/nekobox/ui/mainwindow.h
@@ -22,6 +22,7 @@ class JsUpdaterWindow;
 #include <nekobox/js/js_updater.h>
 #endif
 
+extern QWidget *mainwindow;
 
 #ifndef MW_INTERFACE
 
@@ -259,6 +260,7 @@ private:
     //
     int proxy_last_order = -1;
     bool select_mode = false;
+    bool keep_running = false;
     QMutex mu_starting;
     QMutex mu_stopping;
     QMutex mu_exit;
diff --git a/src/nekobox/ui/profile/edit_tor.h b/src/nekobox/ui/profile/edit_tor.h
new file mode 100755
index 00000000..20c54512
--- /dev/null
+++ b/src/nekobox/ui/profile/edit_tor.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include <QWidget>
+#include "profile_editor.h"
+#include "ui_edit_tor.h"
+
+QT_BEGIN_NAMESPACE
+namespace Ui {
+    class EditTor;
+}
+QT_END_NAMESPACE
+
+class EditTor : public QWidget, public ProfileEditor {
+    Q_OBJECT
+
+public:
+    explicit EditTor(QWidget *parent = nullptr);
+    ~EditTor() override;
+
+    void onStart(std::shared_ptr<Configs::ProxyEntity> _ent) override;
+
+    bool onEnd() override;
+
+private:
+    Ui::EditTor *ui;
+    std::shared_ptr<Configs::ProxyEntity> ent;
+};
diff --git a/src/nekobox/ui/profile/edit_tor.ui b/src/nekobox/ui/profile/edit_tor.ui
new file mode 100755
index 00000000..19a54ab8
--- /dev/null
+++ b/src/nekobox/ui/profile/edit_tor.ui
@@ -0,0 +1,66 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>EditTor</class>
+ <widget class="QWidget" name="EditTor">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>441</width>
+    <height>330</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>EditTor</string>
+  </property>
+  <layout class="QFormLayout" name="formLayout">
+   <item row="0" column="0">
+    <widget class="QLabel" name="user_l">
+     <property name="text">
+      <string>Custom Path</string>
+     </property>
+    </widget>
+   </item>
+   <item row="0" column="1">
+    <widget class="QLineEdit" name="executable_path"/>
+   </item>
+   <item row="1" column="0">
+    <widget class="QLabel" name="password_l">
+     <property name="text">
+      <string>Extra Args</string>
+     </property>
+    </widget>
+   </item>
+   <item row="1" column="1">
+    <widget class="QLineEdit" name="extra_args"/>
+   </item>
+   <item row="3" column="0">
+    <widget class="QLabel" name="port_range_l">
+     <property name="text">
+      <string>Tor Config</string>
+     </property>
+    </widget>
+   </item>
+   <item row="3" column="1">
+    <widget class="QTextEdit" name="torrc"/>
+   </item>
+   <item row="4" column="0" colspan="2">
+    <widget class="QWidget" name="widget" native="true">
+     <layout class="QGridLayout" name="gridLayout"/>
+    </widget>
+   </item>
+   <item row="2" column="0">
+    <widget class="QLabel" name="multiplexing_l">
+     <property name="text">
+      <string>Data DIr</string>
+     </property>
+    </widget>
+   </item>
+   <item row="2" column="1">
+    <widget class="QLineEdit" name="data_directory"/>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
diff --git a/src/stats/autotester/ProxyAutoTester.cpp b/src/stats/autotester/ProxyAutoTester.cpp
index 1f248a32..a87493fb 100644
--- a/src/stats/autotester/ProxyAutoTester.cpp
+++ b/src/stats/autotester/ProxyAutoTester.cpp
@@ -2,7 +2,7 @@
 #include "nekobox/dataStore/ProxyEntity.hpp"
 #include "nekobox/dataStore/Database.hpp"
 #include "nekobox/dataStore/Configs.hpp"
-#include "nekobox/dataStore/Utils.hpp"
+#include "nekobox/global/GuiUtils.hpp"
 #include "nekobox/ui/mainwindow.h"
 #include "nekobox/api/RPC.h"
 
diff --git a/src/stats/connectionLister/connectionLister.cpp b/src/stats/connectionLister/connectionLister.cpp
index 07cec6e2..3daca359 100755
--- a/src/stats/connectionLister/connectionLister.cpp
+++ b/src/stats/connectionLister/connectionLister.cpp
@@ -1,7 +1,8 @@
 #include <QThread>
 #include <nekobox/api/RPC.h>
-#include "nekobox/ui/mainwindow_interface.h"
+#include <nekobox/ui/mainwindow_interface.h>
 #include <nekobox/stats/connections/connectionLister.hpp>
+#include <nekobox/global/GuiUtils.hpp>
 
 namespace Stats
 {
diff --git a/src/stats/traffic/TrafficLooper.cpp b/src/stats/traffic/TrafficLooper.cpp
index a8129ad6..9ef8231e 100755
--- a/src/stats/traffic/TrafficLooper.cpp
+++ b/src/stats/traffic/TrafficLooper.cpp
@@ -1,6 +1,7 @@
 #include "nekobox/stats/traffic/TrafficLooper.hpp"
 
 #include "nekobox/api/RPC.h"
+#include "nekobox/global/GuiUtils.hpp"
 #include "nekobox/ui/mainwindow_interface.h"
 
 #include <QElapsedTimer>
diff --git a/src/sys/Process.cpp b/src/sys/Process.cpp
index 0e8b271d..48a76de5 100755
--- a/src/sys/Process.cpp
+++ b/src/sys/Process.cpp
@@ -20,8 +20,8 @@ namespace Configs_sys {
     }
 
     void CoreProcess::Kill() {
-        kill();
-        waitForFinished();
+        process.kill();
+        process.waitForFinished();
     }
 
     CoreProcess::CoreProcess(const QString &core_path, const QStringList &args) {
@@ -30,8 +30,8 @@ namespace Configs_sys {
         arguments << "-waitpid";
         arguments << QString::number(QCoreApplication::applicationPid());
 
-        connect(this, &QProcess::readyReadStandardOutput, this, [&]() {
-            auto log = readAllStandardOutput();
+        connect(&process, &QProcess::readyReadStandardOutput, this, [&]() {
+            auto log = process.readAllStandardOutput();
             if (!Configs::dataStore->core_running) {
                 if (log.contains("Core listening at")) {
                     // The core really started
@@ -40,7 +40,7 @@ namespace Configs_sys {
                     start_profile_when_core_is_up = -1;
                 } else if (log.contains("failed to serve")) {
                     // The core failed to start
-                    kill();
+                    process.kill();
                 }
             }
             if (log.contains("Extra process exited unexpectedly"))
@@ -51,23 +51,23 @@ namespace Configs_sys {
             if (logCounter.fetchAndAddRelaxed(log.count("\n")) > Configs::dataStore->max_log_line) return;
             MW_show_log(log);
         });
-        connect(this, &QProcess::readyReadStandardError, this, [&]() {
-            auto log = readAllStandardError().trimmed();
+        connect(&process, &QProcess::readyReadStandardError, this, [&]() {
+            auto log = process.readAllStandardError().trimmed();
             MW_show_log(log);
         });
-        connect(this, &QProcess::errorOccurred, this, [&](ProcessError error) {
-            if (error == FailedToStart) {
+        connect(&process, &QProcess::errorOccurred, this, [&](QProcess::ProcessError error) {
+            if (error == QProcess::FailedToStart) {
                 failed_to_start = true;
-                MW_show_log("start core error occurred: " + errorString() + "\n");
+                MW_show_log("start core error occurred: " + process.errorString() + "\n");
             }
         });
-        connect(this, &QProcess::stateChanged, this, [&](ProcessState state) {
-            if (state == NotRunning) {
+        connect(&process, &QProcess::stateChanged, this, [&](QProcess::ProcessState state) {
+            if (state == QProcess::NotRunning) {
                 Configs::dataStore->core_running = false;
                 qDebug() << "Core stated changed to not running";
             }
 
-            if (!Configs::dataStore->prepare_exit && state == NotRunning) {
+            if (!Configs::dataStore->prepare_exit && state == QProcess::NotRunning) {
                 if (failed_to_start) return; // no retry
                 if (restarting) return;
 
@@ -98,14 +98,14 @@ namespace Configs_sys {
         started = true;
         QStringList list = QProcessEnvironment::systemEnvironment().toStringList();
         list << "NEKOBOX_APPIMAGE_CUSTOM_EXECUTABLE=nekobox_core";
-        setEnvironment(list);
-        start(program, arguments);
+        process.setEnvironment(list);
+        process.start(program, arguments);
     }
 
     void CoreProcess::Restart() {
         restarting = true;
-        kill();
-        waitForFinished(500);
+        process.kill();
+        process.waitForFinished(500);
         started = false;
         Start();
         restarting = false;
diff --git a/src/sys/linux/LinuxCap.cpp b/src/sys/linux/LinuxCap.cpp
index 6aa74413..ee9f1d80 100755
--- a/src/sys/linux/LinuxCap.cpp
+++ b/src/sys/linux/LinuxCap.cpp
@@ -1,10 +1,18 @@
-#include "nekobox/sys/linux/LinuxCap.h"
-
+#include <nekobox/sys/linux/LinuxCap.h>
 #include <QDebug>
 #include <QProcess>
 #include <QStandardPaths>
+#include <QString>
+#include <sys/resource.h>
+
+void Unix_SetCrashHandler() {
+    rlimit rl;
+    rl.rlim_cur = RLIM_INFINITY;
+    rl.rlim_max = RLIM_INFINITY;
+    setrlimit(RLIMIT_CORE, &rl);
+}
 
-bool Linux_HavePkexec() {
+bool Unix_HavePkexec() {
     QProcess p;
     p.setProgram("pkexec");
     p.setArguments({"--help"});
diff --git a/src/sys/windows/MiniDump.cpp b/src/sys/windows/MiniDump.cpp
index 4fb16d17..0f051283 100755
--- a/src/sys/windows/MiniDump.cpp
+++ b/src/sys/windows/MiniDump.cpp
@@ -13,7 +13,7 @@
 #include <QMessageBox>
 
 #include <nekobox/js/version.h>
-#include "nekobox/dataStore/Utils.hpp"
+#include "nekobox/global/GuiUtils.hpp"
 
 
 typedef BOOL(WINAPI *MINIDUMPWRITEDUMP)(
diff --git a/src/ui/group/dialog_edit_group.cpp b/src/ui/group/dialog_edit_group.cpp
index de03e363..955d25ca 100755
--- a/src/ui/group/dialog_edit_group.cpp
+++ b/src/ui/group/dialog_edit_group.cpp
@@ -4,11 +4,13 @@
 #include "nekobox/ui/mainwindow_interface.h"
 #include "nekobox/sys/Settings.h"
 #include <QHeaderView>
+#include <nekobox/global/GuiUtils.hpp>
 #include <QClipboard>
 #include <QStringListModel>
 #include <QCompleter>
 #include <QTableView>
 #include <qdialog.h>
+#include <functional>
 #include <qdialogbuttonbox.h>
 #include <qnamespace.h>
 
@@ -40,23 +42,28 @@ DialogEditGroup::DialogEditGroup(const std::shared_ptr<Configs::Group> &ent, QWi
         }
     }
 
-    connect(ui->copy_links, &QPushButton::clicked, this, [=,this] {
+    std::function<void(bool)> copy_click = [id=ent->id, this] (bool neko){
         QStringList links;
         for (const auto &[_, profile]: Configs::profileManager->profiles) {
-            if (profile->gid != ent->id) continue;
-            links += profile->bean->ToShareLink();
+            if (profile->gid != id) continue;
+            if (neko){
+                links += profile->bean->ToNekorayShareLink(profile->type);
+            } else {
+                links += profile->bean->ToShareLink();
+            }
         }
         QApplication::clipboard()->setText(links.join("\n"));
-        MessageBoxInfo(software_name, tr("Copied"));
+        runOnUiThread([this](){
+            QMessageBox::information(this, software_name, tr("Copied"));
+        });
+    };
+
+    connect(ui->copy_links, &QPushButton::clicked, this, [copy_click](){
+        copy_click(false);
     });
-    connect(ui->copy_links_nkr, &QPushButton::clicked, this, [=,this] {
-        QStringList links;
-        for (const auto &[_, profile]: Configs::profileManager->profiles) {
-            if (profile->gid != ent->id) continue;
-            links += profile->bean->ToNekorayShareLink(profile->type);
-        }
-        QApplication::clipboard()->setText(links.join("\n"));
-        MessageBoxInfo(software_name, tr("Copied"));
+
+    connect(ui->copy_links_nkr, &QPushButton::clicked, this, [copy_click](){
+        copy_click(true);
     });
 
     ui->name->setFocus();
@@ -252,8 +259,11 @@ void DialogGroupChooseProxy::dialog_button(QAbstractButton * button){
 }
 
 void DialogGroupChooseProxy::profile_selected(int profile, bool def){
+    if (this->selected_id != profile) {
+        emit select_proxy(profile);
+    }
     this->selected_id = profile;
-    this->ui->profile_label->setText(DialogEditGroup::get_proxy_name(profile));
+    this->ui->profile_label->setText(DialogEditGroup::get_proxy_name(profile, this->is_for_routeprofile));
     if (def){
         this->default_id = profile;
     }
@@ -342,7 +352,9 @@ DialogEditGroup::~DialogEditGroup() {
 void DialogEditGroup::accept() {
     if (ent->id >= 0) { // already a group
         if (!ent->url.isEmpty() && ui->url->text().isEmpty()) {
-            MessageBoxWarning(tr("Warning"), tr("Please input URL"));
+            runOnUiThread([this](){
+                QMessageBox::warning(this, tr("Warning"), tr("Please input URL"));
+            });
             return;
         }
     }
diff --git a/src/ui/mainwindow.cpp b/src/ui/mainwindow.cpp
index 103913ef..cdcd1a22 100755
--- a/src/ui/mainwindow.cpp
+++ b/src/ui/mainwindow.cpp
@@ -3,22 +3,21 @@
 #include "nekobox/configs/ConfigBuilder.hpp"
 #include "nekobox/configs/sub/GroupUpdater.hpp"
 #include "nekobox/dataStore/ProfileFilter.hpp"
+#include <nekobox/global/GuiUtils.hpp>
 #include "nekobox/dataStore/ResourceEntity.hpp"
-#include "nekobox/dataStore/Utils.hpp"
+#include "nekobox/global/keyvaluerange.h"
 #include "nekobox/sys/AutoRun.hpp"
 #include "nekobox/sys/Process.hpp"
-#include "nekobox/global/keyvaluerange.h"
 
 #include <QJsonDocument>
 #include <QMutex>
 #include <QQueue>
 #include <QWaitCondition>
-#include <nekobox/js/version.h>
 #include <qnamespace.h>
 #include <set>
 #ifdef _WIN32
-#include <winsock2.h>
 #include <windows.h>
+#include <winsock2.h>
 #endif
 
 #include "nekobox/ui/group/dialog_manage_groups.h"
@@ -83,62 +82,57 @@ extern std::map<std::string, std::string> ruleSetMap;
 
 void setAppIcon(Icon::TrayIconStatus, QSystemTrayIcon *, MainWindow *window);
 
-void MainWindow::set_icons(){
+void MainWindow::set_icons() {
   QSettings settings = getSettings();
   set_icons_from_settings(settings);
 }
 
-    void SpinnerDialog::addItem(QString item, QString name) {
-        listWidget->addItem(name);
-        list << (item);
-    }
+void SpinnerDialog::addItem(QString item, QString name) {
+  listWidget->addItem(name);
+  list << (item);
+}
 
-    void SpinnerDialog::onOk() {
-        auto ids = listWidget->selectedItems();
-        for (auto item : ids){
-          QString url = "";
-          QString profile = list[listWidget->indexFromItem(item).row()];
-          bool proxy = false;
-          auto resp = window->remoteRouteProfileGetter(profile, &url, &proxy);
-          if (resp.isEmpty()) {
-            return;
-          } else {
-            qDebug() << resp;
-          }
-          QString err;
-          auto parsed = Configs::RoutingChain::parseJsonArray(
-              QString2QJsonArray(resp), &err);
-          if (!err.isEmpty()) {
-            runOnUiThread([=, this] {
-              MessageBoxInfo(tr("Invalid JSON Array"),
-                             tr("The provided input cannot be parsed to a "
-                                "valid route rule array:\n") +
-                                 err);
-            });
-            return;
-          }
-          std::shared_ptr<Configs::RoutingChain> chain =
-              Configs::ProfileManager::NewRouteChain();
-          chain->chain_name =
-              window->remoteRouteProfileNames.value(profile, profile);
-          chain->update_url = url;
-          chain->defaultOutboundID =
-              //profile.startsWith("bypass", Qt::CaseInsensitive)
-                  proxy
-                  ? Configs::proxyID
-                  : Configs::directID;
-          chain->Rules.clear();
-          chain->Rules << parsed;
-          Configs::profileManager->AddRouteChain(chain);
-        }
+void SpinnerDialog::onOk() {
+  auto ids = listWidget->selectedItems();
+  for (auto item : ids) {
+    QString url = "";
+    QString profile = list[listWidget->indexFromItem(item).row()];
+    bool proxy = false;
+    auto resp = window->remoteRouteProfileGetter(profile, &url, &proxy);
+    if (resp.isEmpty()) {
+      return;
+    } else {
+      qDebug() << resp;
     }
-
-    void SpinnerDialog::onCancel() {
-      this->close();
+    QString err;
+    auto parsed =
+        Configs::RoutingChain::parseJsonArray(QString2QJsonArray(resp), &err);
+    if (!err.isEmpty()) {
+      runOnUiThread([=, this] {
+        QMessageBox::information(this, tr("Invalid JSON Array"),
+                                 tr("The provided input cannot be parsed to a "
+                                    "valid route rule array:\n") +
+                                     err);
+      });
+      return;
     }
+    std::shared_ptr<Configs::RoutingChain> chain =
+        Configs::ProfileManager::NewRouteChain();
+    chain->chain_name = window->remoteRouteProfileNames.value(profile, profile);
+    chain->update_url = url;
+    chain->defaultOutboundID =
+        // profile.startsWith("bypass", Qt::CaseInsensitive)
+        proxy ? Configs::proxyID : Configs::directID;
+    chain->Rules.clear();
+    chain->Rules << parsed;
+    Configs::profileManager->AddRouteChain(chain);
+  }
+}
 
-void MainWindow::getRemoteRouteProfiles(){
-   {
+void SpinnerDialog::onCancel() { this->close(); }
+
+void MainWindow::getRemoteRouteProfiles() {
+  {
 #ifdef SKIP_JS_UPDATER
     auto resp =
         NetworkRequestHelper::HttpGet("https://api.github.com/repos/qr243vbi/"
@@ -157,13 +151,14 @@ void MainWindow::getRemoteRouteProfiles(){
       }
       mu_remoteRouteProfiles.lock();
       remoteRouteProfiles = newRemoteRouteProfiles;
-
-      remoteRouteProfileGetter = [=, this](QString profile, QString * url, bool *proxy) -> QString {
+      remoteRouteProfileGetter = [=, this](QString profile, QString *url,
+                                           bool *proxy) -> QString {
         *proxy = profile.toLower().startsWith("bypass");
-        auto resp = NetworkRequestHelper::HttpGet( *url =
-            Configs::get_jsdelivr_link("https://raw.githubusercontent.com/"
-                                       "qr243vbi/ruleset/routeprofiles/" +
-                                       profile + ".json"));
+        auto resp = NetworkRequestHelper::HttpGet(
+                *url = Configs::get_jsdelivr_link(
+                    "https://raw.githubusercontent.com/"
+                    "qr243vbi/ruleset/routeprofiles/" +
+                    profile + ".json"));
         if (!resp.error.isEmpty()) {
           runOnUiThread([=, this] {
             MessageBoxWarning(QObject::tr("Download Profiles"),
@@ -202,83 +197,78 @@ void MainWindow::getRemoteRouteProfiles(){
   };
 }
 
-SpinnerDialog::SpinnerDialog(MainWindow * window){
-        this->window = window;
-        setWindowTitle(tr("Fetching information"));
+SpinnerDialog::SpinnerDialog(MainWindow *window) {
+  this->window = window;
+  setWindowTitle(tr("Fetching information"));
 
-        // Create the main layout
-        QVBoxLayout *mainLayout = new QVBoxLayout(this);
+  // Create the main layout
+  QVBoxLayout *mainLayout = new QVBoxLayout(this);
 
-        // Create a list widget
-        listWidget = new QListWidget(this);
+  // Create a list widget
+  listWidget = new QListWidget(this);
 
-        runOnUiThread([window = this->window, this](){
-          if (window->remoteRouteProfiles.isEmpty()){
-            window->getRemoteRouteProfiles();
-          }
-          for (auto profile: window->remoteRouteProfiles){
-            this->addItem(profile, window->remoteRouteProfileNames.value(
-              profile, profile));
-          }
-          setWindowTitle(tr("Download Profiles"));
-        });
+  runOnUiThread([window = this->window, this]() {
+    if (window->remoteRouteProfiles.isEmpty()) {
+      window->getRemoteRouteProfiles();
+    }
+    for (auto profile : window->remoteRouteProfiles) {
+      this->addItem(profile,
+                    window->remoteRouteProfileNames.value(profile, profile));
+    }
+    setWindowTitle(tr("Download Profiles"));
+  });
 
-        // Connect double-click signal
-        connect(listWidget, &QListWidget::itemDoubleClicked, this, &SpinnerDialog::onOk);
+  // Connect double-click signal
+  connect(listWidget, &QListWidget::itemDoubleClicked, this,
+          &SpinnerDialog::onOk);
 
-        // Create a button box with OK and Cancel buttons
-        QDialogButtonBox *buttonBox = new QDialogButtonBox(this);
-        auto okbutton = buttonBox->addButton(QDialogButtonBox::Ok);
-        auto cancelbutton = buttonBox->addButton(QDialogButtonBox::Cancel);
+  // Create a button box with OK and Cancel buttons
+  QDialogButtonBox *buttonBox = new QDialogButtonBox(this);
+  auto okbutton = buttonBox->addButton(QDialogButtonBox::Ok);
+  auto cancelbutton = buttonBox->addButton(QDialogButtonBox::Cancel);
 
-        // Connect signals to slots
-        connect(okbutton, &QPushButton::clicked, this, &SpinnerDialog::onOk);
-        connect(cancelbutton, &QPushButton::clicked, this, &SpinnerDialog::onCancel);
+  // Connect signals to slots
+  connect(okbutton, &QPushButton::clicked, this, &SpinnerDialog::onOk);
+  connect(cancelbutton, &QPushButton::clicked, this, &SpinnerDialog::onCancel);
 
-        // Add widgets to the main layout
-        mainLayout->addWidget(listWidget);
-        mainLayout->addWidget(buttonBox);
+  // Add widgets to the main layout
+  mainLayout->addWidget(listWidget);
+  mainLayout->addWidget(buttonBox);
 
-        // Set the layout to the window
-        setLayout(mainLayout);
-        resize(300, 200);
+  // Set the layout to the window
+  setLayout(mainLayout);
+  resize(300, 200);
 }
 
-void MainWindow::set_icons_from_settings(QSettings& settings){
+void MainWindow::set_icons_from_settings(QSettings &settings) {
   bool text_under_buttons = settings.value("text_under_buttons", true).toBool();
   set_icons_from_flag(text_under_buttons);
 }
 
-void MainWindow::set_icons_from_flag(bool text_under_buttons){
+void MainWindow::set_icons_from_flag(bool text_under_buttons) {
   QSize button_size;
   Qt::ToolButtonStyle button_style;
-  if (text_under_buttons){
-      button_size.setHeight(24);
-      button_size.setWidth(24);
-      button_style = Qt::ToolButtonStyle::ToolButtonTextUnderIcon;
+  if (text_under_buttons) {
+    button_size.setHeight(24);
+    button_size.setWidth(24);
+    button_style = Qt::ToolButtonStyle::ToolButtonTextUnderIcon;
   } else {
-      button_size.setHeight(37);
-      button_size.setWidth(32);
-      button_style = Qt::ToolButtonStyle::ToolButtonIconOnly;
+    button_size.setHeight(37);
+    button_size.setWidth(32);
+    button_style = Qt::ToolButtonStyle::ToolButtonIconOnly;
   }
 
   // styling
-  for ( auto button : {
-    ui->toolButton_preferences, 
-    ui->toolButton_program,
-    ui->toolButton_routing,
-    ui->toolButton_server,
-    ui->toolButton_update
-  }){
+  for (auto button :
+       {ui->toolButton_preferences, ui->toolButton_program,
+        ui->toolButton_routing, ui->toolButton_server, ui->toolButton_update}) {
     button->setToolButtonStyle(button_style);
     button->setIconSize(button_size);
   }
   // top bar set_icons
 }
 
-bool MainWindow::isShowRuleSetData(){
-  return showRuleSetData;
-}
+bool MainWindow::isShowRuleSetData() { return showRuleSetData; }
 
 void UI_InitMainWindow() { mainwindow = new MainWindow; }
 
@@ -308,7 +298,35 @@ std::map<std::string, std::string> jsonToMap(const QByteArray &byteArray) {
 MainWindow::MainWindow(QWidget *parent)
     : QMainWindow(parent), ui(new Ui::MainWindow) {
   mainwindow = this;
+  // software_name
+  {
+    QSettings globalSettings = getGlobal();
+#ifdef NKR_DYNAMIC_VERSION
+    software_version = globalSettings
+                           .value("software_version",
+#ifdef NKR_DEFAULT_VERSION
+                                  NKR_DEFAULT_VERSION
+#else
+                                  "1.0.0"
+#endif
+                                  )
+                           .toString();
+#endif
+    qDebug() << NKR_VERSION << software_version;
+    software_build_date =
+        globalSettings.value("software_build_date", "").toString();
+#ifdef NKR_TIMESTAMP
+    if (software_build_date.isEmpty()) {
+      software_build_date = NKR_TIMESTAMP;
+    }
+#endif
+    software_name = globalSettings.value("software_name", "nekobox").toString();
+    software_core_name =
+        globalSettings.value("software_core_name", "sing-box").toString();
+  }
+
   setAcceptDrops(true);
+
   MW_dialog_message = [=, this](const QString &a, const QString &b) {
     runOnUiThread([=, this] { dialog_message_impl(a, b); });
   };
@@ -494,10 +512,6 @@ MainWindow::MainWindow(QWidget *parent)
   //
   RegisterHotkey(false);
   //
-
-  // software_name
-  software_name = "nekobox";
-  software_core_name = "sing-box";
   //
   {
     auto appDataPath =
@@ -521,19 +535,16 @@ MainWindow::MainWindow(QWidget *parent)
 
   set_icons_from_settings(settings);
 
-  connect(
-      ui->actionAdd_new_Group, &QAction::triggered,
-      this,
-      [this] {
-        auto ent = Configs::ProfileManager::NewGroup();
-        auto dialog = new DialogEditGroup(ent, this);
-        int ret = dialog->exec();
-        dialog->deleteLater();
+  connect(ui->actionAdd_new_Group, &QAction::triggered, this, [this] {
+    auto ent = Configs::ProfileManager::NewGroup();
+    auto dialog = new DialogEditGroup(ent, this);
+    int ret = dialog->exec();
+    dialog->deleteLater();
 
-        if (ret == QDialog::Accepted) {
-          Configs::profileManager->AddGroup(ent);
-          MW_dialog_message(Dialog_DialogManageGroups, "refresh-1");
-        }
+    if (ret == QDialog::Accepted) {
+      Configs::profileManager->AddGroup(ent);
+      MW_dialog_message(Dialog_DialogManageGroups, "refresh-1");
+    }
   });
   ui->toolButton_program->setMenu(ui->menu_program);
   ui->toolButton_preferences->setMenu(ui->menu_preferences);
@@ -708,9 +719,9 @@ MainWindow::MainWindow(QWidget *parent)
   connect(ui->menu_open_config_folder, &QAction::triggered, this, [=, this] {
     QDesktopServices::openUrl(QUrl::fromLocalFile(QDir::currentPath()));
   });
-//  ui->toolButton_server->hide();
-//  connect(ui->menu_add_from_clipboard2, &QAction::triggered,
-//          ui->menu_add_from_clipboard, &QAction::trigger);
+  //  ui->toolButton_server->hide();
+  //  connect(ui->menu_add_from_clipboard2, &QAction::triggered,
+  //          ui->menu_add_from_clipboard, &QAction::trigger);
   connect(ui->actionRestart_Proxy, &QAction::triggered, this, [=, this] {
     if (Configs::dataStore->started_id >= 0)
       profile_start(Configs::dataStore->started_id);
@@ -779,11 +790,11 @@ MainWindow::MainWindow(QWidget *parent)
   });
 
   connect(ui->menu_server, &QMenu::aboutToShow, this, [=, this]() {
-  //  if (running) {
-  //    ui->actionSpeedtest_Current->setEnabled(true);
-  //  } else {
- //     ui->actionSpeedtest_Current->setEnabled(false);
-  //  }
+    //  if (running) {
+    //    ui->actionSpeedtest_Current->setEnabled(true);
+    //  } else {
+    //     ui->actionSpeedtest_Current->setEnabled(false);
+    //  }
     if (auto selected = get_now_selected_list(); selected.empty()) {
       ui->actionSpeedtest_Selected->setEnabled(false);
       ui->actionUrl_Test_Selected->setEnabled(false);
@@ -815,44 +826,43 @@ MainWindow::MainWindow(QWidget *parent)
     ruleSetMap = jsonToMap(byteArray);
   } else {
     delete srslist;
-    runOnNewThread([this](){getRuleSet();});
+    runOnNewThread([this]() { getRuleSet(); });
   }
 
-//  runOnUiThread(getRemoteRouteProfiles);
+  //  runOnUiThread(getRemoteRouteProfiles);
 
-//  QFile file_route(getResource("check_routeprofiles.js"));
+  //  QFile file_route(getResource("check_routeprofiles.js"));
 
   connect(ui->menuRouting_Menu, &QMenu::aboutToShow, this, [=, this]() {
-//    if (remoteRouteProfiles.isEmpty())
-//      runOnNewThread(getRemoteRouteProfiles);
+    //    if (remoteRouteProfiles.isEmpty())
+    //      runOnNewThread(getRemoteRouteProfiles);
     ui->menuRouting_Menu->clear();
 
     auto *actionProfiles = new QAction(ui->menuRouting_Menu);
-    actionProfiles->setText(QCoreApplication::translate(
-      "MainWindow", "Edit Routing Profiles"));
+    actionProfiles->setText(
+        QCoreApplication::translate("MainWindow", "Edit Routing Profiles"));
     ui->menuRouting_Menu->addAction(actionProfiles);
     connect(
-      actionProfiles, &QAction::triggered, this,
-      [this]() {
-        if (dialog_is_using)
-          return;
-        dialog_is_using = true;
-        auto dialog = new DialogManageRoutes(this, true);
-        connect(dialog, &QDialog::finished, this, [=, this] {
-          dialog->deleteLater();
-          dialog_is_using = false;
-        });
-        dialog->show();
-      },
-      Qt::SingleShotConnection);
+        actionProfiles, &QAction::triggered, this,
+        [this]() {
+          if (dialog_is_using)
+            return;
+          dialog_is_using = true;
+          auto dialog = new DialogManageRoutes(this, true);
+          connect(dialog, &QDialog::finished, this, [=, this] {
+            dialog->deleteLater();
+            dialog_is_using = false;
+          });
+          dialog->show();
+        },
+        Qt::SingleShotConnection);
 
     ui->menuRouting_Menu->addSeparator();
     // ui->menuRouting_Menu->addAction(ui->menu_routing_settings);
 
-
     auto *actionUpdateProfiles = new QAction(ui->menuRouting_Menu);
-    actionUpdateProfiles->setText(QCoreApplication::translate(
-        "MainWindow", "Update Routing Profiles"));
+    actionUpdateProfiles->setText(
+        QCoreApplication::translate("MainWindow", "Update Routing Profiles"));
     ui->menuRouting_Menu->addAction(actionUpdateProfiles);
     connect(
         actionUpdateProfiles, &QAction::triggered, this,
@@ -861,121 +871,120 @@ MainWindow::MainWindow(QWidget *parent)
             int profiles_count = updateRouteProfiles();
 
             runOnUiThread([profiles_count, this] {
-              if (profiles_count == 0){
-                
-                MessageBoxWarning(tr("Update Response"),
-                             tr("No routing profiles are updated"));
+              if (profiles_count == 0) {
+
+                QMessageBox::warning(this, tr("Update Response"),
+                                     tr("No routing profiles are updated"));
               } else {
-                MessageBoxInfo(tr("Update Response"),
-                             tr("Updated %1 routing profiles").arg(
-                              QString::number(profiles_count)));
+                QMessageBox::information(
+                    this, tr("Update Response"),
+                    tr("Updated %1 routing profiles")
+                        .arg(QString::number(profiles_count)));
               }
             });
           });
         },
         Qt::SingleShotConnection);
 
-
     auto *actionUpdateRuleSet = new QAction(ui->menuRouting_Menu);
-    actionUpdateRuleSet->setText(QCoreApplication::translate(
-      "MainWindow", "Update RuleSet Map"));
+    actionUpdateRuleSet->setText(
+        QCoreApplication::translate("MainWindow", "Update RuleSet Map"));
     ui->menuRouting_Menu->addAction(actionUpdateRuleSet);
     connect(
-      actionUpdateRuleSet, &QAction::triggered, this,
-      [this]() {
-        runOnNewThread([this] {
-          bool ruleset_updated = getRuleSet();
-          if (!ruleset_updated){
-            runOnUiThread([this] {
-              MessageBoxWarning(tr("Update Response"),
-                                tr("Failed to update rulesets"));
-            });
-          } else {
-            runOnUiThread([this] {
-              MessageBoxInfo(tr("Update Response"),
-                             tr("Rulesets updated successfully"));
+        actionUpdateRuleSet, &QAction::triggered, this,
+        [this]() {
+          runOnNewThread([this] {
+            bool ruleset_updated = getRuleSet();
+            runOnUiThread([this, ruleset_updated] {
+              if (!ruleset_updated) {
+                QMessageBox::warning(this, tr("Update Response"),
+                                     tr("Failed to update rulesets"));
+              } else {
+                QMessageBox::information(this, tr("Update Response"),
+                                         tr("Rulesets updated successfully"));
+              }
             });
-          }
-        });
-      },
-      Qt::SingleShotConnection);
-
+          });
+        },
+        Qt::SingleShotConnection);
 
     auto *actionUpdateRuleSetCache = new QAction(ui->menuRouting_Menu);
-    actionUpdateRuleSetCache->setText(QCoreApplication::translate(
-      "MainWindow", "Update RuleSet Cache"));
+    actionUpdateRuleSetCache->setText(
+        QCoreApplication::translate("MainWindow", "Update RuleSet Cache"));
     ui->menuRouting_Menu->addAction(actionUpdateRuleSetCache);
     connect(
-      actionUpdateRuleSetCache, &QAction::triggered, this,
-      [this]() {
-        runOnNewThread([this] {
-          if (mu_download_update.try_lock()){
-            QMutex mut;
-            showRuleSetData = true;
-            for (auto & item : ruleSetMap){
-              if (!showRuleSetData){
-                break;
-              }
-              QString url(QString::fromStdString(item.second));
-              QString str = Configs::get_cache_from_str(url);
-              QFile cache_file(str);
-              if (!cache_file.exists()){
-                mut.lock();
-                runOnUiThread([this,&str,&mut](){
-                  this->setDownloadReport(DownloadProgressReport{str, 0, 0}, true);
-                  UpdateDataView(true);
+        actionUpdateRuleSetCache, &QAction::triggered, this,
+        [this]() {
+          runOnNewThread([this] {
+            if (mu_download_update.try_lock()) {
+              QMutex mut;
+              showRuleSetData = true;
+              for (auto &item : ruleSetMap) {
+                if (!showRuleSetData) {
+                  break;
+                }
+                QString url(QString::fromStdString(item.second));
+                QString str = Configs::get_cache_from_str(url);
+                QFile cache_file(str);
+                if (!cache_file.exists()) {
+                  mut.lock();
+                  runOnUiThread([this, &str, &mut]() {
+                    this->setDownloadReport(DownloadProgressReport{str, 0, 0},
+                                            true);
+                    UpdateDataView(true);
+                    mut.unlock();
+                  });
+                  mut.lock();
                   mut.unlock();
+                  NetworkRequestHelper::DownloadAsset(
+                      Configs::get_jsdelivr_link(url), str);
+                }
+              }
+              if (showRuleSetData) {
+                showRuleSetData = false;
+                runOnUiThread([=, this] {
+                  QMessageBox::information(this, tr("Update Response"),
+                                           tr("Rulesets cache is updated"));
+
+                  this->setDownloadReport({}, false);
+                  this->UpdateDataView(true);
                 });
-                mut.lock();
-                mut.unlock();
-                NetworkRequestHelper::DownloadAsset(Configs::get_jsdelivr_link(url), str);
               }
+              mu_download_update.unlock();
             }
-            if (showRuleSetData){
-              showRuleSetData = false;
-              runOnUiThread([=, this] {
-                MessageBoxInfo(tr("Update Response"),
-                             tr("Rulesets cache is updated"));
-
-               GetMainWindow()->setDownloadReport({}, false);
-               GetMainWindow()->UpdateDataView(true);
-              });
-            }
-            mu_download_update.unlock();
-          }
-        });
-      },
-      Qt::SingleShotConnection);
+          });
+        },
+        Qt::SingleShotConnection);
 
     auto *actionClearRuleSetCache = new QAction(ui->menuRouting_Menu);
-    actionClearRuleSetCache->setText(QCoreApplication::translate(
-      "MainWindow", "Clear RuleSet Cache"));
+    actionClearRuleSetCache->setText(
+        QCoreApplication::translate("MainWindow", "Clear RuleSet Cache"));
     ui->menuRouting_Menu->addAction(actionClearRuleSetCache);
     connect(
-      actionClearRuleSetCache, &QAction::triggered, this,
-      [this]() {
-        runOnNewThread([this] {
-          showRuleSetData = false;
-          mu_download_update.lock();
-          mu_download_update.unlock();
-          MoveDirToTrash("rule_sets/ftps");
-          MoveDirToTrash("rule_sets/ftp");
-          MoveDirToTrash("rule_sets/http");
-          MoveDirToTrash("rule_sets/https");
-          
-          QMutex mut;
-          mut.lock();
-          runOnUiThread([this, &mut](){
+        actionClearRuleSetCache, &QAction::triggered, this,
+        [this]() {
+          runOnNewThread([this] {
             showRuleSetData = false;
-            setDownloadReport({}, false);
-            UpdateDataView(true);
+            mu_download_update.lock();
+            mu_download_update.unlock();
+            MoveDirToTrash("rule_sets/ftps");
+            MoveDirToTrash("rule_sets/ftp");
+            MoveDirToTrash("rule_sets/http");
+            MoveDirToTrash("rule_sets/https");
+
+            QMutex mut;
+            mut.lock();
+            runOnUiThread([this, &mut]() {
+              showRuleSetData = false;
+              setDownloadReport({}, false);
+              UpdateDataView(true);
+              mut.unlock();
+            });
+            mut.lock();
             mut.unlock();
           });
-          mut.lock();
-          mut.unlock();
-        });
-      }, Qt::SingleShotConnection
-    );
+        },
+        Qt::SingleShotConnection);
 
     ui->menuRouting_Menu->addSeparator();
 
@@ -997,23 +1006,23 @@ MainWindow::MainWindow(QWidget *parent)
     ui->menuRouting_Menu->addAction(actionAdblock);
 
     mu_remoteRouteProfiles.lock();
-    #ifndef SKIP_JS_UPDATER
+#ifndef SKIP_JS_UPDATER
     QFile file_route(getResource("check_routeprofiles.js"));
-    if (file_route.exists()){
-    #endif
+    if (file_route.exists()) {
+#endif
       auto *actionRoute = new QAction(ui->menuRouting_Menu);
-      actionRoute->setText(QCoreApplication::translate(
-      "SpinnerDialog","Download Profiles"));
-      connect(actionRoute, &QAction::triggered, this, 
-      [=, this](){
-        std::shared_ptr<SpinnerDialog> dialog = std::make_shared<SpinnerDialog>(this);
+      actionRoute->setText(
+          QCoreApplication::translate("SpinnerDialog", "Download Profiles"));
+      connect(actionRoute, &QAction::triggered, this, [=, this]() {
+        std::shared_ptr<SpinnerDialog> dialog =
+            std::make_shared<SpinnerDialog>(this);
         dialog->show();
         dialog->exec();
       });
       ui->menuRouting_Menu->addAction(actionRoute);
-    #ifndef SKIP_JS_UPDATER
+#ifndef SKIP_JS_UPDATER
     }
-    #endif
+#endif
     /*
     if (!remoteRouteProfiles.isEmpty()) {
       QMenu *profilesMenu =
@@ -1060,7 +1069,7 @@ MainWindow::MainWindow(QWidget *parent)
       }
     }
       */
-    
+
     mu_remoteRouteProfiles.unlock();
 
     ui->menuRouting_Menu->addSeparator();
@@ -1083,8 +1092,10 @@ MainWindow::MainWindow(QWidget *parent)
       ui->menuRouting_Menu->addAction(action);
     }
   });
-  connect(ui->actionUrl_Test_Selected, &QAction::triggered, this,
-          [=, this]() { urltest_current_group(get_now_selected_list()); });
+  connect(ui->actionUrl_Test_Selected, &QAction::triggered, this, [this]() {
+    qDebug() << "Url Test Selected Clicked";
+    urltest_current_group(get_now_selected_list());
+  });
   connect(ui->actionUrl_Test_Clear, &QAction::triggered, this,
           [=, this]() { on_menu_clear_test_result_triggered(true); });
   connect(ui->actionUrl_Test_Group, &QAction::triggered, this, [=, this]() {
@@ -1167,8 +1178,8 @@ MainWindow::MainWindow(QWidget *parent)
           [&] { UI_update_all_groups(true); });
   TM_auto_update_subsctiption_Reset_Minute(Configs::dataStore->sub_auto_update);
 
-  if ((!Configs::dataStore->flag_tray) && ( 
-        !settings.value("auto_hide", false).toBool() ) ){
+  if ((!Configs::dataStore->flag_tray) &&
+      (!settings.value("auto_hide", false).toBool())) {
     show();
   } else {
     hide();
@@ -1186,50 +1197,52 @@ void MainWindow::closeEvent(QCloseEvent *event) {
   }
 }
 
-int MainWindow::updateRouteProfiles(){
+int MainWindow::updateRouteProfiles() {
   auto profiles = Configs::profileManager->routes;
-            int profiles_count = 0;
-            for (const auto &item : profiles) {
-              auto &chain = item.second;
-              if (chain->skip_update){
-                continue;
-              }
-              auto url = chain->update_url;
-              if (!url.isEmpty()) {
-                url = Configs::get_jsdelivr_link(url);
-                auto response = NetworkRequestHelper::HttpGet(url);
-                if (response.error.isEmpty()) {
-                  QString err;
-                  auto parsed = Configs::RoutingChain::parseJsonArray(
-                      QString2QJsonArray(response.data), &err);
-                  if (err.isEmpty()) {
-                    chain->Rules.clear();
-                    chain->Rules << parsed;
-                    profiles_count ++;
-                  }
-                }
-              }
-            }
-            return profiles_count;
+  int profiles_count = 0;
+  for (const auto &item : profiles) {
+    auto &chain = item.second;
+    if (chain->skip_update) {
+      continue;
+    }
+    auto url = chain->update_url;
+    if (!url.isEmpty()) {
+      url = Configs::get_jsdelivr_link(url);
+      auto response = NetworkRequestHelper::HttpGet(url);
+      if (response.error.isEmpty()) {
+        QString err;
+        auto parsed = Configs::RoutingChain::parseJsonArray(
+            QString2QJsonArray(response.data), &err);
+        if (err.isEmpty()) {
+          chain->Rules.clear();
+          chain->Rules << parsed;
+          profiles_count++;
+        }
+      }
+    }
+  }
+  return profiles_count;
 }
 
-bool MainWindow::getRuleSet(){
-      QString err;
-      for (int retry = 0; retry < 5; retry++) {
-        auto err = NetworkRequestHelper::DownloadAsset(
-            Configs::get_jsdelivr_link(Configs::dataStore->routing->ruleset_json_url), "srslist.json");
-        if (err.isEmpty()) {
-          QFile file("srslist.json");
-          if (file.open(QIODevice::ReadOnly)){
-            auto resp_data = file.readAll();
-            ruleSetMap = jsonToMap(resp_data);
-          }
-          return true;
-        } else
-        QThread::sleep(30);
+bool MainWindow::getRuleSet() {
+  QString err;
+  for (int retry = 0; retry < 5; retry++) {
+    auto err = NetworkRequestHelper::DownloadAsset(
+        Configs::get_jsdelivr_link(
+            Configs::dataStore->routing->ruleset_json_url),
+        "srslist.json");
+    if (err.isEmpty()) {
+      QFile file("srslist.json");
+      if (file.open(QIODevice::ReadOnly)) {
+        auto resp_data = file.readAll();
+        ruleSetMap = jsonToMap(resp_data);
       }
-      MW_show_log(QObject::tr("Requesting rule-set list error: %1").arg(err));
-      return false;
+      return true;
+    } else
+      QThread::sleep(30);
+  }
+  MW_show_log(QObject::tr("Requesting rule-set list error: %1").arg(err));
+  return false;
 }
 
 void MainWindow::dragEnterEvent(QDragEnterEvent *event) {
@@ -1312,7 +1325,10 @@ void MainWindow::show_group(int gid) {
 
   auto group = Configs::profileManager->GetGroup(gid);
   if (group == nullptr) {
-    MessageBoxWarning(tr("Error"), QString("No such group: %1").arg(gid));
+    runOnUiThread([this, gid]() {
+      QMessageBox::warning(this, tr("Error"),
+                           QString("No such group: %1").arg(gid));
+    });
     Configs::dataStore->refreshing_group = false;
     return;
   }
@@ -1362,7 +1378,7 @@ void MainWindow::dialog_message_impl(const QString &sender,
   // info
   if (info.contains("UpdateIcon")) {
     icon_status = -1;
-    runOnUiThread([this](){
+    runOnUiThread([this]() {
       refresh_status();
       refresh_proxy_list(-1);
       set_icons();
@@ -1396,8 +1412,10 @@ void MainWindow::dialog_message_impl(const QString &sender,
     }
     refresh_proxy_list();
     if (info.contains("VPNChanged") && Configs::dataStore->spmode_vpn) {
-      MessageBoxWarning(tr("Tun Settings changed"),
-                        tr("Restart Tun to take effect."));
+      runOnUiThread([this]() {
+        QMessageBox::warning(this, tr("Tun Settings changed"),
+                             tr("Restart Tun to take effect."));
+      });
     }
     if ((info.contains("NeedChoosePort") || updateCorePath ||
          suggestRestartProxy) &&
@@ -1412,13 +1430,13 @@ void MainWindow::dialog_message_impl(const QString &sender,
     }
 
     if (proxyAutoTester) {
-        if (Configs::dataStore->auto_test_enable) {
-            proxyAutoTester->Reset();
-            proxyAutoTester->Start();
-            MW_show_log("[Auto-Test] Restarted with new settings");
-        } else {
-            proxyAutoTester->Stop();
-        }
+      if (Configs::dataStore->auto_test_enable) {
+        proxyAutoTester->Reset();
+        proxyAutoTester->Start();
+        MW_show_log("[Auto-Test] Restarted with new settings");
+      } else {
+        proxyAutoTester->Stop();
+      }
     }
 
     refresh_status();
@@ -1579,6 +1597,8 @@ void MainWindow::on_commitDataRequest() {
     settings.sync();
   }
   //
+
+  qDebug() << "Something?";
   //
   auto last_id = Configs::dataStore->started_id;
   if (Configs::dataStore->remember_enable && last_id >= 0) {
@@ -1600,8 +1620,6 @@ void MainWindow::prepare_exit() {
     mu_exit.unlock();
     return;
   }
-  hide();
-  tray->hide();
   Configs::dataStore->prepare_exit = true;
   //
   RegisterHiddenMenuShortcuts(true);
@@ -1646,7 +1664,7 @@ void MainWindow::on_menu_exit_triggered() {
 #endif
     list << this->updater_args;
     list << "--";
-    list << Configs::GetBasePath() + "/" + this->archive_name;
+    list << this->archive_name;
     list << updateDir;
     auto arguments = Configs::dataStore->argv;
     if (arguments.length() > 0) {
@@ -1669,14 +1687,10 @@ void MainWindow::on_menu_exit_triggered() {
       qDebug() << "File copied successfully from" << sourceFilePath << "to"
                << destinationFilePath;
 #ifdef Q_OS_WIN
-      if (!isDirectoryWritable(updateDir)) {
-        WinCommander::runProcessElevated(destinationFilePath, list, "",
-                                        SW_NORMAL, false);
-      } else {
-#endif
-        QProcess::startDetached(destinationFilePath, list);
-#ifdef Q_OS_WIN
-      }
+      WinCommander::runProcess(destinationFilePath, list, "", SW_NORMAL, false,
+                               (!isDirectoryWritable(updateDir)));
+#else
+      QProcess::startDetached(destinationFilePath, list);
 #endif
     } else {
       qDebug() << "Failed to copy file from" << sourceFilePath << "to"
@@ -1703,8 +1717,8 @@ void MainWindow::on_menu_exit_triggered() {
       if (exit_reason == 4)
         arguments << "-flag_restart_dns_set";
 #ifdef Q_OS_WIN
-      WinCommander::runProcessElevated(program, arguments, "",
-                                       SW_NORMAL, false);
+      WinCommander::runProcessElevated(program, arguments, "", SW_NORMAL,
+                                       false);
 #else
       QProcess::startDetached(program, arguments);
 #endif
@@ -1712,6 +1726,10 @@ void MainWindow::on_menu_exit_triggered() {
       QProcess::startDetached(program, arguments);
     }
   }
+  if (this->keep_running) {
+    this->keep_running = false;
+    return;
+  }
   QCoreApplication::quit();
 }
 
@@ -1735,8 +1753,11 @@ bool MainWindow::get_elevated_permissions(int reason, void *pointer) {
 #undef ELEVATE_CORE_PROGRAM
 
 #ifdef Q_OS_UNIX
-  if (!Linux_HavePkexec()) {
-    MessageBoxWarning(software_name, "Please install \"pkexec\" first.");
+  if (!Unix_HavePkexec()) {
+    runOnUiThread([this]() {
+      QMessageBox::warning(this, software_name,
+                           "Please install \"pkexec\" first.");
+    });
     return false;
   }
 #define ELEVATE_CORE_PROGRAM
@@ -1760,7 +1781,7 @@ skip_start_elevate_process:
 start_elevate_process: {
   StopVPNProcess();
   core_process->elevateCoreProcessProgram();
-  {
+  runOnUiThread([=, this]() {
     if (reason == 3) {
       bool save = false;
       if (pointer != nullptr) {
@@ -1768,7 +1789,7 @@ start_elevate_process: {
       }
       set_spmode_vpn(true, save, false);
     }
-  }
+  });
   return false;
 }
 skip_start_elevate_process:
@@ -1837,16 +1858,14 @@ void MainWindow::UpdateDataView(bool force) {
     }
     QString stat = ReadableSize(currentDownloadReport.downloadedSize) + "/" +
                    ReadableSize(currentDownloadReport.totalSize);
-    if (showRuleSetData){
+    if (showRuleSetData) {
       html =
-        QString(
-            "<p style='text-align:center;margin:0;'>Downloading %1</p>")
-            .arg(currentDownloadReport.fileName);
+          QString("<p style='text-align:center;margin:0;'>Downloading %1</p>")
+              .arg(currentDownloadReport.fileName);
     } else {
-      html =
-        QString(
-            "<p style='text-align:center;margin:0;'>Downloading %1: %2 %3</p>")
-            .arg(currentDownloadReport.fileName, stat, progressText);
+      html = QString("<p style='text-align:center;margin:0;'>Downloading %1: "
+                     "%2 %3</p>")
+                 .arg(currentDownloadReport.fileName, stat, progressText);
     }
   }
   if (showSpeedtestData) {
@@ -1858,14 +1877,13 @@ void MainWindow::UpdateDataView(bool force) {
             "<span style='color: #86C43F;'>Ul %3</span>"
             "</div>"
             "<p style='text-align:center;margin:0;'>Server: %4%5, %6</p>")
-            .arg(currentSptProfileName, 
-              QString::fromStdString(currentTestResult.dl_speed),
-              QString::fromStdString(currentTestResult.ul_speed),
+            .arg(currentSptProfileName,
+                 QString::fromStdString(currentTestResult.dl_speed),
+                 QString::fromStdString(currentTestResult.ul_speed),
                  CountryCodeToFlag(
-                     CountryNameToCode(
-                      (currentTestResult.server_country))),
-              QString::fromStdString(currentTestResult.server_country),
-              QString::fromStdString(currentTestResult.server_name));
+                     CountryNameToCode((currentTestResult.server_country))),
+                 QString::fromStdString(currentTestResult.server_country),
+                 QString::fromStdString(currentTestResult.server_name));
   }
   ui->data_view->setHtml(html);
   lastUpdated = QDateTime::currentDateTime();
@@ -2141,8 +2159,12 @@ void MainWindow::refresh_status(const QString &traffic_update) {
         Configs::dataStore->spmode_system_proxy)
       tt << "[Tun+" + tr("System Proxy") + "]";
     tt << software_name;
-    if (!isTray)
+    if (!isTray) {
       tt << QString(NKR_VERSION);
+      if (!software_build_date.isEmpty()) {
+        tt << software_build_date;
+      }
+    }
     if (!Configs::dataStore->active_routing.isEmpty() &&
         Configs::dataStore->active_routing != "Default") {
       tt << "[" + Configs::dataStore->active_routing + "]";
@@ -2355,6 +2377,8 @@ void MainWindow::refresh_proxy_list_impl_refresh_data(const int &id,
                                                       bool stopping) {
   ui->proxyListTable->setUpdatesEnabled(false);
   auto currentGroup = Configs::profileManager->CurrentGroup();
+  if (currentGroup == nullptr)
+    return;
   if (id >= 0) {
     if (!currentGroup->HasProfile(id)) {
       ui->proxyListTable->setUpdatesEnabled(true);
@@ -2440,7 +2464,7 @@ void MainWindow::refresh_table_item(
   // C3: Test Result
   f = f0->clone();
   if (profile->full_test_report.isEmpty()) {
-    auto color = profile->DisplayLatencyColor();
+    auto color = DisplayLatencyColor(profile.get());
     if (color.isValid())
       f->setForeground(color);
     f->setText(profile->DisplayTestResult());
@@ -2786,7 +2810,7 @@ void MainWindow::parseQrImage(const QPixmap *image) {
   const QVector<QString> texts = QrDecoder().decode(
       image->toImage().convertToFormat(QImage::Format_Grayscale8));
   if (texts.isEmpty()) {
-    MessageBoxInfo(software_name, tr("QR Code not found"));
+    QMessageBox::information(this, software_name, tr("QR Code not found"));
   } else {
     for (const QString &text : texts) {
       show_log_impl("QR Code Result:\n" + text);
@@ -2806,7 +2830,8 @@ void MainWindow::on_menu_scan_qr_triggered() {
   if (ok) {
     parseQrImage(&qpx);
   } else {
-    MessageBoxInfo(software_name, tr("Unable to capture screen"));
+    QMessageBox::information(this, software_name,
+                             tr("Unable to capture screen"));
   }
 }
 
@@ -3323,6 +3348,13 @@ void MainWindow::RegisterHiddenMenuShortcuts(bool unregister) {
           action->shortcut(), this, [=, this]() { action->trigger(); }));
     }
   }
+
+  for (const auto &action : ui->menu_server->actions()) {
+    if (!action->shortcut().toString().isEmpty()) {
+      hiddenMenuShortcuts.append(new QShortcut(
+          action->shortcut(), this, [=, this]() { action->trigger(); }));
+    }
+  }
 }
 
 void MainWindow::setActionsData() {
@@ -3352,6 +3384,7 @@ void MainWindow::setActionsData() {
 
 QList<QAction *> MainWindow::getActionsForShortcut() {
   QList<QAction *> list;
+
   QList<QAction *> actions = findChildren<QAction *>();
 
   for (QAction *action : actions) {
@@ -3359,6 +3392,7 @@ QList<QAction *> MainWindow::getActionsForShortcut() {
       continue;
     list.append(action);
   }
+
   return list;
 }
 
@@ -3410,45 +3444,46 @@ JsUpdaterWindow *MainWindow::createJsUpdaterWindow() {
   // Connect the signal to a lambda function
   connect(bQueue, &JsUpdaterWindow::warning_signal, this,
           [=, this](const QString &message, const QString &title) {
-            runOnUiThread([=, this] { MessageBoxWarning(title, message); });
+            runOnUiThread(
+                [=, this] { QMessageBox::warning(this, title, message); });
           });
 
   // Connect the signal to a lambda function
   connect(bQueue, &JsUpdaterWindow::info_signal, this,
           [=, this](const QString &message, const QString &title) {
-            runOnUiThread([=, this] { MessageBoxInfo(title, message); });
+            runOnUiThread(
+                [=, this] { QMessageBox::information(this, title, message); });
           });
 
-  connect(bQueue, &JsUpdaterWindow::download_signal, this, 
-          [=, this](const QString &url, const QString &fileName, QString *ret){
-            *ret = NetworkRequestHelper::DownloadAsset(url, fileName);;
+  connect(bQueue, &JsUpdaterWindow::download_signal, this,
+          [=, this](const QString &url, const QString &fileName, QString *ret) {
+            *ret = NetworkRequestHelper::DownloadAsset(url, fileName);
+            ;
             bQueue->unlock();
           });
 
   // Connect the signal to a lambda function
   connect(bQueue, &JsUpdaterWindow::ask_signal, this,
-          [=, this](const QString &message, const QString &title, const QStringList &list, 
-              int* ret) {
-        //    runOnUiThread([ret, this, &mut, &title, &message, &list] {
-              QMessageBox box(QMessageBox::Question,
-                              title,
-                              message);
-
-              QMap<QPushButton*, int> buttons;
-              for (auto [k, str] : asListRange(list)){
-                buttons[box.addButton(str, QMessageBox::ActionRole)] = k;
-              }
-              box.exec();
-              auto button = box.clickedButton();
-              for (auto [btn, i]: asKeyValueRange(buttons)){
-                if (btn == button){
-                  *ret = i;
-                  break;
-                }
+          [=, this](const QString &message, const QString &title,
+                    const QStringList &list, int *ret) {
+            //    runOnUiThread([ret, this, &mut, &title, &message, &list] {
+            QMessageBox box(QMessageBox::Question, title, message);
+
+            QMap<QPushButton *, int> buttons;
+            for (auto [k, str] : asListRange(list)) {
+              buttons[box.addButton(str, QMessageBox::ActionRole)] = k;
+            }
+            box.exec();
+            auto button = box.clickedButton();
+            for (auto [btn, i] : asKeyValueRange(buttons)) {
+              if (btn == button) {
+                *ret = i;
+                break;
               }
-              
-              bQueue->unlock();
-         //   });
+            }
+
+            bQueue->unlock();
+            //   });
           });
 
   return bQueue;
@@ -3456,6 +3491,7 @@ JsUpdaterWindow *MainWindow::createJsUpdaterWindow() {
 #endif
 
 void MainWindow::HotkeyEvent(const QString &key) {
+  qDebug() << "Hot Key Pressed" << key;
   if (key.isEmpty())
     return;
   runOnUiThread([=, this] {
@@ -3587,19 +3623,16 @@ bool isNewer(QString assetName) {
 
 #ifndef SKIP_UPDATE_BUTTON
 #ifndef SKIP_JS_UPDATER
-#include <nekobox/js/js_updater.h>
 #include <iostream>
+#include <nekobox/js/js_updater.h>
 #endif
 void MainWindow::CheckUpdate() {
   bool is_newer = false;
 
   QString archive_name = "nekobox.zip",
 #ifdef SKIP_JS_UPDATER
-          assets_name = "",
-          release_download_url = "",
-          release_url = "",
-          release_note = "",
-          note_pre_release = "",
+          assets_name = "", release_download_url = "", release_url = "",
+          release_note = "", note_pre_release = "",
 #endif
           search = "";
 
@@ -3691,22 +3724,21 @@ end_search_define:
 
   updaterPath = getUpdaterPath();
 
-bool allow_updater = true;
+  bool allow_updater = true;
 #ifndef Q_OS_WIN
 #ifdef Q_OS_UNIX
-if (isAppImage()) {
-  allow_updater =
-  (access(softwareFilePath.toUtf8().constData(), W_OK) == 0);
-} else {
-  #endif
-  allow_updater = isDirectoryWritable(softwarePath);
-  if (allow_updater){
-    if (!QFile::exists(updaterPath)){
-      allow_updater = false;
+  if (isAppImage()) {
+    allow_updater = (access(softwareFilePath.toUtf8().constData(), W_OK) == 0);
+  } else {
+#endif
+    allow_updater = isDirectoryWritable(softwarePath);
+    if (allow_updater) {
+      if (!QFile::exists(updaterPath)) {
+        allow_updater = false;
+      }
     }
+#ifdef Q_OS_UNIX
   }
-  #ifdef Q_OS_UNIX
-}
 #endif
 #endif
 
@@ -3730,15 +3762,15 @@ if (isAppImage()) {
 
   bQueue = createJsUpdaterWindow();
 
-  jsUpdater(bQueue, &updater_js, &search, &archive_name,
-            &is_newer, &updater_args, allow_updater);
+  jsUpdater(bQueue, &updater_js, &search, &archive_name, &is_newer,
+            &updater_args, allow_updater, &this->keep_running);
 #endif
 skip1:
 
   if (search.isEmpty()) {
     runOnUiThread([=, this] {
-      MessageBoxWarning(QObject::tr("Update"),
-                        QObject::tr("Not official support platform"));
+      QMessageBox::warning(this, QObject::tr("Update"),
+                           QObject::tr("Not official support platform"));
     });
     return;
   }
@@ -3806,17 +3838,13 @@ skip1:
 
     qDebug() << "ARCHIVE PATH" << archive_name;
 
-    runOnNewThread([=, this] {
-      on_menu_exit_triggered();
-    });
+    runOnNewThread([=, this] { on_menu_exit_triggered(); });
   }
 
 #endif
 
 #ifdef SKIP_JS_UPDATER
   runOnUiThread([=, this] {
-
-
     QMessageBox box(QMessageBox::Question,
                     QObject::tr("Update") + note_pre_release,
                     QObject::tr("Update found: %1\nRelease note:\n%2")
@@ -3824,7 +3852,7 @@ skip1:
     //
     box.addButton(QObject::tr("Close"), QMessageBox::RejectRole);
     QAbstractButton *btn2 =
-      box.addButton(QObject::tr("Open in browser"), QMessageBox::AcceptRole);
+        box.addButton(QObject::tr("Open in browser"), QMessageBox::AcceptRole);
     QAbstractButton *btn1 = nullptr;
     if (allow_updater) {
       btn1 = box.addButton(QObject::tr("Update"), QMessageBox::AcceptRole);
@@ -3866,7 +3894,8 @@ skip1:
                 QObject::tr("Update is ready, restart to install?"));
             if (q == QMessageBox::StandardButton::Yes) {
               this->exit_reason = 1;
-              this->archive_name = archive_path;
+              this->archive_name =
+                  Configs::GetBasePath() + "/temp/" + archive_path;
               on_menu_exit_triggered();
             }
           } else {
@@ -3879,6 +3908,5 @@ skip1:
     }
   });
 #endif
-
 }
 #endif
diff --git a/src/ui/mainwindow_rpc.cpp b/src/ui/mainwindow_rpc.cpp
index be706b61..2f6d5537 100755
--- a/src/ui/mainwindow_rpc.cpp
+++ b/src/ui/mainwindow_rpc.cpp
@@ -6,7 +6,7 @@
 #include "nekobox/api/RPC.h"
 #include "nekobox/ui/utils//MessageBoxTimer.h"
 #include "3rdparty/qv2ray/v2/proxy/QvProxyConfigurator.hpp"
-
+#include <nekobox/global/GuiUtils.hpp>
 #include <QInputDialog>
 #include <QPushButton>
 #include <QDesktopServices>
@@ -156,7 +156,9 @@ void MainWindow::urltest_current_group(const QList<std::shared_ptr<Configs::Prox
         return;
     }
     if (!speedtestRunning.tryLock()) {
-        MessageBoxWarning(software_name, tr("The last url test did not exit completely, please wait. If it persists, please restart the program."));
+        runOnUiThread([this](){
+            QMessageBox::warning(this, software_name, tr("The last url test did not exit completely, please wait. If it persists, please restart the program."));
+        });
         return;
     }
 
@@ -253,7 +255,9 @@ void MainWindow::speedtest_current_group(const QList<std::shared_ptr<Configs::Pr
         return;
     }
     if (!speedtestRunning.tryLock()) {
-        MessageBoxWarning(software_name, tr("The last speed test did not exit completely, please wait. If it persists, please restart the program."));
+        runOnUiThread([this](){
+            QMessageBox::warning(this, software_name, tr("The last speed test did not exit completely, please wait. If it persists, please restart the program."));
+        });
         return;
     }
 
@@ -480,6 +484,7 @@ bool MainWindow::set_system_dns(bool set, bool save_set) {
 }
 
 void MainWindow::profile_start(int _id) {
+    
     if (Configs::dataStore->prepare_exit) return;
 #ifdef Q_OS_UNIX
     if (Configs::dataStore->enable_dns_server && Configs::dataStore->dns_server_listen_port <= 1024) {
@@ -489,43 +494,29 @@ void MainWindow::profile_start(int _id) {
         }
     }
 #endif
+     
+    qDebug() << "profile starting: " << _id;
 
     auto ents = get_now_selected_list();
     auto ent = (_id < 0 && !ents.isEmpty()) ? ents.first() : Configs::profileManager->GetProfile(_id);
     if (ent == nullptr) return;
-
+/*
     if (select_mode) {
         emit profile_selected(ent->id);
         select_mode = false;
-        refresh_status();
+        runOnUiThread([this](){
+            refresh_status();
+        });
         return;
     }
-
+*/
     auto group = Configs::profileManager->GetGroup(ent->gid);
     if (group == nullptr || group->archive) return;
 
-    auto result = BuildConfig(ent, false, false);
-    if (!result->error.isEmpty()) {
-        MessageBoxWarning(tr("BuildConfig return error"), result->error);
-        return;
-    }
-
     auto profile_start_stage2 = [=, this] {
-        libcore::LoadConfigReq req;
-        req.core_config = (QJsonObject2QString(result->coreConfig, true)).toStdString();
-        req.disable_stats = (Configs::dataStore->disable_traffic_stats);
-        if (ent->type == "extracore")
-        {
-            req.need_extra_process = (true);
-            req.extra_process_path = (result->extraCoreData->path).toStdString();
-            req.extra_process_args = (result->extraCoreData->args).toStdString();
-            req.extra_process_conf = (result->extraCoreData->config).toStdString();
-            req.extra_process_conf_dir = (result->extraCoreData->configDir).toStdString();
-            req.extra_no_out = (result->extraCoreData->noLog);
-        }
         //
         bool rpcOK;
-        QString error = defaultClient->Start(&rpcOK, req);
+        auto [error, result] = defaultClient->StartEntity(&rpcOK, ent);
         if (!rpcOK) {
             return false;
         }
@@ -553,7 +544,9 @@ void MainWindow::profile_start(int _id) {
                 });
                 return false;
             }
-            runOnUiThread([=,this] { MessageBoxWarning("LoadConfig return error", error); });
+            runOnUiThread([error,this] { 
+               QMessageBox::warning(this, "LoadConfig return error", error); 
+            });
             return false;
         }
         //
@@ -576,11 +569,17 @@ void MainWindow::profile_start(int _id) {
     };
 
     if (!mu_starting.tryLock()) {
-        MessageBoxWarning(software_name, tr("Another profile is starting..."));
+        
+        runOnUiThread([this](){
+            QMessageBox::warning(this, software_name, tr("Another profile is starting..."));
+        });
         return;
     }
     if (!mu_stopping.tryLock()) {
-        MessageBoxWarning(software_name, tr("Another profile is stopping..."));
+        
+        runOnUiThread([this](){
+            QMessageBox::warning(this, software_name, tr("Another profile is stopping..."));
+        });
         mu_starting.unlock();
         return;
     }
@@ -603,12 +602,16 @@ void MainWindow::profile_start(int _id) {
     auto restartMsgbox = new QMessageBox(QMessageBox::Question, software_name, tr("If there is no response for a long time, it is recommended to restart the software."), QMessageBox::Yes | QMessageBox::No, this);
     connect(restartMsgbox, &QMessageBox::accepted, this, [=,this] { MW_dialog_message("", "RestartProgram"); });
     auto restartMsgboxTimer = new MessageBoxTimer(this, restartMsgbox, 10000);
-
+    QMutex * mutex = new QMutex();
+    mutex->lock();
+    runOnUiThread([this, mutex](){
+        profile_stop(false, true, true);
+        mutex->unlock();
+    });
     runOnNewThread([=, this] {
-        // stop current running
-        if (running != nullptr) {
-            profile_stop(false, true, true);
-        }
+        mutex->lock();
+        mutex->unlock();
+        delete mutex;
         // do start
         MW_show_log(">>>>>>>> " + tr("Starting profile %1").arg(ent->bean->DisplayTypeAndName()));
         if (!profile_start_stage2()) {
@@ -657,7 +660,9 @@ void MainWindow::profile_stop(bool crash, bool block, bool manual) {
             bool rpcOK;
             QString error = defaultClient->Stop(&rpcOK);
             if (rpcOK && !error.isEmpty()) {
-                runOnUiThread([=,this] { MessageBoxWarning(tr("Stop return error"), error); });
+                runOnUiThread([=,this] { 
+                    QMessageBox::warning(this, tr("Stop return error"), error); 
+                });
                 return false;
             } else if (!rpcOK) {
                 return false;
diff --git a/src/ui/profile/dialog_edit_profile.cpp b/src/ui/profile/dialog_edit_profile.cpp
index 30427181..8852fb76 100755
--- a/src/ui/profile/dialog_edit_profile.cpp
+++ b/src/ui/profile/dialog_edit_profile.cpp
@@ -6,6 +6,7 @@
 #include "nekobox/ui/profile/edit_custom.h"
 #include "nekobox/ui/profile/edit_extra_core.h"
 #include "nekobox/ui/profile/edit_mieru.h"
+#include "nekobox/ui/profile/edit_tor.h"
 #include "nekobox/ui/profile/edit_quic.h"
 #include "nekobox/ui/profile/edit_shadowsocks.h"
 #include "nekobox/ui/profile/edit_socks_http.h"
@@ -46,7 +47,7 @@
       this);
 #define LOAD_TYPE(a)                                                           \
   ui->type->addItem(                                                           \
-      Configs::ProfileManager::NewProxyEntity(a)->bean->DisplayType(), a);
+      Configs::ProfileManager::GetDisplayType(a), a);
 
 DialogEditProfile::DialogEditProfile(const QString &_type, int profileOrGroupId,
                                      QWidget *parent)
@@ -219,6 +220,7 @@ DialogEditProfile::DialogEditProfile(const QString &_type, int profileOrGroupId,
                       "internal-full");
     ui->type->addItem(tr("Extra Core"), "extracore");
     LOAD_TYPE("chain")
+    LOAD_TYPE("tor")
 
     // type changed
     connect(ui->type, &QComboBox::currentIndexChanged, this,
@@ -316,12 +318,18 @@ void DialogEditProfile::typeSelected(const QString &newType) {
     auto _innerWidget = new EditMieru(this);
     innerWidget = _innerWidget;
     innerEditor = _innerWidget;
+  } else if (type == "tor") {
+      auto _innerWidget = new EditTor(this);
+      innerWidget = _innerWidget;
+      innerEditor = _innerWidget;
   } else {
     validType = false;
   }
 
   if (!validType) {
-    MessageBoxWarning(newType, "Wrong type");
+    runOnUiThread([newType, this](){
+      QMessageBox::warning(this, newType, "Wrong type");
+    });
     return;
   }
 
@@ -553,7 +561,10 @@ void DialogEditProfile::accept() {
   if (newEnt) {
     auto ok = Configs::profileManager->AddProfile(ent);
     if (!ok) {
-      MessageBoxWarning("???", "id exists");
+      
+    runOnUiThread([this](){
+      QMessageBox::warning(this, "???", "id exists");
+    });
     }
   } else {
     auto changed = ent->Save();
@@ -637,14 +648,20 @@ void DialogEditProfile::on_apply_to_group_clicked() {
   } else {
     auto group = Configs::profileManager->GetGroup(ent->gid);
     if (group == nullptr) {
-      MessageBoxWarning("failed", "unknown group");
+      
+    runOnUiThread([this](){
+      QMessageBox::warning(this, "failed", "unknown group");
+    });
+      
       return;
     }
     // save this
     if (onEnd()) {
       ent->Save();
     } else {
-      MessageBoxWarning("failed", "failed to save");
+    runOnUiThread([this](){
+      QMessageBox::warning(this, "failed","failed to save");
+    });
       return;
     }
     // copy keys
diff --git a/src/ui/profile/edit_tor.cpp b/src/ui/profile/edit_tor.cpp
new file mode 100755
index 00000000..99095058
--- /dev/null
+++ b/src/ui/profile/edit_tor.cpp
@@ -0,0 +1,29 @@
+#include "nekobox/ui/profile/edit_tor.h"
+#include <QFileDialog>
+
+#include "nekobox/configs/proxy/TorBean.hpp"
+
+EditTor::EditTor(QWidget *parent) : QWidget(parent), ui(new Ui::EditTor) {
+    ui->setupUi(this);
+}
+
+EditTor::~EditTor() {
+    delete ui;
+}
+
+void EditTor::onStart(std::shared_ptr<Configs::ProxyEntity> _ent) {
+    this->ent = _ent;
+    auto bean = this->ent->TorBean();
+    P_LOAD_STRINGLIST(extra_args)
+    P_LOAD_STRING(executable_path)
+    P_LOAD_STRING(data_directory)
+
+}
+
+bool EditTor::onEnd() {
+    auto bean = this->ent->TorBean();
+    P_SAVE_STRING(executable_path)
+    P_SAVE_STRING(data_directory)
+    P_SAVE_STRINGLIST(extra_args)
+    return true;
+}
diff --git a/src/ui/setting/Icon.cpp b/src/ui/setting/Icon.cpp
index aa92c070..8ad39012 100755
--- a/src/ui/setting/Icon.cpp
+++ b/src/ui/setting/Icon.cpp
@@ -1,5 +1,5 @@
 #include "nekobox/ui/setting/Icon.hpp"
-
+#include "nekobox/global/GuiUtils.hpp"
 #include <QCoreApplication>
 #include <QPainter>
 #include <QDir>
@@ -15,24 +15,16 @@ QPixmap Icon::GetTrayIcon(TrayIconStatus status) {
     QPixmap pixmap;
     auto pixmap_read = QPixmap(SYSTRAY_ICON("icon.png"), FORMAT);
     if (!pixmap_read.isNull()) pixmap = pixmap_read;
-
-    if (status == TrayIconStatus::NONE) return pixmap;
+    if (!indicatorRuleMap.contains(status)) return pixmap;
+    auto rule = indicatorRuleMap[status];
 
     auto p = QPainter(&pixmap);
     auto side = pixmap.width();
-    auto radius = side * 0.4;
-    auto d = side * 0.4;
-    auto margin = side * 0.04;
-
-    if (status == TrayIconStatus::RUNNING) {
-        p.setBrush(QBrush(Qt::darkGreen));
-    } else if (status == TrayIconStatus::SYSTEM_PROXY) {
-        p.setBrush(QBrush(Qt::blue));
-    } else if (status == TrayIconStatus::VPN) {
-        p.setBrush(QBrush(QColor(165, 42, 42)));
-    } else if (status == TrayIconStatus::DNS) {
-        p.setBrush(QBrush(Qt::darkMagenta));
-    }
+    auto radius = side * rule.radius;
+    auto d = side * rule.diameter;
+    auto margin = side * rule.margin;
+    
+    p.setBrush(QBrush(rule.color));
     p.drawRoundedRect(
         QRect(side - d - margin,
               side - d - margin,
@@ -41,6 +33,5 @@ QPixmap Icon::GetTrayIcon(TrayIconStatus status) {
               radius,
               radius);
     p.end();
-
     return pixmap;
 }
diff --git a/src/ui/setting/RouteItem.cpp b/src/ui/setting/RouteItem.cpp
index 507947b7..15914825 100755
--- a/src/ui/setting/RouteItem.cpp
+++ b/src/ui/setting/RouteItem.cpp
@@ -4,6 +4,7 @@
 #include "nekobox/dataStore/RouteEntity.h"
 #include "nekobox/dataStore/Database.hpp"
 #include "nekobox/api/RPC.h"
+#include "nekobox/global/GuiUtils.hpp"
 #include "nekobox/configs/ConfigBuilder.hpp"
 #include <qnamespace.h>
 #include <nekobox/global/HTTPRequestHelper.hpp>
@@ -129,6 +130,7 @@ RouteItem::RouteItem(QWidget *parent, const std::shared_ptr<Configs::RoutingChai
         auto ruleItem = chain->Rules[currentIndex];
         int outbound_id = ruleItem->outboundID;
         window->profile_selected(outbound_id, true);
+        window->last_id = outbound_id;
         window->setWindowTitle(QCoreApplication::translate(
         "DialogGroupChooseProxy","Select outbound"));
         window->ui->proxy_label->setText(QCoreApplication::translate(
@@ -161,13 +163,38 @@ RouteItem::RouteItem(QWidget *parent, const std::shared_ptr<Configs::RoutingChai
                 break;
         }
 
+        window->is_for_routeprofile = true;
+
+        connect(radio1, &QRadioButton::clicked, this, [window](bool b)->void{
+            window->profile_selected(-1);
+        });
+
+        connect(radio2, &QRadioButton::clicked, this, [window](bool b)->void{
+            window->profile_selected(-2);
+        });
+
+        connect(radio3, &QRadioButton::clicked, this, [window](bool b)->void{
+            window->profile_selected(window->last_id);
+        });
+
+        connect(window, &DialogGroupChooseProxy::select_proxy,
+                this, [=](int id)->void{
+            if (id >= 0){
+                window->last_id = id;
+                runOnUiThread([radio3]()->void{
+                    radio3->setChecked(true);
+                });
+            }
+        });
+
         connect(window, &DialogGroupChooseProxy::set_proxy, 
-                this, [ruleItem, this, radio1, radio2, radio3](int id)->void{
+                this, [radio1, radio2, ruleItem, this](int id)->void{
             if (radio1->isChecked()){
                 id = -1;
             } else if (radio2->isChecked()){
                 id = -2;
             }
+
             proxy_chooser->setText(DialogEditGroup::get_proxy_name(id, true));
             ruleItem->outboundID = id;
             chain->Rules[currentIndex]->set_field_value("outbound", {QString::number(id)});
diff --git a/src/ui/setting/ThemeManager.cpp b/src/ui/setting/ThemeManager.cpp
index 83eb423d..9acb6ecd 100755
--- a/src/ui/setting/ThemeManager.cpp
+++ b/src/ui/setting/ThemeManager.cpp
@@ -4,7 +4,6 @@
 #include <QPalette>
 
 #include "nekobox/ui/setting/ThemeManager.hpp"
-#include "iostream"
 
 ThemeManager *themeManager = new ThemeManager;
 
diff --git a/src/ui/setting/dialog_basic_settings.cpp b/src/ui/setting/dialog_basic_settings.cpp
index fbf1c058..ea778c55 100755
--- a/src/ui/setting/dialog_basic_settings.cpp
+++ b/src/ui/setting/dialog_basic_settings.cpp
@@ -165,7 +165,7 @@ DialogBasicSettings::DialogBasicSettings(MainWindow *parent)
     ui->theme->addItems(QStyleFactory::keys());
     ui->theme->addItem("QDarkStyle");
     //
-    bool ok;
+//    bool ok;
     ui->theme->setCurrentText(settings.value("theme", "").toString());
     //
     connect(ui->theme, static_cast<void (QComboBox::*)(int)>(&QComboBox::currentIndexChanged), this, [=,this](int index) {
@@ -363,7 +363,7 @@ void DialogBasicSettings::accept() {
     Configs::dataStore->ntp_server_port = ui->ntp_port->text().toInt();
     Configs::dataStore->ntp_interval = ui->ntp_interval->currentText();
 
-    int width, height, X, Y;
+ //   int width, height, X, Y;
     // Startup
     settings.setValue("language", locale);
     S_SAVE_BOOL(save_geometry);
diff --git a/src/ui/setting/dialog_vpn_settings.cpp b/src/ui/setting/dialog_vpn_settings.cpp
index d487b57f..593721b7 100755
--- a/src/ui/setting/dialog_vpn_settings.cpp
+++ b/src/ui/setting/dialog_vpn_settings.cpp
@@ -1,3 +1,8 @@
+#ifdef _WIN32
+#include <winsock2.h>
+#include <windows.h>
+#endif
+
 #include "nekobox/ui/setting/dialog_vpn_settings.h"
 
 #include "nekobox/configs/proxy/Preset.hpp"
