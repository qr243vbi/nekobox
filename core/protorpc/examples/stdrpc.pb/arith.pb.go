// Code generated by protoc-gen-go. DO NOT EDIT.
// source: arith.proto

/*
Package service is a generated protocol buffer package.

It is generated from these files:
	arith.proto
	echo.proto

It has these top-level messages:
	ArithRequest
	ArithResponse
	EchoRequest
	EchoResponse
*/
package service

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import "bufio"
import "crypto/tls"
import "errors"
import "io"
import "log"
import "net"
import "net/http"
import "net/rpc"
import "time"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ArithRequest struct {
	A int32 `protobuf:"varint,1,opt,name=a" json:"a,omitempty"`
	B int32 `protobuf:"varint,2,opt,name=b" json:"b,omitempty"`
}

func (m *ArithRequest) Reset()                    { *m = ArithRequest{} }
func (m *ArithRequest) String() string            { return proto.CompactTextString(m) }
func (*ArithRequest) ProtoMessage()               {}
func (*ArithRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ArithRequest) GetA() int32 {
	if m != nil {
		return m.A
	}
	return 0
}

func (m *ArithRequest) GetB() int32 {
	if m != nil {
		return m.B
	}
	return 0
}

type ArithResponse struct {
	C int32 `protobuf:"varint,1,opt,name=c" json:"c,omitempty"`
}

func (m *ArithResponse) Reset()                    { *m = ArithResponse{} }
func (m *ArithResponse) String() string            { return proto.CompactTextString(m) }
func (*ArithResponse) ProtoMessage()               {}
func (*ArithResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ArithResponse) GetC() int32 {
	if m != nil {
		return m.C
	}
	return 0
}

func init() {
	proto.RegisterType((*ArithRequest)(nil), "service.ArithRequest")
	proto.RegisterType((*ArithResponse)(nil), "service.ArithResponse")
}

type ArithService interface {
	Add(in *ArithRequest, out *ArithResponse) error
	Mul(in *ArithRequest, out *ArithResponse) error
	Div(in *ArithRequest, out *ArithResponse) error
	Error(in *ArithRequest, out *ArithResponse) error
}

// AcceptArithServiceClient accepts connections on the listener and serves requests
// for each incoming connection.  Accept blocks; the caller typically
// invokes it in a go statement.
func AcceptArithServiceClient(lis net.Listener, x ArithService) {
	srv := rpc.NewServer()
	if err := srv.RegisterName("service.ArithService", x); err != nil {
		log.Fatal(err)
	}

	for {
		conn, err := lis.Accept()
		if err != nil {
			log.Fatalf("lis.Accept(): %v\n", err)
		}
		go srv.ServeConn(conn)
	}
}

// RegisterArithService publish the given ArithService implementation on the server.
func RegisterArithService(srv *rpc.Server, x ArithService) error {
	if err := srv.RegisterName("service.ArithService", x); err != nil {
		return err
	}
	return nil
}

// NewArithServiceServer returns a new ArithService Server.
func NewArithServiceServer(x ArithService) *rpc.Server {
	srv := rpc.NewServer()
	if err := srv.RegisterName("service.ArithService", x); err != nil {
		log.Fatal(err)
	}
	return srv
}

// ListenAndServeArithService listen announces on the local network address laddr
// and serves the given ArithService implementation.
func ListenAndServeArithService(network, addr string, x ArithService) error {
	lis, err := net.Listen(network, addr)
	if err != nil {
		return err
	}
	defer lis.Close()

	srv := rpc.NewServer()
	if err := srv.RegisterName("service.ArithService", x); err != nil {
		return err
	}

	for {
		conn, err := lis.Accept()
		if err != nil {
			log.Fatalf("lis.Accept(): %v\n", err)
		}
		go srv.ServeConn(conn)
	}
}

// ServeArithService serves the given ArithService implementation.
func ServeArithService(conn io.ReadWriteCloser, x ArithService) {
	srv := rpc.NewServer()
	if err := srv.RegisterName("service.ArithService", x); err != nil {
		log.Fatal(err)
	}
	srv.ServeConn(conn)
}

type ArithServiceClient struct {
	*rpc.Client
}

// NewArithServiceClient returns a ArithService stub to handle
// requests to the set of ArithService at the other end of the connection.
func NewArithServiceClient(conn io.ReadWriteCloser) *ArithServiceClient {
	c := rpc.NewClient(conn)
	return &ArithServiceClient{c}
}

func (c *ArithServiceClient) Add(in *ArithRequest) (out *ArithResponse, err error) {
	if in == nil {
		in = new(ArithRequest)
	}
	type Validator interface {
		Validate() error
	}
	if x, ok := proto.Message(in).(Validator); ok {
		if err := x.Validate(); err != nil {
			return nil, err
		}
	}
	out = new(ArithResponse)
	if err = c.Call("service.ArithService.Add", in, out); err != nil {
		return nil, err
	}
	if x, ok := proto.Message(out).(Validator); ok {
		if err := x.Validate(); err != nil {
			return out, err
		}
	}
	return out, nil
}

func (c *ArithServiceClient) AsyncAdd(in *ArithRequest, out *ArithResponse, done chan *rpc.Call) *rpc.Call {
	if in == nil {
		in = new(ArithRequest)
	}
	return c.Go(
		"service.ArithService.Add",
		in, out,
		done,
	)
}

func (c *ArithServiceClient) Mul(in *ArithRequest) (out *ArithResponse, err error) {
	if in == nil {
		in = new(ArithRequest)
	}
	type Validator interface {
		Validate() error
	}
	if x, ok := proto.Message(in).(Validator); ok {
		if err := x.Validate(); err != nil {
			return nil, err
		}
	}
	out = new(ArithResponse)
	if err = c.Call("service.ArithService.Mul", in, out); err != nil {
		return nil, err
	}
	if x, ok := proto.Message(out).(Validator); ok {
		if err := x.Validate(); err != nil {
			return out, err
		}
	}
	return out, nil
}

func (c *ArithServiceClient) AsyncMul(in *ArithRequest, out *ArithResponse, done chan *rpc.Call) *rpc.Call {
	if in == nil {
		in = new(ArithRequest)
	}
	return c.Go(
		"service.ArithService.Mul",
		in, out,
		done,
	)
}

func (c *ArithServiceClient) Div(in *ArithRequest) (out *ArithResponse, err error) {
	if in == nil {
		in = new(ArithRequest)
	}
	type Validator interface {
		Validate() error
	}
	if x, ok := proto.Message(in).(Validator); ok {
		if err := x.Validate(); err != nil {
			return nil, err
		}
	}
	out = new(ArithResponse)
	if err = c.Call("service.ArithService.Div", in, out); err != nil {
		return nil, err
	}
	if x, ok := proto.Message(out).(Validator); ok {
		if err := x.Validate(); err != nil {
			return out, err
		}
	}
	return out, nil
}

func (c *ArithServiceClient) AsyncDiv(in *ArithRequest, out *ArithResponse, done chan *rpc.Call) *rpc.Call {
	if in == nil {
		in = new(ArithRequest)
	}
	return c.Go(
		"service.ArithService.Div",
		in, out,
		done,
	)
}

func (c *ArithServiceClient) Error(in *ArithRequest) (out *ArithResponse, err error) {
	if in == nil {
		in = new(ArithRequest)
	}
	type Validator interface {
		Validate() error
	}
	if x, ok := proto.Message(in).(Validator); ok {
		if err := x.Validate(); err != nil {
			return nil, err
		}
	}
	out = new(ArithResponse)
	if err = c.Call("service.ArithService.Error", in, out); err != nil {
		return nil, err
	}
	if x, ok := proto.Message(out).(Validator); ok {
		if err := x.Validate(); err != nil {
			return out, err
		}
	}
	return out, nil
}

func (c *ArithServiceClient) AsyncError(in *ArithRequest, out *ArithResponse, done chan *rpc.Call) *rpc.Call {
	if in == nil {
		in = new(ArithRequest)
	}
	return c.Go(
		"service.ArithService.Error",
		in, out,
		done,
	)
}

// DialArithService connects to an ArithService at the specified network address.
func DialArithService(network, addr string) (*ArithServiceClient, error) {
	c, err := rpc.Dial(network, addr)
	if err != nil {
		return nil, err
	}
	return &ArithServiceClient{c}, nil
}

// DialArithServiceTimeout connects to an ArithService at the specified network address.
func DialArithServiceTimeout(network, addr string, timeout time.Duration) (*ArithServiceClient, error) {
	conn, err := net.DialTimeout(network, addr, timeout)
	if err != nil {
		return nil, err
	}
	return &ArithServiceClient{rpc.NewClient(conn)}, nil
}

// DialArithServiceHTTP connects to an HTTP RPC server at the specified network address
// listening on the default HTTP RPC path.
func DialArithServiceHTTP(network, address string) (*ArithServiceClient, error) {
	return DialArithServiceHTTPPath(network, address, rpc.DefaultRPCPath)
}

// DialArithServiceHTTPPath connects to an HTTP RPC server
// at the specified network address and path.
func DialArithServiceHTTPPath(network, address, path string) (*ArithServiceClient, error) {
	conn, err := net.Dial(network, address)
	if err != nil {
		return nil, err
	}
	return dialArithServicePath(network, address, path, conn)
}

// DialArithServiceHTTPS connects to an HTTPS RPC server at the specified network address
// listening on the default HTTP RPC path.
func DialArithServiceHTTPS(network, address string, tlsConfig *tls.Config) (*ArithServiceClient, error) {
	return DialArithServiceHTTPSPath(network, address, rpc.DefaultRPCPath, tlsConfig)
}

// DialArithServiceHTTPSPath connects to an HTTPS RPC server
// at the specified network address and path.
func DialArithServiceHTTPSPath(network, address, path string, tlsConfig *tls.Config) (*ArithServiceClient, error) {
	conn, err := tls.Dial(network, address, tlsConfig)
	if err != nil {
		return nil, err
	}
	return dialArithServicePath(network, address, path, conn)
}

func dialArithServicePath(network, address, path string, conn net.Conn) (*ArithServiceClient, error) {
	const net_rpc_connected = "200 Connected to Go RPC"

	io.WriteString(conn, "CONNECT "+path+" HTTP/1.0\n\n")

	// Require successful HTTP response
	// before switching to RPC protocol.
	resp, err := http.ReadResponse(bufio.NewReader(conn), &http.Request{Method: "CONNECT"})
	if err == nil && resp.Status == net_rpc_connected {
		return &ArithServiceClient{rpc.NewClient(conn)}, nil
	}
	if err == nil {
		err = errors.New("unexpected HTTP response: " + resp.Status)
	}
	conn.Close()
	return nil, &net.OpError{
		Op:   "dial-http",
		Net:  network + " " + address,
		Addr: nil,
		Err:  err,
	}
}

func init() { proto.RegisterFile("arith.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 159 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4e, 0x2c, 0xca, 0x2c,
	0xc9, 0xd0, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x2f, 0x4e, 0x2d, 0x2a, 0xcb, 0x4c, 0x4e,
	0x55, 0xd2, 0xe2, 0xe2, 0x71, 0x04, 0x89, 0x07, 0xa5, 0x16, 0x96, 0xa6, 0x16, 0x97, 0x08, 0xf1,
	0x70, 0x31, 0x26, 0x4a, 0x30, 0x2a, 0x30, 0x6a, 0xb0, 0x06, 0x31, 0x26, 0x82, 0x78, 0x49, 0x12,
	0x4c, 0x10, 0x5e, 0x92, 0x92, 0x2c, 0x17, 0x2f, 0x54, 0x6d, 0x71, 0x41, 0x7e, 0x5e, 0x71, 0x2a,
	0x48, 0x3a, 0x19, 0xa6, 0x38, 0xd9, 0xe8, 0x05, 0x23, 0xd4, 0xac, 0x60, 0x88, 0xd9, 0x42, 0x26,
	0x5c, 0xcc, 0x89, 0x29, 0x29, 0x42, 0xa2, 0x7a, 0x50, 0xcb, 0xf4, 0x90, 0x6d, 0x92, 0x12, 0x43,
	0x17, 0x86, 0x1a, 0x6a, 0xc2, 0xc5, 0x9c, 0x5b, 0x9a, 0x43, 0x86, 0xae, 0x94, 0xcc, 0x32, 0x52,
	0x75, 0x99, 0x71, 0xb1, 0xa6, 0x16, 0x15, 0xe5, 0x17, 0x91, 0xa8, 0x2f, 0x89, 0x0d, 0x1c, 0x8a,
	0xc6, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa2, 0x62, 0xfd, 0xbd, 0x54, 0x01, 0x00, 0x00,
}
